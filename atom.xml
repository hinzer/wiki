<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hinzer&#39;s Wiki</title>
  
  <subtitle>先打基础</subtitle>
  <link href="/wiki/atom.xml" rel="self"/>
  
  <link href="https://hinzer.github.io/wiki/"/>
  <updated>2020-04-05T00:35:09.000Z</updated>
  <id>https://hinzer.github.io/wiki/</id>
  
  <author>
    <name>hinzer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>07 编译android kernel</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/07%20%E7%BC%96%E8%AF%91android%20goldfish%E5%86%85%E6%A0%B8(x86_64)/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/07 编译android goldfish内核(x86_64)/</id>
    <published>2020-04-05T00:35:10.000Z</published>
    <updated>2020-04-05T00:35:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android-linux内核">Android linux内核</h3><p>Android并没有使用标准的Linux内核，而是做了很多的修改。AOSP网站提供了适应各种芯片或设备的linux内核源码的仓，只有少部分google设备支持的内核源码可以通过<a href="https://source.android.google.cn/setup/build/building-kernels?hl=zh-cn#downloading" rel="external nofollow noopener noreferrer" target="_blank">repo构建</a>,其他的需要做一些编译配置。</p><h3 id="手动编译内核">手动编译内核</h3><p>这里选择emulator模拟器跑Android内核，所以选择goldfish版本作为我的的Linux Kernel，下面通过编译goldfish内核来介绍这个过程。<br>按照<a href="https://source.android.com/setup/build/building-kernels-deprecated" rel="external nofollow noopener noreferrer" target="_blank">官方的教程</a>没有找到<code>xxx_defconfig</code>编译配置文件，之后在网上找到一篇相似的<a href="https://my.oschina.net/wuqingyi/blog/903421" rel="external nofollow noopener noreferrer" target="_blank">博客</a>，以下步骤基本上是按照那个教程来的。<br>1、下载源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:kernel$ git <span class="built_in">clone</span> https://android.googlesource.com/kernel/goldfish</span><br></pre></td></tr></table></figure><p>2、查看当前Android系统对应的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ emulator   <span class="comment"># 虚拟机运行起来，点Setting -&gt; Android version 查看内核版本信息</span></span><br></pre></td></tr></table></figure><p>3、检出对应分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:kernel$ <span class="built_in">cd</span> goldfish/</span><br><span class="line">git branch -a</span><br><span class="line"><span class="comment">#....</span></span><br><span class="line"><span class="comment">#....</span></span><br><span class="line">git checkout -b dev remotes/origin/android-goldfish-4.14-dev.20190417  <span class="comment"># 对应的内核版本为4.14</span></span><br><span class="line"><span class="comment">#....</span></span><br></pre></td></tr></table></figure><p>4、进行编译配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/hinzer/<span class="built_in">source</span>/android-10/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9/bin</span><br><span class="line"><span class="built_in">export</span> ARCH=x86_64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=x86_64-linux-android-</span><br><span class="line"><span class="built_in">export</span> REAL_CROSS_COMPILE=x86_64-linux-android-</span><br></pre></td></tr></table></figure><p>5、编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/hinzer/<span class="built_in">source</span>/android-10/prebuilts/qemu-kernel/build-kernel.sh  --arch=x86_64    <span class="comment"># 需要在kernel的源码的根目录下执行</span></span><br></pre></td></tr></table></figure><p>但是出现error，没有发现&quot;x86_64_emu_defconfig&quot;这个文件。于是我将<code>x86_64_defconfig</code>改为<code>x86_64_emu_defconfig</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp -a /home/hinzer/<span class="built_in">source</span>/android-10/kernel/goldfish/arch/x86/configs/x86_64_defconfig /home/hinzer/<span class="built_in">source</span>/android-10/kernel/goldfish/arch/x86/configs/x86_64_emu_defconfig</span><br><span class="line">/home/hinzer/<span class="built_in">source</span>/android-10/prebuilts/qemu-kernel/build-kernel.sh  --arch=x86_64    <span class="comment"># 继续编译</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Kernel: arch/x86/boot/bzImage is ready  (<span class="comment">#1)</span></span><br><span class="line">Kernel x86_64_emu prebuilt images (kernel-qemu and vmlinux-qemu) copied to /tmp/kernel-qemu/x86_64-4.14.88 successfully !</span><br></pre></td></tr></table></figure><p>6、加载内核并运行系统<br>emulator启动相关的参数，可参考<a href="https://developer.android.google.cn/studio/run/emulator-commandline#startup-options" rel="external nofollow noopener noreferrer" target="_blank">官方手册 - 命令行启动选项</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译生成的内核放在/tmp/kernel-qemu/x86_64-3.10.0/kernel-qemu</span></span><br><span class="line">hinzer@ubuntu:android-10$ emulator -kernel /tmp/kernel-qemu/x86_64-4.14.88/kernel-qemu  <span class="comment"># 配置参数</span></span><br></pre></td></tr></table></figure><p>7、再次查看当前Android系统对应的内核版本</p><h3 id="补充">补充</h3><p>将编译出的<code>kernel-qemu</code>加载到emulator上发现界面直接卡死，adb devices命令也连接不上。初步怀疑是编译的linux内核版本不对，导致无法正常启动。(这个问题暂时还没有解决，目前单独编译不影响)<br>另外，进一步研究了kernel源码下的<code>README</code>文件，发现<code>make ${PLATFORM}_defconfig</code>说明。想到之前按照官方的步骤可能出了一点差错，修改为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd goldfish</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ARCH</span>=x86     # cpu架构</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CROSS_COMPILE</span>=x86_64-linux-android-</span><br><span class="line">make x86_64_defconfig    # 将arch/<span class="variable">$ARCH</span>/configs/xxx_defconfig写入.config文件，编译阶段build系统会检索</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>success!!此时编译出的映像文件输出<code>arch/x86/boot/bzImage</code>,</p><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/build/building-kernels-deprecated" rel="external nofollow noopener noreferrer" target="_blank">手动编译内核</a></li><li><a href="https://my.oschina.net/wuqingyi/blog/903421" rel="external nofollow noopener noreferrer" target="_blank">编译x86_64 android 7.1及goldfish内核</a></li><li><a href="https://blog.51cto.com/ticktick/1654759" rel="external nofollow noopener noreferrer" target="_blank">Android内核开发：源码的版本与分支详解</a></li><li><a href="https://source.android.google.cn/devices/architecture/kernel/android-common?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">Android 通用内核</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android-linux内核&quot;&gt;Android linux内核&lt;/h3&gt;
&lt;p&gt;Android并没有使用标准的Linux内核，而是做了很多的修改。AOSP网站提供了适应各种芯片或设备的linux内核源码的仓，只有少部分google设备支持的内核源码可以通过&lt;a 
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>04 x8架构</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/04%20x86%E6%9E%B6%E6%9E%84/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/04 x86架构/</id>
    <published>2020-04-05T00:32:02.000Z</published>
    <updated>2020-04-05T00:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先了解计算机底层最基本的工作原理，以便于以后能理解Linux系统的运作模式!!</p></blockquote><h3 id="总体概要">总体概要</h3><p>原文中对于x86架构的总结图片，重点牢记这些寄存器的作用，以及段的工作模式<br><img src="https://static001.geekbang.org/resource/image/e2/76/e2e92f2239fe9b4c024d300046536d76.jpeg" alt="总结概要"></p><h3 id="计算机的工作模式-了解一下">计算机的工作模式(了解一下)</h3><p><strong>1、 CPU、总线、内存</strong><br><img src="https://static001.geekbang.org/resource/image/fa/9b/fa6c2b6166d02ac37637d7da4e4b579b.jpeg" alt="计算机的工作模式"><br>对于一个计算机来讲，所有功能看似是<code>输入输出设备</code>的功劳，实际干活的还是<code>CPU</code>。同时CPU通过内存不断的保存和取出中间数据，然后基于中间结果进行进一步的计算。<code>总线</code>是CPU和其他设备的高速通道。</p><ul><li><code>CPU</code>是这台计算机的大脑，所有的设备都围绕它展开。</li><li><code>总线</code>其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。</li><li>最重要的是<code>内存</code>。因为单靠 CPU 是没办法完成计算任务的，很多复杂的计算任务都需要将中间结果保存下来，然后基于中间结果进行进一步的计算。</li></ul><p><strong>2、相互配合工作</strong><br><img src="https://static001.geekbang.org/resource/image/3a/23/3afda18fc38e7e53604e9ebf9cb42023.jpeg" alt="CPU 和内存"><br>首先要了解几个概念的关系，其中</p><ul><li>CPU包括三个部分，<code>运算单元</code>、<code>数据单元</code>和<code>控制单元</code></li><li>进程在内存上有独立的内存空间，相互隔离(但不连续)，每个进程简单的区分<code>代码段</code>和<code>数据段</code></li><li>总线上主要有两类，<code>地址总线</code>操作地址数据，<code>数据总线</code>操作真正的数据</li></ul><blockquote><p>那 CPU 怎么执行这些程序，操作这些数据，产生一些结果，并写入回内存呢?</p></blockquote><ol><li>CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。</li><li>数据单元根据数据的地址，从数据段里读到数据寄存器里，就可以参与运算了。<code>指令 = 操作码(运算单元) + 操作数(数据单元)</code></li><li>运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。</li><li>最终，会有指令将数据写回内存中的数据段。</li></ol><h3 id="x86平台特性-了解一下">x86平台特性(了解一下)</h3><p>x86架构起源于IBM,开端于8086。由于<code>开放、统一、兼容</code>的特性逐渐成为标准，后来Intel的cpu也都基于这个架构<br><img src="https://static001.geekbang.org/resource/image/54/8a/548dfd163066d061d1e882c73e7c2b8a.jpg" alt="x86架构cpu"></p><h3 id="8086的原理-了解一下">8086的原理(了解一下)</h3><p><img src="https://static001.geekbang.org/resource/image/2d/1c/2dc8237e996e699a0361a6b5ffd4871c.jpeg" alt="8086原理"><br><strong>1、 数据单元</strong><br>8086处理器内部有 8 个 16 位的通用寄存器，有些寄存器还能掰开2个8位寄存器来使用。</p><p><strong>2、 控制单元</strong><br><code>IP寄存器</code>指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。<br>每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS代码段寄存器、DS数据段寄存器、SS栈寄存器、ES。</p><p><strong>3、 访问地址模式</strong><br>这个时候内存是分段管理，CPU要访问内存地址通过<code>段启始地址 + 偏移量</code>的方式访问。其中，</p><ul><li>代码段的起始地址在CS寄存器，偏移量在 IP 寄存器中</li><li>数据段的起始地址在DS寄存器，偏移量在通用寄存器中<br>由于是20位地址总线，而寄存器都是16位的。所以8086采用了<code>基地址 &lt;&lt; 4 + 偏移量</code>的方式，其中</li><li>地址访问范围: 2^20 = 1M , 表示一个进程的最大访问空间</li><li>偏移量大小: 2^16=64k ， 表示一个段的最大空间</li></ul><h3 id="32位处理器-重点理解">32位处理器(重点理解)</h3><p>随着计算机的发展，32位总线已经足够应对4G内存。为了x86体系<code>开放、统一、兼容</code>的特性，要兼容原来的模式<br><img src="https://static001.geekbang.org/resource/image/e3/84/e3f4f64e6dfe5591b7d8ef346e8e8884.jpeg" alt="32位处理器"></p><ul><li>对于通用寄存器和IP寄存器有原来的16位扩展到32位，兼容原来的模式。</li><li>而改动比较大，有点不兼容的就是段寄存器(因为之前的20位总线设计太独特了)。其中有<ul><li>段的起始地址从原来放在寄存器中，改为放在内存的某个地方，当然为了快速拿到段起始地址，段寄存器会从内存中拿到 CPU 的描述符高速缓存器中。</li><li>cpu访问内存分位<code>实模式</code>和<code>保护模式</code>。其中<code>实模式</code>是对原来兼容的模式。</li></ul></li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/89417" rel="external nofollow noopener noreferrer" target="_blank">极客时间 - x86架构</a></li><li><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html" rel="external nofollow noopener noreferrer" target="_blank">x86 Assembly Guide</a></li><li><a href="https://www.cnblogs.com/bindot/p/linux6.html" rel="external nofollow noopener noreferrer" target="_blank">Linux学习笔记《六》</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;先了解计算机底层最基本的工作原理，以便于以后能理解Linux系统的运作模式!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;总体概要&quot;&gt;总体概要&lt;/h3&gt;
&lt;p&gt;原文中对于x86架构的总结图片，重点牢记这些寄存器的作用，以及段的工作模式&lt;b
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>06 添加java层系统服务</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/06%20%E6%B7%BB%E5%8A%A0java%E5%B1%82%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/06 添加java层系统服务/</id>
    <published>2020-04-05T00:28:10.000Z</published>
    <updated>2020-04-05T00:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入概念">引入概念</h3><p>目前对android系统体系了解比较少，主要区分一下<code>服务</code>、<code>系统服务</code>这两个概念</p><ul><li><a href="https://developer.android.com/guide/components/services" rel="external nofollow noopener noreferrer" target="_blank">Android服务</a>是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。在android开发中作为一个<code>应用组件</code>,通过继承类<code>extern Service</code>来使用。</li><li><a href="https://blog.csdn.net/u010753159/article/details/52193061" rel="external nofollow noopener noreferrer" target="_blank">Android系统服务</a>。理解为随着andorid系统启动运行的service，分为<code>本地守护进程</code>、<code>Native系统服务</code>和<code>Java系统服务</code>。</li></ul><p>有相同点更有不同点，但请不要把两个概念弄混淆了!!!<br>然后下面记录一下<code>添加自定义一个java系统服务</code>的步骤，参考于<a href="http://qiushao.net/2019/12/20/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/7-%E6%B7%BB%E5%8A%A0java%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/" rel="external nofollow noopener noreferrer" target="_blank">qiushao</a>大神的blog。基于<code>android-10</code>版本的AOSP源码，</p><h3 id="添加服务">添加服务</h3><p><strong>1、 定义服务接口</strong><br>首先我们得定义我们的服务名是什么，提供什么样的接口。在<code>frameworks/base/core/java/android</code>目录下添加pure文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree frameworks/base/core/java/android/pure</span><br><span class="line">frameworks/base/core/java/android/pure</span><br><span class="line">└── IHelloService.aidl     # 使用 aidl 定义服务接口</span><br><span class="line"></span><br><span class="line">0 directories, 1 file</span><br></pre></td></tr></table></figure><p>定义接口文件<code>IHelloService.aidl</code>，模块名<code>IHelloService</code>,接口<code>hello</code>将实现播放指定路径的音频文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package android.pure;</span><br><span class="line">interface IHelloService &#123;</span><br><span class="line">    void hello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>frameworks/base/Android.bp</code>文件中找到模块名<code>framework-defaults</code>，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;core/java/android/pure/IHelloService.aidl&quot;,</span><br></pre></td></tr></table></figure><p><em>此时，进入 <code>framework/base</code> 目录执行 <code>mm -j</code> 命令编译 <code>framework.jar</code> 模块。<br>编译成功后，会在 <code>out/soong/.intermediates/frameworks/base/framework/android_common/gen/aidl/frameworks/base/core/java/android/pure</code> 目录生成 <code>IHelloService.java</code> 这个文件</em></p><p><strong>2、 实现接口</strong><br>然后在<code>frameworks/base/services/core/java/com/android/server</code>下创建<code>HelloService.java</code>文件(接口实现) 内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.android.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.pure.IHelloService;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">IHelloService</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"HelloService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"create hello service"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"hello "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、 将服务添加到 ServiceManager</strong><br>修改 <code>frameworks/base/services/java/com/android/server/SystemServer.java</code> 文件，在<code>startOtherServices</code>方法里面增加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// add hello service</span><br><span class="line">traceBeginAndSlog(&quot;HelloService&quot;);</span><br><span class="line">ServiceManager.addService(&quot;HelloService&quot;, new HelloService());</span><br><span class="line">traceEnd();</span><br></pre></td></tr></table></figure><p><strong>4、 编译验证 &amp; 系统无法启动</strong><br>现在已经实现的<code>HelloService</code>接口模块，并添加到<code>ServiceManager</code>。开始尝试整编下android源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ./build/envsetup.sh   <span class="comment"># 导出环境变量(之前执行过了)</span></span><br><span class="line">$ lunch product01-eng          <span class="comment"># 选择Product</span></span><br><span class="line">$ make api-stubs-docs-update-current-api -j4            <span class="comment"># 更新api接口</span></span><br><span class="line">$ make -j4            <span class="comment"># 编译</span></span><br></pre></td></tr></table></figure><p>然后启动<code>emulator</code>虚拟机，发现一直停留在logo界面，说明系统没起来。。这时候可以adb调试，我们查看一下log记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ emulator      <span class="comment"># 发现android系统界面没起来</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">$ adb shell logcat -b all &gt; logSystem.txt    <span class="comment"># 抓取android层的 log</span></span><br><span class="line">...</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>日志中检索我们想要的关键字<code>HelloService</code>,发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">04-02 01:24:25.871  2224  2224 I SystemServer: HelloService</span><br><span class="line">04-02 01:24:25.871  1528  1528 I auditd  : avc:  denied  &#123; add &#125; for service=HelloService pid=2224 uid=1000 scontext=u:r:system_server:s0 tcontext=u:object_r:default_android_service:s0 tclass=service_manager permissive=0</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  : ******************************************</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  : ************ Failure starting system services</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  : java.lang.SecurityException</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.BinderProxy.transactNative(Native Method)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.BinderProxy.transact(BinderProxy.java:510)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.ServiceManagerProxy.addService(ServiceManagerNative.java:156)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.ServiceManager.addService(ServiceManager.java:192)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.ServiceManager.addService(ServiceManager.java:161)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.server.SystemServer.startOtherServices(SystemServer.java:920)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.server.SystemServer.run(SystemServer.java:512)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.server.SystemServer.main(SystemServer.java:349)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:908)</span><br><span class="line">04-02 01:24:25.871  2224  2224 D SystemServerTiming: HelloService took to complete: 1ms</span><br><span class="line">04-02 01:24:25.871  2224  2224 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main</span><br></pre></td></tr></table></figure><p>然后定位到这一句<code>04-02 01:24:25.871  1528  1528 I auditd  : avc:  denied  { add } for service=HelloService pid=2224 uid=1000 scontext=u:r:system_server:s0 tcontext=u:object_r:default_android_service:s0 tclass=service_manager permissive=0</code>,不理解没关系，google一下。发现是selinux方面的原因。</p><p>为了进一步验证猜想，将系统中的<code>selinux</code>关掉试试。通过<code>setenforce 0</code>命令，重启系统发现正常了，印证了之前的猜想，确实selinux配置的原因。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell setenforce 0   <span class="comment"># 禁用selinux</span></span><br><span class="line"></span><br><span class="line">$ emulator -wipe-data      <span class="comment"># 擦掉data区，重启系统</span></span><br></pre></td></tr></table></figure><p><strong>5、 设置selinux规则</strong><br>然后我们只需要添加这个自定义服务<code>HelloService</code>相关的 SELinux 规则。为了方便之后验证，打开selinux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell setenforce 1   <span class="comment"># 打开selinux</span></span><br></pre></td></tr></table></figure><p>Android 10 的 selinux 规则是放在 <code>system/sepolicy</code> 目录下的。不怎么了解SELinux规则，可以参考现有的系统服务的规则去添加，这里参考的是 <code>network_time_update_service</code> 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> system/sepolicy    <span class="comment"># selinux规则在这个目录</span></span><br><span class="line">$ grep -nr network_time_update_service   <span class="comment"># 查找network_time_update_service服务相关的selinux配置</span></span><br></pre></td></tr></table></figure><p>涉及到的文件很多，有部分文件是不需要修改的，我们先把找到的所有 service.te 和 service_contexts 都参考 network_time_update_service 加上 HelloService 的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ find -name service.te</span><br><span class="line">./prebuilts/api/27.0/public/service.te   # 需要</span><br><span class="line">./prebuilts/api/28.0/public/service.te   # 需要</span><br><span class="line">./prebuilts/api/28.0/private/service.te</span><br><span class="line">./prebuilts/api/29.0/public/service.te    # 需要</span><br><span class="line">./prebuilts/api/29.0/private/service.te</span><br><span class="line">./prebuilts/api/26.0/public/service.te   # 需要</span><br><span class="line">./public/service.te                 # 需要</span><br><span class="line">./private/service.te</span><br><span class="line">$ find -name service_contexts</span><br><span class="line">./reqd_mask/service_contexts</span><br><span class="line">./prebuilts/api/27.0/private/service_contexts   # 需要</span><br><span class="line">./prebuilts/api/28.0/private/service_contexts   # 需要</span><br><span class="line">./prebuilts/api/29.0/private/service_contexts       # 需要</span><br><span class="line">./prebuilts/api/26.0/private/service_contexts   # 需要</span><br><span class="line">./private/service_contexts         # 需要</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>service_contexts</code>上添加<code>HelloService                              u:object_r:HelloService:s0</code>;</li><li><code>service.te</code>上添加<code>type HelloService, system_server_service, service_manager_type;</code>。</li></ul><p>6、 编译验证<br>最后再次编译一遍，启动届满没有什么问题了。adb进入系统查看一下有没有这个服务</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ source ./build/envsetup.sh   # 导出环境变量(之前执行过了)</span><br><span class="line">$ lunch product01-eng          # 选择Product</span><br><span class="line">$ make api-stubs-docs-update-current-api -j4            # 更新api接口</span><br><span class="line">$ make -j4            # 编译</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">$ adb shell</span><br><span class="line">pure:/ #<span class="built_in"> service </span>list | grep HelloService                                                                                                                                                               </span><br><span class="line">16      HelloService: [android.pure.IHelloService]</span><br><span class="line">pure:/ #</span><br></pre></td></tr></table></figure><h3 id="错误记录">错误记录</h3><p><strong>1、 添加服务后,<code>make -j4</code>编译系统报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error: Added package android.pure [AddedPackage]</span><br><span class="line">Aborting: Found compatibility problems checking the public API against the API in /home/mi/source/android-10/frameworks/base/api/current.txt</span><br><span class="line">-e </span><br><span class="line">******************************</span><br><span class="line">You have tried to change the API from what has been previously approved.</span><br><span class="line"></span><br><span class="line">To make these errors go away, you have two choices:</span><br><span class="line">   1. You can add &apos;@hide&apos; javadoc comments to the methods, etc. listed in the</span><br><span class="line">      errors above.</span><br><span class="line"></span><br><span class="line">   2. You can update current.txt by executing the following command:</span><br><span class="line">         make api-stubs-docs-update-current-api</span><br><span class="line"></span><br><span class="line">      To submit the revised current.txt to the main Android repository,</span><br><span class="line">      you will need approval.</span><br><span class="line">******************************</span><br><span class="line"></span><br><span class="line">09:05:24 ninja failed with: exit status 1</span><br><span class="line"></span><br><span class="line">#### failed to build some targets (06:37 (mm:ss)) ####</span><br></pre></td></tr></table></figure><p>解决思路: 没有更新服务接口，编译前执行<code>make api-stubs-docs-update-current-api -j4</code></p><p><strong>2、添加selinux后,编译报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELinux: The following public types were found added to the policy without an entry into the compatibility mapping file(s) found in private/compat/V.v/V.v[.ignore].cil, where V.v is the latest API level.</span><br><span class="line">HelloService</span><br><span class="line"></span><br><span class="line">See examples of how to fix this:</span><br><span class="line">https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/781036</span><br><span class="line">https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/852612</span><br><span class="line"></span><br><span class="line">[ 20% 5/24] build out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0</span><br><span class="line">FAILED: out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0</span><br><span class="line">/bin/bash -c &quot;(out/host/linux-x86/bin/treble_sepolicy_tests -l    out/host/linux-x86/lib64/libsepolwrap.so  -f out/target/product/pure/obj/ETC/plat_file_contexts_intermediates/plat_file_contexts  -f out/target/product/pure/obj/ETC/vendor_file_contexts_intermediates/vendor_file_contexts    -b out/target/product/pure/obj/ETC/built_plat_sepolicy_intermediates/built_plat_sepolicy -m out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/28.0_mapping.combined.cil    -o out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/built_28.0_plat_sepolicy -p out/target/product/pure/obj/ETC/sepolicy_intermediates/sepolicy     -u out/target/product/pure/obj/ETC/built_plat_sepolicy_intermediates/base_plat_pub_policy.cil     --fake-treble ) &amp;&amp; (touch out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0 )&quot;</span><br><span class="line">SELinux: The following public types were found added to the policy without an entry into the compatibility mapping file(s) found in private/compat/V.v/V.v[.ignore].cil, where V.v is the latest API level.</span><br><span class="line">HelloService</span><br><span class="line"></span><br><span class="line">See examples of how to fix this:</span><br><span class="line">https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/781036</span><br><span class="line">https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/852612</span><br><span class="line"></span><br><span class="line">21:45:48 ninja failed with: exit status 1</span><br><span class="line"></span><br><span class="line">#### failed to build some targets (16 seconds) ####</span><br></pre></td></tr></table></figure><p>解决思路: selinux没配置好，没有将配置覆盖所有需要的te文件。检查本地配置，按照上面的方法，在配置一下。</p><p><strong>3、启动emulator之后，系统没起来，同时log报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ emulator -wipe-data</span><br><span class="line">emulator: WARNING: Couldn&apos;t find crash service executable /home/hinzer/source/android-10/prebuilts/android-emulator/linux-x86_64/emulator64-crash-service</span><br><span class="line"></span><br><span class="line">emulator: WARNING: system partition size adjusted to match image file (3083 MB &gt; 800 MB)</span><br><span class="line"></span><br><span class="line">qemu_ram_alloc_user_backed: call</span><br><span class="line">context mismatch in svga_surface_destroy   # 这个错误</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>解决方法: 通过网络查询到<a href="https://unix.stackexchange.com/questions/422993/syslogs-getting-spammed-with-context-mismatch-in-svga-sampler-view-destroy" rel="external nofollow noopener noreferrer" target="_blank">解决方法</a>,由于我这边是VM上运行Ubuntu虚拟机，然后在跑emulator。我需要把VM设置中的显示器中的图形渲染关闭，这一操作需要关闭虚拟机，重启后在运行emulator 验证就没有问题了。</p><h3 id="小结">小结</h3><ul><li>查看日志 使用<code>logcat -b all</code>，不清楚不要过滤处理，查看全部log</li><li>不确定的情况下，可以系统上直接启动/禁止<code>selinux</code>验证猜想，然后进一步调试</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="http://qiushao.net/2019/12/20/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/7-%E6%B7%BB%E5%8A%A0java%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-7.添加java层系统服务</a></li><li><a href="https://developer.android.com/guide/components/services" rel="external nofollow noopener noreferrer" target="_blank">官方文档 - 服务概览</a></li><li><a href="https://source.android.com/security/selinux" rel="external nofollow noopener noreferrer" target="_blank">官方文档- SELinux</a></li><li><a href="https://blog.csdn.net/u010753159/article/details/52193061" rel="external nofollow noopener noreferrer" target="_blank">Android 系统服务</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引入概念&quot;&gt;引入概念&lt;/h3&gt;
&lt;p&gt;目前对android系统体系了解比较少，主要区分一下&lt;code&gt;服务&lt;/code&gt;、&lt;code&gt;系统服务&lt;/code&gt;这两个概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.android.
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>04 添加预定义模块</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/04%20%E6%B7%BB%E5%8A%A0%E9%A2%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/04 添加预编译模块/</id>
    <published>2020-04-05T00:05:10.000Z</published>
    <updated>2020-04-05T00:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>在实际的系统开发过程中，有很多文件都是预先编译好的，比如第三方APK，so库, jar包， bin 文件，配置文件等。我们需要在系统编译时能把这些文件打包编译到系统镜像里面。</p><h3 id="操作准则">操作准则</h3><p>我们有两种方法可以达到我们的目的： PRODUCT_COPY_FILES 和 定义 prebuilt 模块。</p><ul><li>如果这个文件只需要预置到指定目录就可以了，那我们就可以简单的将其加入 PRODUCT_COPY_FILES 变量就行， 比如一些 bin 文件， 配置文件。</li><li>如果这个文件有其他模块编译依赖，或者这个文件需要系统签名，那我们就得定义一个预编译模块，比如一些 so 库，APK 文件， jar 包等。</li></ul><h3 id="添加预编译模块">添加预编译模块</h3><p>这里先记录一下添加预编译模块到<code>PRODUCT_COPY_FILES</code>的过程，另外如何定义prebuilt，方法请查看原文<br><a href="http://qiushao.net/2019/12/10/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/5-%E6%B7%BB%E5%8A%A0%E9%A2%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-5.添加预编译模块</a></p><p>1、 定义目录结构<br>为了维护方便，我们一般把 PRODUCT_COPY_FILES 的设置提取到一个单独的文件。在 $<a href="http://product.mk" rel="external nofollow noopener noreferrer" target="_blank">product.mk</a> 里面 include 就行。这里在pure目录下创建一个<code>prebuilt</code>目录如下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android<span class="number">-10</span>$ tree .<span class="regexp">/device/mi</span>/pure/prebuilt/</span><br><span class="line">.<span class="regexp">/device/mi</span>/pure/prebuilt/</span><br><span class="line">├── apk      <span class="comment"># 预置 apk 模块</span></span><br><span class="line">├── libs       <span class="comment"># 预置库模块，so 库， jar 包等</span></span><br><span class="line">└── vendor    <span class="comment"># PRODUCT_COPY_FILES 类型预置，按实际输出路径组织</span></span><br><span class="line">    └── bin</span><br><span class="line">        └── busybox-i686</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> directories, <span class="number">1</span> file</span><br></pre></td></tr></table></figure><p>2、下载bin文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>cd ./device/mi/pure/prebuilt/vendor/bin</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:bin</span><span class="variable">$ </span>wget <span class="symbol">https:</span>/<span class="regexp">/busybox.net/downloads</span><span class="regexp">/binaries/</span><span class="number">1.21</span>.<span class="number">1</span>/busybox-i686</span><br><span class="line">....</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:bin</span><span class="variable">$ </span>file busybox-i686</span><br><span class="line">busybox-<span class="symbol">i686:</span> ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), statically linked, stripped</span><br></pre></td></tr></table></figure><p>3、添加product_copy_files.mk</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:pure</span><span class="variable">$ </span>vim product_copy_files.mk</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:pure</span><span class="variable">$ </span>cat product_copy_files.mk</span><br><span class="line"><span class="comment"># product copy files</span></span><br><span class="line"></span><br><span class="line">LOCAL_PREBUILD_DIR <span class="symbol">:</span>= device/mi/pure/prebuilt</span><br><span class="line"></span><br><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line">    <span class="variable">$(</span>LOCAL_PREBUILD_DIR)/vendor/bin/busybox-<span class="symbol">i686:</span>vendor/bin/busybox</span><br></pre></td></tr></table></figure><p>4、在 $<a href="http://product.mk" rel="external nofollow noopener noreferrer" target="_blank">product.mk</a> 文件中 include</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:pure</span><span class="variable">$ </span>echo <span class="string">"include device/mi/pure/product_copy_files.mk"</span> &gt;&gt; product01.mk</span><br></pre></td></tr></table></figure><h3 id="编译验证">编译验证</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>source ./build/envsetup.sh</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>lunch product01-eng</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>make -j4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动emulator虚拟机</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>emulator</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># adb shell验证</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator<span class="number">-5554</span>device</span><br><span class="line"></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>adb shell busybox          <span class="comment"># 运行可执行文件</span></span><br><span class="line">BusyBox v1.<span class="number">21.1</span> (<span class="number">2013-07</span>-08 <span class="number">10:44</span><span class="symbol">:</span><span class="number">30</span> CDT) multi-call binary.</span><br><span class="line">BusyBox is copyrighted by many authors between <span class="number">1998-2012</span>.</span><br><span class="line">Licensed under GPLv2. See source distribution <span class="keyword">for</span> detailed</span><br><span class="line">copyright notices.</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://developer.android.com/ndk/guides/prebuilts?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">使用预编译库</a></li><li><a href="http://qiushao.net/2019/12/10/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/5-%E6%B7%BB%E5%8A%A0%E9%A2%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-5.添加预编译模块</a></li><li><a href="https://blog.csdn.net/kc58236582/article/details/51451202" rel="external nofollow noopener noreferrer" target="_blank">Android.mk编译目标(编译包、二进制文件、预编译）</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;在实际的系统开发过程中，有很多文件都是预先编译好的，比如第三方APK，so库, jar包， bin 文件，配置文件等。我们需要在系统编译时能把这些文件打包编译到系统镜像里面。&lt;/p&gt;
&lt;h3 id=&quot;操作准则&quot;&gt;操作准则&lt;/h3&gt;
&lt;
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>05 删除android内置apk</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/05%20%E5%88%A0%E9%99%A4Android%E5%8E%9F%E7%94%9F%E5%86%85%E7%BD%AEAPK/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/05 删除Android原生内置APK/</id>
    <published>2020-04-05T00:05:10.000Z</published>
    <updated>2020-04-05T00:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两种方法">两种方法</h3><p>为了在编译阶段将内置apk给异常，下面提供2中方法。</p><ul><li>直接找到添加这个apk的mk文件，从 PRODUCT_PACKAGES 中删除</li><li>通过添加模块，<code>LOCAL_OVERRIDES_PACKAGES</code>定义要覆盖的apk</li></ul><h3 id="目录结构">目录结构</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-<span class="number">10</span>$ tree ./device/mi/pure/</span><br><span class="line">./device/mi/pure/</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Android</span>.</span></span>mk</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">AndroidProducts</span>.</span></span>mk</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">BoardConfig</span>.</span></span>mk</span><br><span class="line">├── product01.mk</span><br></pre></td></tr></table></figure><h3 id="操作过程">操作过程</h3><p><strong>1、 直接从 PRODUCT_PACKAGES 中删除</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step1 找到apk添加到 PRODUCT_PACKAGES 的那个mk文件</span></span><br><span class="line">$ mgrep Contacts</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 从改mk文件中移除配置项</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 清理system目录，重新编译</span></span><br><span class="line">$ rm -rf out/target/product/pure/system</span><br><span class="line"></span><br><span class="line"><span class="comment"># step4 验证</span></span><br><span class="line">make -j4 &amp;&amp; emulator</span><br></pre></td></tr></table></figure><p><strong>2、 通过 LOCAL_OVERRIDES_PACKAGES 删除</strong></p><ol><li>在Product下添加一个模块<code>remove_unused_module</code></li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ vim Android.mk</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := remove_unused_module</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE_CLASS := FAKE     <span class="comment"># 指定编译输出的目录为 $(PRODUCT_OUT)/fake_packages</span></span><br><span class="line">LOCAL_MODULE_SUFFIX := <span class="variable">$(COMMON_ANDROID_PACKAGE_SUFFIX)</span></span><br><span class="line"></span><br><span class="line">LOCAL_OVERRIDES_PACKAGES += \</span><br><span class="line">   Contacts \</span><br><span class="line">   Email  <span class="comment">#这里添加要覆盖的apk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/base_rules.mk</span><br><span class="line"></span><br><span class="line"><span class="variable">$(LOCAL_BUILT_MODULE)</span>:</span><br><span class="line"><span class="variable">$(hide)</span> echo <span class="string">"Fake: <span class="variable">$@</span>"</span></span><br><span class="line"><span class="variable">$(hide)</span> mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(hide)</span> touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">PACKAGES.<span class="variable">$(LOCAL_MODULE)</span>.OVERRIDES := <span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(LOCAL_OVERRIDES_PACKAGES)</span>)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将<code>remove_unused_module</code>添加到对应product文件的PRODUCT_PACKAGES配置</li></ol><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PRODUCT_PACKAGES +</span>=<span class="string"> remove_unused_module</span></span><br></pre></td></tr></table></figure><ol start="3"><li>清理<code>out/target/product/pure/system</code>目录，验证</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf out/target/product/pure/system</span><br><span class="line">$ make -j4 &amp;&amp; emulator</span><br></pre></td></tr></table></figure><h3 id="原理补充-PRODUCT-PACKAGES">原理补充(PRODUCT_PACKAGES)</h3><p>对于第一种方法，通过<code>mgrep</code>命令能够搜索到这个mk文件定义了PRODUCT_PACKAGES，直接移除就ok。对于第二种方法，在 <a href="http://main.mk" rel="external nofollow noopener noreferrer" target="_blank">main.mk</a> 里面有对 <code>OVERRIDES_PACKAGES</code> 进行处理（在<a href="https://cs.android.com/android/platform/superproject/+/master:build/make/core/main.mk?q=_pif_overrides&amp;ss=android%2Fplatform%2Fsuperproject#1064" rel="external nofollow noopener noreferrer" target="_blank">android-10源码</a>中对这个关键词进行检索）</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># Lists most of the files a particular product installs, including:</span><br><span class="line"># - PRODUCT_PACKAGES, and their LOCAL_REQUIRED_MODULES</span><br><span class="line"># - PRODUCT_COPY_FILES</span><br><span class="line"># The base list of modules to build <span class="keyword">for</span> this product is specified</span><br><span class="line"># by the appropriate product definition <span class="keyword">file</span>, which was included</span><br><span class="line"># by product_config.mk.</span><br><span class="line"># Name resolution <span class="keyword">for</span> PRODUCT_PACKAGES:</span><br><span class="line">#   foo:<span class="number">32</span> resolves to foo_32;</span><br><span class="line">#   foo:<span class="number">64</span> resolves to foo;</span><br><span class="line">#   foo resolves to both foo and foo_32 (<span class="keyword">if</span> foo_32 is defined).</span><br><span class="line">#</span><br><span class="line"># Name resolution <span class="keyword">for</span> LOCAL_REQUIRED_MODULES:</span><br><span class="line">#   If a module is built <span class="keyword">for</span> <span class="number">2</span>nd arch, its required module resolves to</span><br><span class="line">#   <span class="number">32</span>-bit variant, <span class="keyword">if</span> it exits. See the <span class="keyword">select</span>-bitness-of-required-modules definition.</span><br><span class="line"># $(<span class="number">1</span>): product makefile</span><br><span class="line">define product-installed-files</span><br><span class="line">  $(<span class="keyword">eval</span> _mk := $(<span class="keyword">strip</span> $(<span class="number">1</span>))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules := \</span><br><span class="line">    $(PRODUCTS.$(_mk).PRODUCT_PACKAGES) \</span><br><span class="line">    $(<span class="keyword">if</span> $(<span class="keyword">filter</span> eng,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_ENG)) \</span><br><span class="line">    $(<span class="keyword">if</span> $(<span class="keyword">filter</span> debug,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_DEBUG)) \</span><br><span class="line">    $(<span class="keyword">if</span> $(<span class="keyword">filter</span> tests,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_TESTS)) \</span><br><span class="line">    $(<span class="keyword">if</span> $(<span class="keyword">filter</span> asan,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_DEBUG_ASAN)) \</span><br><span class="line">    $(call auto-included-modules) \</span><br><span class="line">  ) \</span><br><span class="line">  $(<span class="keyword">eval</span> ### Filter out the overridden packages and executables before doing expansion) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_overrides := $(call module-overrides,$(_pif_modules))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules := $(<span class="keyword">filter</span>-out $(_pif_overrides), $(_pif_modules))) \</span><br><span class="line">  $(<span class="keyword">eval</span> ### Resolve the :<span class="number">32</span> :<span class="number">64</span> module name) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules_32 := $(patsubst %:<span class="number">32</span>,%,$(<span class="keyword">filter</span> %:<span class="number">32</span>, $(_pif_modules)))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules_64 := $(patsubst %:<span class="number">64</span>,%,$(<span class="keyword">filter</span> %:<span class="number">64</span>, $(_pif_modules)))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules_rest := $(<span class="keyword">filter</span>-out %:<span class="number">32</span> %:<span class="number">64</span>,$(_pif_modules))) \</span><br><span class="line">  $(<span class="keyword">eval</span> ### Note <span class="keyword">for</span> <span class="number">32</span>-bit product, <span class="number">32</span> and <span class="number">64</span> will be added as their original module names.) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules := $(call get<span class="number">-32</span>-bit-modules-<span class="keyword">if</span>-we-can, $(_pif_modules_32))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules += $(_pif_modules_64)) \</span><br><span class="line">  $(<span class="keyword">eval</span> ### For the rest we add both) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules += $(call get<span class="number">-32</span>-bit-modules, $(_pif_modules_rest))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules += $(_pif_modules_rest)) \</span><br><span class="line">  $(call expand-required-modules,_pif_modules,$(_pif_modules),$(_pif_overrides)) \</span><br><span class="line">  $(<span class="keyword">filter</span>-out $(HOST_OUT_ROOT)/%,$(call module-installed-files, $(_pif_modules))) \</span><br><span class="line">  $(call resolve-product-relative-paths,\</span><br><span class="line">    $(foreach cf,$(PRODUCTS.$(_mk).PRODUCT_COPY_FILES),$(call word-colon,<span class="number">2</span>,$(cf))))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure><p>有定义<br><code>$(eval _pif_modules := $(filter-out $(_pif_overrides), $(_pif_modules)))</code><br><a href="https://seisman.github.io/how-to-write-makefile/functions.html#filter-out" rel="external nofollow noopener noreferrer" target="_blank">filter-out</a>是Makefile语法支持的函数，从<code>$(_pif_modules)</code>中 反选过滤出<code>$(_pif_overrides)</code>之外的所有modules。</p><blockquote><p>涉及到android build系统，我现在也还没搞清楚逻辑链，有待补充。</p></blockquote><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="http://qiushao.net/2019/12/12/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/6-%E5%88%A0%E9%99%A4%E5%8E%9F%E7%94%9F%E5%86%85%E7%BD%AEAPK/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-6.删除Android原生内置APK</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;两种方法&quot;&gt;两种方法&lt;/h3&gt;
&lt;p&gt;为了在编译阶段将内置apk给异常，下面提供2中方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接找到添加这个apk的mk文件，从 PRODUCT_PACKAGES 中删除&lt;/li&gt;
&lt;li&gt;通过添加模块，&lt;code&gt;LOCAL_OVERR
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>03 添加自定义模块</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/03%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/03 添加自定义模块/</id>
    <published>2020-04-05T00:04:10.000Z</published>
    <updated>2020-04-05T00:24:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景介绍">背景介绍</h3><p>早期的Android系统都是采用Android.mk的配置来编译源码，从Android 7.0开始引入Android.bp。<a href="http://xn--Android-y42nw38bzna.xn--bpAndroid-hp6ne0ab71ako7aqbvzqa225adod146f8hl.mk" rel="external nofollow noopener noreferrer" target="_blank">很明显Android.bp的出现就是为了替换掉Android.mk</a>。</p><ul><li>Android 7.0引入ninja和kati</li><li>Android <a href="http://8.xn--0Android-iu2m5322a.xn--bpAndroid-ww0s413a78a.mk" rel="external nofollow noopener noreferrer" target="_blank">8.0使用Android.bp来替换Android.mk</a>，引入Soong</li><li>Android 9.0强制使用Android.bp</li></ul><h3 id="添加模块">添加模块</h3><p>然后开始介绍如何通过Android.bp来引入一个<code>hello world</code>模块。<br>1、目录结构</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./device/mi/pure/hello/</span><br><span class="line">├── Android.bp</span><br><span class="line">└── hello.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>2.<code>hello.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"qiushao"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG ,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG ,__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello qiushao\n"</span>);</span><br><span class="line">    LOGD(<span class="string">"hello qiushao"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>Android.bp</code>文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_binary &#123;              <span class="comment">//模块类型为可执行文件</span></span><br><span class="line">    name: <span class="string">"hello"</span>,       <span class="comment">//模块名hello</span></span><br><span class="line">    srcs: [<span class="string">"hello.cpp"</span>], <span class="comment">//源文件列表</span></span><br><span class="line">    vendor: <span class="literal">true</span>,        <span class="comment">//编译出来放在/vendor目录下(默认是放在/system目录下)</span></span><br><span class="line">    shared_libs: [       <span class="comment">//编译依赖的动态库</span></span><br><span class="line">        <span class="string">"liblog"</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、编译hello模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:hello$ mma</span><br></pre></td></tr></table></figure><p>5、添加product配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:pure$ <span class="built_in">pwd</span></span><br><span class="line">/home/hinzer/<span class="built_in">source</span>/android-10/device/mi/pure</span><br><span class="line">hinzer@ubuntu:pure$ <span class="built_in">echo</span> <span class="string">"PRODUCT_PACKAGES += hello"</span> &gt;&gt; product01.mk</span><br></pre></td></tr></table></figure><p>6、整编android系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ <span class="built_in">source</span> ./build/envsetup.sh</span><br><span class="line">hinzer@ubuntu:android-10$ lunch product01-eng</span><br><span class="line">hinzer@ubuntu:android-10$ make -j4</span><br></pre></td></tr></table></figure><p>这是其中一个常见的模块实例，需要定义其他类型的模块时，可以参考以下<a href="http://119.29.209.28/Android/soong/soong_build.html" rel="external nofollow noopener noreferrer" target="_blank">文档soong</a>。或者参考系统已有的 Android.bp 模块。</p><h3 id="验证">验证</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>emulator</span><br><span class="line">...</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator<span class="number">-5554</span>device</span><br><span class="line"></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>adb shell hello          <span class="comment"># 运行可执行文件hello                                                                                                              </span></span><br><span class="line">hello qiushao</span><br></pre></td></tr></table></figure><h3 id="理论补充">理论补充</h3><p>1、模块编译输出分区</p><ul><li>system :主要包含 Android 框架， google 官方实现<ul><li><a href="http://Android.mk" rel="external nofollow noopener noreferrer" target="_blank">Android.mk</a> 默认就是输出到 system 分区，不用指定</li><li>Android.bp 默认就是输出到 system 分区，不用指定</li></ul></li><li>vendor :SoC芯片商分区(系统级核心厂商，如高通), 为他们提供一些核心功能和服务，由 soc 实现<ul><li><a href="http://Android.mk" rel="external nofollow noopener noreferrer" target="_blank">Android.mk</a> LOCAL_VENDOR_MODULE := true</li><li>Android.bp vendor: true</li></ul></li><li>odm :设备制造商分区（如华为、小米），为他们的传感器或外围设备提供一些核心功能和服务<ul><li><a href="http://Android.mk" rel="external nofollow noopener noreferrer" target="_blank">Android.mk</a> LOCAL_ODM_MODULE := true</li><li>Android.bp device_specific: true</li></ul></li><li>product :产品机型分区<ul><li><a href="http://Android.mk" rel="external nofollow noopener noreferrer" target="_blank">Android.mk</a> LOCAL_PRODUCT_MODULE := true</li><li>Android.bp product_specific</li></ul></li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/build" rel="external nofollow noopener noreferrer" target="_blank">Soong 编译系统</a></li><li><a href="http://qiushao.net/2019/11/22/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/4-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-4.添加自定义模块</a></li><li><a href="http://gityuan.com/2018/06/02/android-bp/" rel="external nofollow noopener noreferrer" target="_blank">理解Android.bp</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h3&gt;
&lt;p&gt;早期的Android系统都是采用Android.mk的配置来编译源码，从Android 7.0开始引入Android.bp。&lt;a href=&quot;http://xn--Android-y42nw38bzna.xn--bpAndro
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>01 添加Product</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/01%20%E6%B7%BB%E5%8A%A0Product/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/01 添加Product/</id>
    <published>2020-04-05T00:03:10.000Z</published>
    <updated>2020-04-05T00:23:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解概念">理解概念</h3><p>1、Product<br>在android源码正式编译之前选择Product，使用<code>lunch product-xxx</code>，这一步操作理解为预先对要编译的源码进行一系列的配置。在android-10的源码中，将一个Product配置分成三个部分:</p><ul><li><a href="http://BoardConfig.mk" rel="external nofollow noopener noreferrer" target="_blank">BoardConfig.mk</a>: 芯片硬件相关配置，分区设置等</li><li><a href="http://product.mk" rel="external nofollow noopener noreferrer" target="_blank">product.mk</a>: 一个产品的软件相关的配置，比如内置哪些软件模块，<a href="http://xn--AndroidProducts-ig40b.mk" rel="external nofollow noopener noreferrer" target="_blank">由AndroidProducts.mk</a> 中的PRODUCT_MAKEFILES指定</li><li><a href="http://AndroidProducts.mk" rel="external nofollow noopener noreferrer" target="_blank">AndroidProducts.mk</a>: 指定 product 配置,并把 product 添加到 lunch 选择项中</li></ul><p>2、组织结构<br>Google为AOSP源码内置了Product配置，位于源码的<code>build/target</code>目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:target$ pwd</span><br><span class="line">/home/hinzer/source/android-10/build/target</span><br><span class="line">hinzer@ubuntu:target$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── board</span><br><span class="line">├── OWNERS</span><br><span class="line">└── product</span><br><span class="line"></span><br><span class="line">2 directories, 1 file</span><br></pre></td></tr></table></figure><p>同时也允许第三方定制Product配置，在源码<code>device</code>目录下。待会自定义Product在这个目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:device$ tree mi </span><br><span class="line">mi # 公司名</span><br><span class="line">└── pure # device名(写为Product,与product区分),一个device可对应多个product</span><br><span class="line">    ├── AndroidProducts.mk  # 指定product配置，添加lunch选项</span><br><span class="line">    ├── BoardConfig.mk # 硬件配置 boardconfig</span><br><span class="line">    └── product01.mk # 软件配置 product</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><h3 id="自定义product">自定义product</h3><p>模仿aosp源码的Product配置,就引用了<code>build/target/board/generic_x86_64/BoardConfig.mk</code>和<code>build/target/board/generic_x86_64/BoardConfig.mk</code>的配置。然后进行自定义</p><p>1、创建<code>device/[company]/[device]</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ mkdir -p ./device/mi/pure</span><br></pre></td></tr></table></figure><p>2、分别添加<code>AndroidProducts.mk</code>、<code>product.mk</code>、<code>BoardConfig.mk</code>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:pure$ ls</span><br><span class="line">AndroidProducts.mk  BoardConfig.mk  product01.mk</span><br><span class="line"></span><br><span class="line"># 1.添加 AndroidProducts.mk</span><br><span class="line">hinzer@ubuntu:pure$ cat AndroidProducts.mk </span><br><span class="line">PRODUCT_MAKEFILES := \</span><br><span class="line">    $(LOCAL_DIR)/product01.mk   # 指定 product</span><br><span class="line"></span><br><span class="line">COMMON_LUNCH_CHOICES := \</span><br><span class="line">    product01-eng # 添加lunch选项</span><br><span class="line"></span><br><span class="line"># 2.添加 BoardConfig.mk </span><br><span class="line">hinzer@ubuntu:pure$ cat BoardConfig.mk </span><br><span class="line">include $(SRC_TARGET_DIR)/board/generic_x86_64/BoardConfig.mk  # 这里直接饮用</span><br><span class="line"></span><br><span class="line"># 3.添加 product01.mk </span><br><span class="line">hinzer@ubuntu:pure$ cat product01.mk </span><br><span class="line">$(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_x86_64.mk)</span><br><span class="line"></span><br><span class="line">PRODUCT_NAME   := product01 # product名(与文件保持一致)</span><br><span class="line">PRODUCT_DEVICE := pure      # device名，BoardConfig.mk相关</span><br></pre></td></tr></table></figure><p>3、lunch刚才创建的product，编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ <span class="built_in">source</span> ./build/envsetup.sh</span><br><span class="line">hinzer@ubuntu:android-10$ lunch product01-eng</span><br><span class="line">hinzer@ubuntu:android-10$ make -j4</span><br></pre></td></tr></table></figure><p>4、验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行虚拟机</span></span><br><span class="line">hinzer@ubuntu:android-10$ emulator   <span class="comment"># 查看Android version信息，编译时间、产品名是否对应</span></span><br></pre></td></tr></table></figure><h3 id="理论补充">理论补充</h3><p>1、<code>build variants</code><br>aosp为build系统提供三种Product配置，文档里叫做<a href="https://source.android.com/setup/develop/new-device#build-variants" rel="external nofollow noopener noreferrer" target="_blank"><code>build variants</code></a>,分别是:</p><ul><li>eng : 对应到工程版。编译打包所有模块。表示adbd处于ROOT状态，所有调试开关打开</li><li>userdebug : 对应到用户调试版。打开调试开关，但并没有放开ROOT权限</li><li>user : 对应到用户版。关闭调试开关，关闭ROOT权限。最终发布到用户手上的版本，通常都是user版。</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/develop/new-device" rel="external nofollow noopener noreferrer" target="_blank">AOSP开发文档 - 添加新设备</a></li><li><a href="http://qiushao.net/2019/11/19/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/2-%E6%B7%BB%E5%8A%A0product/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-2.添加product</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解概念&quot;&gt;理解概念&lt;/h3&gt;
&lt;p&gt;1、Product&lt;br&gt;
在android源码正式编译之前选择Product，使用&lt;code&gt;lunch product-xxx&lt;/code&gt;，这一步操作理解为预先对要编译的源码进行一系列的配置。在android-10的源码
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>02 添加系统属性</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/02%20%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/02 添加系统属性/</id>
    <published>2020-04-05T00:03:10.000Z</published>
    <updated>2020-04-05T00:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解概念">理解概念</h3><p>1、基本描述<br>系统属性可以简单的理解为系统层级的全局变量，以<code>key-value</code>的形式保存， <code>key-value</code> 都是字符串。这些属性可能是有些资源的使用状态，进程的执行状态，系统的特有属性等。</p><p>2、命名规则<br>几种特殊前缀的属性</p><ul><li>ro ：只读属性，不能修改。</li><li>persist ：修改属性后，重启依然有效。数据会保存到 /data/property 目录。其他前缀的属性被设置后，只是保存在内在中而已，并没有保存到磁盘，所以重启后就恢复默认值了。</li><li>ctrl ：用来启动和停止服务。每一项服务必须在 init.rc 中定义。init 一旦收到设置 ctrl.start 属性的请求，属性服务将使用该属性值作为服务名找到该服务，启动该服务。这项服务的启动结果将会放入 init.svc.&lt;服务名&gt; 属性中。</li></ul><p>3、读写方法<br>在 Android 系统中有一个 Property Service 服务， 这个服务对外提供了两个接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SystemProperties.get(String key, String def) <span class="comment"># 读取系统属性</span></span><br><span class="line">SystemProperties.set(String key, String val) <span class="comment"># 设置系统属性</span></span><br></pre></td></tr></table></figure><p>有两个命令行对这两个接口进行了封装，我们可以直接在adb shell 中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getprop key <span class="comment"># 读取系统属性</span></span><br><span class="line">setprop key val <span class="comment"># 设置系统属性</span></span><br></pre></td></tr></table></figure><p>4、组织结构<br>系统启动的时候会从几个配置文件中加载属性的默认值，大概有以下几个文件， 在不同<code>Android版本系统</code>上可能不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/default.prop 或者是 /prop.default，</span><br><span class="line">/vendor/default.prop</span><br><span class="line">/system/build.prop</span><br><span class="line">/vendor/build.prop</span><br><span class="line">/data/local.prop</span><br><span class="line">/data/property/*</span><br></pre></td></tr></table></figure><p>系统会按先后顺序依次加载以上文件，后加载的属性将覆盖原先的值。<br>default.prop 的值是通过 build/tools 目录下的 <a href="http://buildinfo.sh" rel="external nofollow noopener noreferrer" target="_blank">buildinfo.sh</a> 和 vendor_buildinfo.sh 生成的。</p><h3 id="源码中添加系统属性定义">源码中添加系统属性定义</h3><p>在我们之前配置的product中添加自定义属性,在源码根目录<code>device/mi/pure</code>下,对应Build规则在<code>build/make/core/Makefile</code>,编译后输出到<code>out/target/product/pure</code>下，最终随系统启动加载对应的文件。<br>下面记录了添加属性过程<br>1、添加到<code>/system/build.prop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:pure$ pwd</span><br><span class="line">/home/hinzer/source/android-10/device/mi/pure</span><br><span class="line">hinzer@ubuntu:pure$ cat system.prop</span><br><span class="line">ro.pure.version=1.0 # 定义属性</span><br><span class="line">hinzer@ubuntu:pure$ cat BoardConfig.mk</span><br><span class="line">include $(SRC_TARGET_DIR)/board/generic_x86_64/BoardConfig.mk</span><br><span class="line"></span><br><span class="line">TARGET_SYSTEM_PROP += device/mi/pure/system.prop   # 添加到 TARGET_SYSTEM_PROP 变量</span><br></pre></td></tr></table></figure><p>2、添加到<code>/vendor/build.prop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:pure$ pwd</span><br><span class="line">/home/hinzer/source/android-10/device/mi/pure</span><br><span class="line">hinzer@ubuntu:pure$ cat product01.mk</span><br><span class="line">$(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_x86_64.mk)</span><br><span class="line"></span><br><span class="line">PRODUCT_NAME   := product01 # product名(与文件保持一致)</span><br><span class="line">PRODUCT_DEVICE := pure      # device名，BoardConfig.mk相关</span><br><span class="line"></span><br><span class="line"># 配置属性</span><br><span class="line">PRODUCT_PROPERTY_OVERRIDES += \</span><br><span class="line">    ro.vendor.pure.name=qiushao \</span><br><span class="line">    persist.vendor.pure.name=qiushao \</span><br><span class="line">    vendor.pure.name=qiushao</span><br></pre></td></tr></table></figure><h3 id="编译">编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ <span class="built_in">source</span> ./build/envsetup.sh</span><br><span class="line">hinzer@ubuntu:android-10$ lunch product01-eng</span><br><span class="line">hinzer@ubuntu:android-10$ make -j4</span><br></pre></td></tr></table></figure><h3 id="验证">验证</h3><p>1、查看<code>out/target</code>目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 验证 `/system/build.prop`</span><br><span class="line">hinzer@ubuntu:android-10$ cat out/target/product/pure/system/build.prop  | grep ro.pure</span><br><span class="line">ro.pure.version=1.0</span><br><span class="line"></span><br><span class="line"># 验证 `/vendor/build.prop`</span><br><span class="line">hinzer@ubuntu:android-10$ cat out/target/product/pure/vendor/build.prop | grep pure.name</span><br><span class="line">ro.vendor.pure.name=qiushao</span><br><span class="line">persist.vendor.pure.name=qiushao</span><br><span class="line">vendor.pure.name=qiushao</span><br></pre></td></tr></table></figure><p>2、启动虚拟机系统查看属性</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>emulator</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator<span class="number">-5554</span>device</span><br><span class="line"></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb reboot  <span class="comment"># 重启一下，重置系统属性</span></span><br><span class="line"></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop ro.pure.version</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop ro.vendor.pure.name</span><br><span class="line">qiushao</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop persist.vendor.pure.name </span><br><span class="line">qiushao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只读属性不可改</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop ro.vendor.pure.name</span><br><span class="line">qiushao</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell setprop ro.vendor.pure.name hinzer</span><br><span class="line"><span class="symbol">setprop:</span> failed to set property <span class="string">'ro.vendor.pure.name'</span> to <span class="string">'hinzer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改属性，重启后恢复原属性值</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell setprop persist.vendor.pure.name hinzer</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop persist.vendor.pure.name </span><br><span class="line">hinzer</span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="http://qiushao.net/2019/11/20/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/3-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-3.添加系统属性</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解概念&quot;&gt;理解概念&lt;/h3&gt;
&lt;p&gt;1、基本描述&lt;br&gt;
系统属性可以简单的理解为系统层级的全局变量，以&lt;code&gt;key-value&lt;/code&gt;的形式保存， &lt;code&gt;key-value&lt;/code&gt; 都是字符串。这些属性可能是有些资源的使用状态，进程的执
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>00 配置开发环境</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/00%20%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/00 配置开发环境/</id>
    <published>2020-03-29T01:03:10.000Z</published>
    <updated>2020-03-29T13:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ubuntu系统环境">ubuntu系统环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:~$ uname -a</span><br><span class="line">Linux ubuntu 5.3.0-42-generic <span class="comment">#34~18.04.1-Ubuntu SMP Fri Feb 28 13:42:26 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><h3 id="配置android开发环境">配置android开发环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译所需的工具和相关库</span></span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line">sudo apt-get install -y git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libssl-dev libssl-dev openssl autoconf m4 libxml2-utils bc  libxml-simple-perl</span><br><span class="line"></span><br><span class="line"><span class="comment"># git和repo工具管理android源码</span></span><br><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:<span class="variable">$PATH</span></span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:~/bin'</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置git账信息</span></span><br><span class="line">git config --global user.name <span class="string">"xxx"</span></span><br><span class="line">git config --global user.email <span class="string">"xxxx@aaa.bb"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷写和调试工具</span></span><br><span class="line">sudo apt-get install adb -y</span><br><span class="line">sudo apt-get install fastboot -y</span><br><span class="line">sudo apt-get install android-tools-adb</span><br><span class="line">sudo apt-get install android-tools-fastboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置规则，解决无usb权限问题</span></span><br><span class="line">sudo touch /etc/udev/rules.d/70-android.rules</span><br><span class="line">sudo vim /etc/udev/rules.d/70-android.rules <span class="comment">#添加：SUBSYSTEM=="usb", MODE="0666" </span></span><br><span class="line">sudo chmod a+rx /etc/udev/rules.d/70-android.rules</span><br><span class="line">sudo service udev restart</span><br></pre></td></tr></table></figure><h3 id="下载android源码"><a href="https://source.android.com/setup/build/downloading" rel="external nofollow noopener noreferrer" target="_blank">下载android源码</a></h3><p>由于国内访问google镜像受限，推荐使用<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" rel="external nofollow noopener noreferrer" target="_blank">清华大学开源镜像站</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/<span class="built_in">source</span>/android-10</span><br><span class="line"><span class="built_in">cd</span> ~/<span class="built_in">source</span>/android-10</span><br><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r8   <span class="comment"># 拉取repo长裤，-u指定远程repo仓库url，-b指定获取特定分支branch</span></span><br><span class="line">repo sync <span class="comment"># 同步代码</span></span><br></pre></td></tr></table></figure><p>要要查看分支列表，请参<a href="https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds" rel="external nofollow noopener noreferrer" target="_blank">阅源代码标记和细分版本</a></p><h3 id="编译调试"><a href="https://source.android.com/setup/build/building#run-it" rel="external nofollow noopener noreferrer" target="_blank">编译调试</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整编源码</span></span><br><span class="line"><span class="built_in">source</span> ./build/envsetup.sh <span class="comment"># 导出所需环境变量</span></span><br><span class="line">lunch &lt;product_name&gt; <span class="comment"># 选择要编译的product</span></span><br><span class="line">make -j4 <span class="comment"># 开始编译，-j4表示使用4个线程编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行虚拟机</span></span><br><span class="line">emulator   <span class="comment"># 查看系统信息确认是我们刚刚编译的系统</span></span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/build/downloading#getting-the-files" rel="external nofollow noopener noreferrer" target="_blank">android源码公开文档 - 下载源代码</a></li><li><a href="https://source.android.com/setup/build/building" rel="external nofollow noopener noreferrer" target="_blank">android源码公开文档 - 编译系统</a></li><li><a href="http://qiushao.net/2019/11/15/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/0-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-0.开发环境准备</a></li><li><a href="http://qiushao.net/2019/11/16/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/1-Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-1.Android系统源码下载编译</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ubuntu系统环境&quot;&gt;ubuntu系统环境&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>03 系统调用</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/03%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/03 系统调用/</id>
    <published>2020-03-28T09:31:02.000Z</published>
    <updated>2020-03-29T03:23:49.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关概念">相关概念</h3><p>1、程序vs进程vs命令<br>Linux系统上所有的操作由<code>进程</code>完成，<code>进程</code>的运行是动态的，在此之前是一个静态的<code>程序</code>。用户用一个程序来启动一个进程，这个程序可以是别人写好的(最终被编译成可执行文件)，比如<code>ls</code>、<code>pwd</code>、<code>cat</code>，也可以是我们自己写的。</p><p>2、系统调用<br>无论如何，程序最后运行起来都是进程，并且一个程序想要在系统上跑，要用到<code>系统调用</code>,这是系统给用户提供的API接口。</p><p>3、strace命令<br>Linux有个命令strace，常用来跟踪进程执行时系统调用和所接收的信号。通过<code>manstrace</code>查看具体描述。</p><p>4、Glibc<br>作为一个开发者，也许平时并没有直接使用系统调用，而是Glibc库。Glibc是Linux下使用的开源的标准C库它是GNU发布的libc库。<code>Glibc</code>即系统调用的封装。</p><h3 id="介绍系统调用">介绍系统调用</h3><p>然后本文开始介绍这些系统调用，先上图<br><img src="https://static001.geekbang.org/resource/image/ff/f0/ffb6847b94cb0fd086095ac263ac4ff0.jpg" alt="系统调用"></p><p>1、进程管理<br>linux操作系统使用叫<code>fork</code>的系统调用来创建进程，进程运行过程:</p><blockquote><p>当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。按理说，如果不进行特殊的处理，父进程和子进程都按相同的程序代码进行下去，这样就没有意义了。<br>所以，我们往往会这样处理：对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过if-else语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用execve来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支（fork）了。</p></blockquote><p>其他进程都是父进程fork出来的，对于操作系统而言，系统启动的时候先创建一个所有用户进程的“祖宗进程”。</p><p>2、内存管理<br>在操作系统中，每个进程都有自己的<code>进程内存空间</code>。其中布局就有<code>代码段</code>、<code>数据段</code>、<code>堆</code>。<br>一个进程的内存空间是很大的，32位的是4G，64位的就更大了。物理空间是有限的，所以进程的空间不能事先分配好的，一定是需要的时候再分配。<br><code>brk</code>和<code>mmap</code>是官员堆分配内存的系统调用，分配内存数量比较小的时候，使用<code>brk</code>会和原来的堆的数据连在一起。当分配的内存数量比较大的时候，使用mmap，会重新划分一块区域。</p><p>3、文件管理<br>文件系统相当于公司的资料库，用于保存一些永久性质的数据。能做到长期保存，文件之所以能做到这一点，一方面是因为<code>介质</code>，另一方面是因为<code>格式</code>。<br>对于文件的操作，无非是<code>创建</code>、<code>打开</code>、<code>读</code>、<code>写</code>等等,对应的系统调用常有:</p><blockquote><p>对于已经有的文件，可以使用open打开这个文件，close关闭这个文件；<br>对于没有的文件，可以使用creat创建文件；<br>打开文件以后，可以使用lseek跳到文件的某个位置；<br>可以对文件的内容进行读写，读的系统调用是read，写是write。</p></blockquote><p><a href="https://static001.geekbang.org/resource/image/e4/df/e49b5c2a78ac09903d697126bfe6c5df.jpeg" rel="external nofollow noopener noreferrer" target="_blank">Linux中一切皆文件</a>,就包括<code>二进制文件</code>、<code>文本文件</code>、<code>stdout文件</code>、<code>Socket文件</code>、<code>设备文件</code>、<code>目录文件</code>，包括进程运行起来在<code>/proc</code>下生成的进程号也是文件。<br>对于每一个文件，Linux分配了<code>文件描述符</code>，这是一个整数。</p><p>4、信号处理<br>信号是异步处理机制，用于紧急突发情况。常见信号有</p><blockquote><p>在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；<br>如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西；<br>硬件故障，设备出了问题，当然要通知项目组；<br>用户进程通过kill函数，将一个用户信号发送给另一个进程。<br>每一种信号都有默认动作，当然用户也能编写信号处理函数，通过<code>sigaction</code>系统调用进行处理。</p></blockquote><p>5、进程间通信<br>本地进程之间实现数据的互通，比较常见的处理机制有<code>消息队列</code>和<code>共享内存</code>。</p><ul><li>通过<code>msgget</code>创建一个新的队列，<code>msgsnd</code>将消息发送到消息队列，而消息接收方可以使用<code>msgrcv</code>从队列中取消息</li><li>我们可以通过<code>shmget</code>创建一个共享内存块，通过<code>shmat</code>将共享内存映射到自己的内存空间，然后就可以读写了。</li></ul><p>6、网络通信<br>内核中有TCP/IP网络协议栈的实现，可以通过socket来实现跨系统的进程间通信。</p><h3 id="查看源码中的系统调用">查看源码中的系统调用</h3><p><a href="https://www.kernel.org/" rel="external nofollow noopener noreferrer" target="_blank">下载内核源码</a>，找到<code>./include/asm-x86_64/unistd.h</code>文件，里面对于系统调用的定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:linux-2.6.11$ head ./include/asm-x86_64/unistd.h</span><br><span class="line"><span class="comment">#ifndef _ASM_X86_64_UNISTD_H_</span></span><br><span class="line"><span class="comment">#define _ASM_X86_64_UNISTD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef __SYSCALL</span></span><br><span class="line"><span class="comment">#define __SYSCALL(a,b) </span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This file contains the system call numbers.</span><br><span class="line"> *</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://time.geekbang.org/column/article/89251" rel="external nofollow noopener noreferrer" target="_blank">趣谈Linux操作系统 - 刘超</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相关概念&quot;&gt;相关概念&lt;/h3&gt;
&lt;p&gt;1、程序vs进程vs命令&lt;br&gt;
Linux系统上所有的操作由&lt;code&gt;进程&lt;/code&gt;完成，&lt;code&gt;进程&lt;/code&gt;的运行是动态的，在此之前是一个静态的&lt;code&gt;程序&lt;/code&gt;。用户用一个程序来启动一个进程，
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>bugreport</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/logcat/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/logcat/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-29T03:38:51.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>logcat是抓log的工具，从android logging系统抓取日志。</p><p>1、logcat相关目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码位置：`/system/core/logcat/`</span><br><span class="line">编译生成的可执行文件位于：`out/target/product/umi/system/bin/logcat`(umi是产品名)</span><br><span class="line">对应到设备端的可执行文件：`/system/bin/logcat`</span><br></pre></td></tr></table></figure><p>2、日志缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">radio：查看包含无线装置/电话相关消息的缓冲区。</span><br><span class="line">events：查看已经过解译的二进制系统事件缓冲区消息。</span><br><span class="line">main：查看主日志缓冲区（默认），不包含系统和崩溃日志消息。</span><br><span class="line">system：查看系统日志缓冲区（默认）。</span><br><span class="line">crash：查看崩溃日志缓冲区（默认）。</span><br><span class="line">all：查看所有缓冲区。</span><br><span class="line">default：报告 main、system 和 crash 缓冲区。</span><br></pre></td></tr></table></figure><h3 id="使用规范">使用规范</h3><p>1、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#filteringOutput" rel="external nofollow noopener noreferrer" target="_blank">过滤日志输出</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag:priority  标记:优先级</span></span><br><span class="line">$ adb shell logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure><p>2、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#outputFormat" rel="external nofollow noopener noreferrer" target="_blank">控制日志输出格式</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v &lt;format&gt;</span></span><br><span class="line">$ adb shell logcat -v thread</span><br></pre></td></tr></table></figure><p>3、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#alternativeBuffers" rel="external nofollow noopener noreferrer" target="_blank">查看备用日志缓冲区</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -b &lt;buffer&gt;</span></span><br><span class="line">$ adb shell logcat -b radio</span><br></pre></td></tr></table></figure><h3 id="命令速查">命令速查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取help</span></span><br><span class="line">$ adb shell logcat --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查log</span></span><br><span class="line">$ adb shell logcat -b system &gt; logSystem.txt  <span class="comment">#查询此时system的日志，并且保存在logSystem.txt的文件中</span></span><br><span class="line">^C</span><br></pre></td></tr></table></figure><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">Logcat 命令行工具</a></li><li><a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=181967386" rel="external nofollow noopener noreferrer" target="_blank">Android Log机制、Logcat及MIUI 284日志介绍</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;logcat是抓log的工具，从android logging系统抓取日志。&lt;/p&gt;
&lt;p&gt;1、logcat相关目录&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Log" scheme="https://hinzer.github.io/wiki/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>理解测试用例</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/如何编写一个好的测试用例/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-29T03:38:59.625Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试用例设计过程">测试用例设计过程</h3><p>以“用户登录”功能的测试用例设计为例，画了一张图来帮你理清这些概念之间的映射关系。图中的业务需求到软件功能需求、软件功能需求到测试需求，以及测试需求到测试用例的映射关系，<br><img src="https://static001.geekbang.org/resource/image/f1/f7/f1adcc92da9091037ccc022f29911ef7.png" alt="测试用例设计过程"></p><h3 id="什么才算是“好的”测试用例？">什么才算是“好的”测试用例？</h3><p>测试用例的好坏与被测试对象的测试结果无关，好的测试用例必须具备</p><ul><li><code>整体完备性</code>： “好的”测试用例一定是一个完备的整体，是有效测试用例组成的集合，能够完全覆盖测试需求。</li><li><code>等价类划分的准确性</code>： 指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。</li><li><code>等价类集合的完备性</code>： 需要保证所有可能的边界值和边界条件都已经正确识别。</li></ul><h3 id="三种最常用的测试用例设计方法">三种最常用的测试用例设计方法</h3><p>1、等价类划分方法<br>我们只要从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖结果。<br>一个具体的例子</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生信息系统中有一个“考试成绩”的输入项，成绩的取值范围是 <span class="number">0</span>~<span class="number">100</span> 之间的整数，考试成绩及格的分数线是 <span class="number">60</span>。</span><br></pre></td></tr></table></figure><p>最终测试用例为</p><ul><li>有效等价类 1：0~59 之间的任意整数；</li><li>有效等价类 2：59~100 之间的任意整数；</li><li>无效等价类 1：小于 0 的负数；</li><li>无效等价类 2：大于 100 的整数；</li><li>无效等价类 3：0~100 之间的任何浮点数；</li><li>无效等价类 4：其他任意非数字字符。</li></ul><p>2、边界值分析方法<br>边界值分析是对等价类划分的补充，你从工程实践经验中可以发现，大量的错误发生在输入输出的边界值上，所以需要对边界值进行重点测试，通常选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。<br>我们继续看学生信息系统中“考试成绩”的例子，选取的边界值数据应该包括：<br><code>-1，0，1，59，60，61，99，100，101</code>。</p><p>3、错误推测方法<br>错误推测方法是指基于对被测试软件系统设计的理解、过往经验以及个人直觉，推测出软件可能存在的缺陷，从而有针对性地设计测试用例的方法。这个方法强调的是对被测试软件的需求理解以及设计实现的细节把握，当然还有个人的能力。</p><h3 id="如何才能设计出“好的”测试用例？">如何才能设计出“好的”测试用例？</h3><p><a href="(https://time.geekbang.org/column/article/10150)">查看原文</a></p><h3 id="总结">总结</h3><p>首先，理解测试用例是一个完备的集合，好的测试用例从原始业务需求出发进行分析设计。其次，理解三种常用的测试用例设计方法<code>等价类划分方法</code>、<code>边界值分析方法</code>、<code>边界值分析方法</code></p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/10150" rel="external nofollow noopener noreferrer" target="_blank">如何设计一个“好的”测试用例？</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;测试用例设计过程&quot;&gt;测试用例设计过程&lt;/h3&gt;
&lt;p&gt;以“用户登录”功能的测试用例设计为例，画了一张图来帮你理清这些概念之间的映射关系。图中的业务需求到软件功能需求、软件功能需求到测试需求，以及测试需求到测试用例的映射关系，&lt;br&gt;
&lt;img src=&quot;https
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="代码测试" scheme="https://hinzer.github.io/wiki/tags/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    
      <category term="笔记" scheme="https://hinzer.github.io/wiki/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>bugreport</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/bugreport/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/bugreport/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-29T03:37:01.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>原生android系统支持<code>adb bugreport</code>命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误</p><p>1、目录结构</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">mi@</span>ubuntu:bugreport$ tree -L <span class="number">1</span></span><br><span class="line">.</span><br><span class="line">├── bugreport-dipper_ru-QKQ1<span class="number">.190828</span><span class="number">.002</span><span class="number">-2020</span><span class="number">-03</span><span class="number">-26</span><span class="number">-16</span><span class="number">-15</span><span class="number">-04.</span>txt  #最重要的文件</span><br><span class="line">├── dumpstate_board.txt</span><br><span class="line">├── dumpstate_log.txt</span><br><span class="line">├── FS</span><br><span class="line">├── lshal-debug</span><br><span class="line">├── main_entry.txt</span><br><span class="line">├── outfile.log</span><br><span class="line">├── proto</span><br><span class="line">└── version.txt</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">6</span> files</span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><p>1、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#anrs-deadlocks" rel="external nofollow noopener noreferrer" target="_blank">ANR和死锁</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 找出无响应的应用(系统会终止该进程并将堆栈转储到 /data/anr)</span><br><span class="line">grep &quot;am_anr&quot; bugreport-2015-10-01-18-13-48.txt  # 为二进制事件日志中的 am_anr 执行 grep 命令</span><br><span class="line">grep &quot;ANR in&quot; bugreport-2015-10-01-18-13-48.txt  # 为 logcat 日志（其中包含关于发生 ANR 时是什么在占用 CPU 的更多信息）中的 ANR in 执行 grep 命令</span><br><span class="line"></span><br><span class="line"># 查找堆栈跟踪( ANR 对应的堆栈跟踪 --&gt; 进程主线程)</span><br><span class="line">------ VM TRACES AT LAST ANR</span><br><span class="line">------ TRACES JUST NOW 和 </span><br><span class="line"></span><br><span class="line"># 查找死锁(系统服务器发生死锁，监控程序最终会将其终止)</span><br><span class="line">WATCHDOG KILLING SYSTEM PROCESS</span><br></pre></td></tr></table></figure><p>2、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#activities" rel="external nofollow noopener noreferrer" target="_blank">Activity</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看聚焦状态的activity(崩溃期间处于聚焦状态的 Activity 表示当前用户操作)</span><br><span class="line">grep &quot;am_focused_activity&quot; bugreport-2015-10-01-18-13-48.txt</span><br><span class="line"></span><br><span class="line"># 查看进程启动事件</span><br><span class="line">grep &quot;Start proc&quot; bugreport-2015-10-01-18-13-48.txt</span><br><span class="line"></span><br><span class="line"># 设备是否发生系统颠簸</span><br><span class="line">grep -e &quot;am_proc_died&quot; -e &quot;am_proc_start&quot; bugreport-2015-10-01-18-13-48.txt</span><br></pre></td></tr></table></figure><p>3、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#memory" rel="external nofollow noopener noreferrer" target="_blank">内存</a><br>4、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#broadcasts" rel="external nofollow noopener noreferrer" target="_blank">广播</a><br>5、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#monitor%20contention" rel="external nofollow noopener noreferrer" target="_blank">显示器争用</a><br>6、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#background-compilation" rel="external nofollow noopener noreferrer" target="_blank">后台编译</a><br>7、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#narrative" rel="external nofollow noopener noreferrer" target="_blank">叙述</a><br>8、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#power" rel="external nofollow noopener noreferrer" target="_blank">电源</a><br>9、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#packages" rel="external nofollow noopener noreferrer" target="_blank">程序包</a><br>10、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#processes" rel="external nofollow noopener noreferrer" target="_blank">进程</a><br>11、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#scans" rel="external nofollow noopener noreferrer" target="_blank">扫描</a></p><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://developer.android.com/studio/debug/bug-report" rel="external nofollow noopener noreferrer" target="_blank">获取并阅读错误报告</a></li><li><a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">阅读错误报告</a></li><li><a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=181967386" rel="external nofollow noopener noreferrer" target="_blank">Android Log机制、Logcat及MIUI 284日志介绍</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;原生android系统支持&lt;code&gt;adb bugreport&lt;/code&gt;命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误&lt;/p&gt;
&lt;p&gt;1、目录结构&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Log" scheme="https://hinzer.github.io/wiki/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>理解单元测试</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E7%90%86%E8%A7%A3%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/理解单元测试/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-28T00:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解概念">理解概念</h3><p>1、单元测试的概念理解</p><blockquote><p>单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类。</p></blockquote><p>一个工厂生产电视机的例子。如果把电视机的生产、测试和软件的开发、测试进行类比，你可以发现：</p><ul><li>电子元器件就像是软件中的单元，通常是函数或者类，对单个元器件的测试就像是软件测试中的<code>单元测试</code>；</li><li>组装完成的功能电路板就像是软件中的模块，对电路板的测试就像是软件中的<code>集成测试</code>；</li><li>电视机全部组装完成就像是软件完成了预发布版本，电视机全部组装完成后的开机测试就像是软件中的<code>系统测试</code>。</li></ul><p>2、单元测试对开发的好处</p><ol><li>单元测试属于最严格的软件测试手段，是最接近代码底层实现的验证手段，可以在软件开发的早期以最小的成本保证局部代码的质量。</li><li>单元测试都是以自动化的方式执行，所以在大量回归测试的场景下更能带来高收益。</li><li>单元测试的实施过程还可以帮助开发工程师改善代码的设计与实现，并能在单元测试代码里提供函数的使用示例，因为单元测试的具体表现形式就是对函数以各种不同输入参数组合进行调用，这些调用方法构成了函数的使用说明。</li></ol><h3 id="掌握方法">掌握方法</h3><blockquote><p>如何做好单元测试?你首先必须弄清楚单元测试的对象是代码，以及代码的基本特征和产生错误的原因，然后你必须掌握单元测试的基本方法和主要技术手段。<br>1、代码基本特征与产生错误的原因</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无论是开发语言还是脚本语言，都会有条件分支、循环处理和函数调用等最基本的逻辑控制，如果抛开代码需要实现的具体业务逻辑，仅看代码结构的话，你会发现所有的代码都是在对数据进行分类处理，每一次条件判定都是一次分类处理，嵌套的条件判定或者循环执行，也是在做分类处理。</span><br></pre></td></tr></table></figure><p>可见，要做到代码功能逻辑正确，必须做到分类正确并且完备无遗漏，同时每个分类的处理逻辑必须正确。而在开发实践的过程中，通常考虑从以下方面考虑</p><ul><li>如果要实现正确的功能逻辑，会有哪几种<code>正常的输入</code>；</li><li>是否有需要特殊处理的多种<code>边界输入</code>；</li><li>各种潜在<code>非法输入</code>的可能性以及如何处理。</li></ul><p>2、测试用例<br>单元测试的用例是一个<code>输入数据</code>和<code>预计输出</code>的集合。<br><strong>完整的输入数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">被测试函数的输入参数；</span><br><span class="line">被测试函数内部需要读取的全局静态变量；</span><br><span class="line">被测试函数内部需要读取的成员变量；</span><br><span class="line">函数内部调用子函数获得的数据；</span><br><span class="line">函数内部调用子函数改写的数据；</span><br><span class="line">嵌入式系统中，在中断调用时改写的数据</span><br></pre></td></tr></table></figure><p><strong>明确的预计输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">被测试函数的返回值；</span><br><span class="line">被测试函数的输出参数；</span><br><span class="line">被测试函数所改写的成员变量；</span><br><span class="line">被测试函数所改写的全局变量；</span><br><span class="line">被测试函数中进行的文件更新；</span><br><span class="line">被测试函数中进行的数据库更新；</span><br><span class="line">被测试函数中进行的消息队列更新；</span><br></pre></td></tr></table></figure><p>3、<code>驱动代码</code>，<code>桩代码</code>和<code>Mock代码</code><br><code>驱动代码</code>，<code>桩代码</code>和<code>Mock代码</code>，是单元测试中最常出现的三个名词<br><img src="https://static001.geekbang.org/resource/image/4b/2f/4b593086d9370bea9afc2d12219a0c2f.png" alt></p><ul><li><code>驱动代码</code>，指调用被测函数的代码，单元测试过程中，驱动模块通常包括调用被测函数前的数据准备、调用被测函数以及验证相关结果三个步骤。驱动代码的结构，通常由单元测试的框架决定。</li><li><code>桩代码</code>，是用来代替真实代码的临时代码。 比如，某个函数 A 的内部实现中调用了一个尚未实现的函数 B，为了对函数 A 的逻辑进行测试，那么就需要模拟一个函数 B，这个模拟的函数 B 的实现就是所谓的桩代码。</li><li><code>Mock</code>，Mock 代码和桩代码非常类似，都是用来代替真实代码的临时代码，起到隔离和补齐的作用。在使用 Mock 代码的测试中，对于结果的验证（也就是 assert），通常出现在 Mock 函数中。</li></ul><h3 id="实际流程">实际流程</h3><p>实际软件项目中开展单元测试</p><ol><li>并不是所有的代码都要进行单元测试，通常只有底层模块或者核心模块的测试中才会采用单元测试。</li><li>你需要确定单元测试框架的选型，这和开发语言直接相关。</li><li>为了能够衡量单元测试的代码覆盖率，通常你还需要引入计算代码覆盖率的工具。</li><li>最后你需要把单元测试执行、代码覆盖率统计和持续集成流水线做集成，以确保每次代码递交，都会自动触发单元测试，并在单元测试执行过程中自动统计代码覆盖率，最后以“单元测试通过率”和“代码覆盖率”为标准来决定本次代码递交是否能够被接受。</li></ol><h3 id="总结">总结</h3><p>全部笔记内容从茹炳晟的《软件测试52讲》整理。</p><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/10275" rel="external nofollow noopener noreferrer" target="_blank">什么是单元测试？如何做好单元测试？</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解概念&quot;&gt;理解概念&lt;/h3&gt;
&lt;p&gt;1、单元测试的概念理解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="代码测试" scheme="https://hinzer.github.io/wiki/tags/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    
      <category term="笔记" scheme="https://hinzer.github.io/wiki/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git fetch</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-fetch/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-fetch/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>从远程取最新的patch或者分支，引用的信息记录到<code>.git/FETCH_HEAD</code>这个文件中。可以借助<code>git fetch --help</code>查看具体描述。可以操作一个分支<code>git pull = git getch + git merge</code>，也可以单独pick一个patch<code>git fetch + git cherry-pick</code>。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### 从gerrit上取一个patch，然后pick到当前分支</span><br><span class="line">git fetch ssh:<span class="comment">//wangjianfeng1@git.mioffice.cn:29418/device/xiaomi/merlin refs/changes/17/909617/1</span></span><br><span class="line">git cherry-pick FETCH_HEAD</span><br><span class="line"></span><br><span class="line">### 获取远程库的分支更新，然后merge到本地分支</span><br><span class="line">git fetch origin master:tmp #从远程仓库master分支获取最新，在本地建立tmp分支</span><br><span class="line">git diff tmp #將當前分支和tmp進行對比</span><br><span class="line">git merge tmp #合并tmp分支到当前分支</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.cnblogs.com/qiu-Ann/p/7902855.html" rel="external nofollow noopener noreferrer" target="_blank">git fetch 和git pull 的差别</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;从远程取最新的patch或者分支，引用的信息记录到&lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;这个文件中。可以借助&lt;code&gt;git fetch --help&lt;/code&gt;查看具体描述。可以操作一个分支&lt;code&gt;git 
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>打patch</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/%E6%89%93patch/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/打patch/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>patch是某一次提交给文件内容的改变，打patch是将某一次改变的内容应用到当前的版本库。</p><h3 id="常规操作">常规操作</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成patch</span></span><br><span class="line">git diff <span class="string">./</span> &gt; xxx.<span class="keyword">patch</span>  <span class="comment">#将差异的内容制作成patch</span></span><br><span class="line">mkdir update &amp;&amp; git diff commit-id-time1 commit-id-time2 <span class="params">--name-only</span> | xargs -i cp '&#123;&#125;' <span class="string">./update/</span> <span class="params">--parents</span> <span class="comment">#制作patch 把两个commit-id 之间修改的文件复制到update目录中 而且会把中间的目录也一并生成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打patch</span></span><br><span class="line"><span class="keyword">patch</span> -p1 &lt; xxx.<span class="keyword">patch</span></span><br></pre></td></tr></table></figure><h3 id="另外">另外</h3><p>不过我们有线上的gerrit仓库，日常使用<code>git fetch</code> + <code>git cherry-pick</code>效果是一样的，cherry-pick直接pick某一个patch.</p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/tf1Wyudp7l9XWM0ILAhZpQ" rel="external nofollow noopener noreferrer" target="_blank">你知道用git打补丁吗？</a></li><li><a href="https://www.git-scm.com/book/en/v2/Appendix-C%3A-Git-Commands-Patching" rel="external nofollow noopener noreferrer" target="_blank">Git Commands - Patching</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;patch是某一次提交给文件内容的改变，打patch是将某一次改变的内容应用到当前的版本库。&lt;/p&gt;
&lt;h3 id=&quot;常规操作&quot;&gt;常规操作&lt;/h3&gt;
&lt;figure class=&quot;highlight jboss-cli&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>push代码</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/push%E4%BB%A3%E7%A0%81/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/push代码/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:27:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用法">用法</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wjf@ubuntu:base$ pwd</span><br><span class="line">/home/wjf/miui/umi-q/frameworks/base</span><br><span class="line">wjf@ubuntu:base$ repo info .</span><br><span class="line">Manifest branch: miui-q-umi-stable</span><br><span class="line">Manifest merge branch: refs/heads/stable</span><br><span class="line">Manifest groups: all,-notdefault</span><br><span class="line">----------------------------</span><br><span class="line">Project: platform/frameworks/base</span><br><span class="line">Mount path: /home/wjf/miui/umi-q/frameworks/base</span><br><span class="line">Current revision: miui-q-umi-stable</span><br><span class="line">Local Branches: 0</span><br><span class="line">----------------------------</span><br><span class="line">wjf@ubuntu:base$ git push ssh://wangjianfeng1@gerrit.pt.miui.com:29418/platform/frameworks/base HEAD:refs/for/miui-q-umi-stable</span><br></pre></td></tr></table></figure><ul><li><code>git push</code> git语法表示远程推送,<code>git push help</code>查看详细情况</li><li><code>ssh://wangjianfeng1@gerrit.pt.miui.com:29418/platform/frameworks/base</code>表示使用ssh协议访问gerrit服务器的29418端口，通过url定位到frameworks/base这个目录，是要推送的目录</li><li><code>HEAD:refs/for/miui-q-umi-stable</code>,HEAD指向当前的本地分支，refs/for/miui-q-umi-stable表示远程分支名。</li></ul><p><em>ps: 在修改目录下，git remote -v命令查看代码服务器的git仓库的链接，repo info .获取gerrit仓库远程提交点（分支名）</em></p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.cnblogs.com/sparkdev/p/6071533.html" rel="external nofollow noopener noreferrer" target="_blank">SSH协议语法格式</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用法&quot;&gt;用法&lt;/h3&gt;
&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>android源码管理工具</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/android%E6%BA%90%E7%A0%81%E5%B7%A5%E5%85%B7/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/android源码工具/</id>
    <published>2020-03-27T16:11:37.000Z</published>
    <updated>2020-03-29T01:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Google使用git和repo管理AOSP源码。</p></blockquote><h3 id="概念区分">概念区分</h3><p>1、Git和git(<a href="https://source.android.com/setup/develop#git" rel="external nofollow noopener noreferrer" target="_blank">https://source.android.com/setup/develop#git</a>)<br>Git是版本控制系统，我们使用git工具进行代码仓库和分支的管理。比如我可以使用<code>git clone</code>从远程仓库的一个分支下载代码到本地，可以<code>git push</code>将本地仓库的某一个分支推送到远程仓库的分支，关于git使用可以参考<a href="https://www.git-scm.com/book/en/v2" rel="external nofollow noopener noreferrer" target="_blank">progit</a><br>Google将android源码拆分成许多个Git仓库，我们知道每一个git仓库下有<code>.git</code>文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="meta">@ubuntu</span>:android<span class="number">-10</span>$ find -name <span class="string">".git"</span></span><br><span class="line">.<span class="regexp">/developers/</span>demos/.git</span><br><span class="line">.<span class="regexp">/developers/</span>build/.git</span><br><span class="line">.<span class="regexp">/developers/</span>samples<span class="regexp">/android/</span>.git</span><br><span class="line">.<span class="regexp">/.repo/</span>repo/.git</span><br><span class="line">.<span class="regexp">/.repo/</span>manifests/.git</span><br><span class="line">.<span class="regexp">/cts/</span>.git</span><br><span class="line">.<span class="regexp">/platform_testing/</span>.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>go<span class="regexp">/linux-x86/</span>.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>go<span class="regexp">/darwin-x86/</span>.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>build-tools/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>clang<span class="regexp">/host/</span>linux-x86/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>clang<span class="regexp">/host/</span>darwin-x86/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>checkcolor/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>android-emulator/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>asuite/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>gradle-plugin/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>manifest-merger/.git</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>2、Repo和repo(<a href="https://source.android.com/setup/develop#repo" rel="external nofollow noopener noreferrer" target="_blank">https://source.android.com/setup/develop#repo</a>)<br>然后使用一个Repo仓库对这些拆分开来的Git仓库集中起来进行管理，在源码根目录下有一个<code>.repo</code>文件，其中<code>manifest.xml</code>是一个清单文件，记录了<code>远程分支</code>、<code>本地分支</code>、<code>本地目录</code>之间对应关系。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>tree .repo -L <span class="number">1</span></span><br><span class="line">.repo</span><br><span class="line">├── manifests       <span class="comment"># 所有清单文件保存</span></span><br><span class="line">├── manifests.git</span><br><span class="line">├── manifest.xml     <span class="comment"># 重要，当前清单文件的指向！！</span></span><br><span class="line">├── project.list</span><br><span class="line">├── project-objects</span><br><span class="line">├── projects</span><br><span class="line">└── repo</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>在<code>.repo</code>目录之前，还有一个repo工具(通过它来初始化repo仓库)，这是一个python写的脚本，可以直接阅读源码(也就是可执行文件的位置)查看代码逻辑。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>whereis repo</span><br><span class="line"><span class="symbol">repo:</span> /home/hinzer/bin/repo</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>cat /home/hinzer/bin/repo</span><br></pre></td></tr></table></figure><p><em>PS: google将android源码拆分成许多个Git仓库，又通过Repo将这些拆分还原回一个android源码。像不像计算机原理中的<code>化整为零，还零为整</code>的思想？</em></p><h3 id="平时使用">平时使用</h3><p>1、Repo和Git<br>Repo 并非用来取代 Git，只是为了让您在 Android 环境中更轻松地使用 Git。一般我们使用<code>repo</code>命令建立Repo仓库，同步android源码；使用<code>git</code>命令对我们修改的其中一个模块提交。</p><p>2、Gerrit仓库<br>一个网页系统，用于代码审核，也方便查看别人提交的patch。</p><p>3、OpenGrok<br>网页系统，在线阅读源码的利器。</p><p>4、Android Studio<br>用于开发 Android 应用的官方集成开发环境 (IDE)。</p><h3 id="相关资料">相关资料</h3><blockquote><ul><li><a href="https://git-scm.com/doc" rel="external nofollow noopener noreferrer" target="_blank">Git 文档</a></li><li><a href="https://source.android.com/setup/develop/repo" rel="external nofollow noopener noreferrer" target="_blank">Repo 命令参考文档</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Google使用git和repo管理AOSP源码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概念区分&quot;&gt;概念区分&lt;/h3&gt;
&lt;p&gt;1、Git和git(&lt;a href=&quot;https://source.android.com/setup/d
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
      <category term="Repo" scheme="https://hinzer.github.io/wiki/tags/Repo/"/>
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>02 Linux命令</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/02%20Linux%E5%91%BD%E4%BB%A4/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/02 Linux命令/</id>
    <published>2020-03-21T14:01:02.000Z</published>
    <updated>2020-03-29T03:23:42.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，<code>运行程序</code>和<code>安装软件</code>的命令整理一下。</p></blockquote><h3 id="运行程序">运行程序</h3><p>通过命令行让Linux执行<code>程序</code>，有以下几种方式，也决定<code>进程</code>已什么方式运行。<br><strong>1、交互式运行</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>./filename  <span class="comment"># 交互式运行，Ctrl+C可以结束这个在执行的进程</span></span><br></pre></td></tr></table></figure><p><strong>2、后台方式运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脱离终端后台运行，并将log输出到xxx.outfile文件。</span></span><br><span class="line"><span class="comment"># nohup命令使终端关闭也不影响进程(进程正常是终端进程fork过来的，父进程挂起....), 2&amp;&gt;1表示将标准输出合并错误输出到xxx.outfile,&amp;设置进程后台运行</span></span><br><span class="line">$ nohup ./<span class="built_in">command</span> &gt; xxx.outfile 2&amp;&gt;1 &amp;  <span class="comment"># 后台运行进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps -ef |grep 关键字过滤出进程信息，通过awk '&#123;print $2&#125;'找出进程id，然后通过xargs命令传递给kill -9 ，最终干掉这个进程</span></span><br><span class="line">$ ps -ef |grep 关键字 |awk <span class="string">'&#123;print $2&#125;'</span>|xargs <span class="built_in">kill</span> -9 <span class="comment"># kill 这个进程的方法</span></span><br></pre></td></tr></table></figure><p><strong>3、服务方式运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  systemctl工具管理服务</span></span><br><span class="line">$ systemctl <span class="built_in">enable</span> service-name</span><br><span class="line">$ systemctl start service-name</span><br><span class="line">$ systemctl stop service-name</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p><em>现在有一个小问题</em></p><blockquote><p>Q: 后台运行的进程和服务都是可以脱离终端独立存在的，那么两者有什么区别呢？<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>A：查到<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/11027121?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">系统服务</a>的概念，总结两点区别：1、服务是系统功能的进程；进程是用户的进程。2、服务不会与用户交互，在后台默默运行(这点和后台进程一样)</p></blockquote><p><br><br></p><h3 id="安装软件">安装软件</h3><p>无论是<code>Ubuntu</code>系还是<code>CentOS</code>系的Linux发行版，总有几种安装软件的方式，<code>下载安装包</code>、<code>通过软件管家</code>、<code>直接下载压缩包</code>或者通过<code>源码编译</code>。<br><strong>1、下载安装包安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -i xxxx.deb   <span class="comment"># 如果是chentos的话，使用rpm命令</span></span><br></pre></td></tr></table></figure><p><strong>2、通过软件管家安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install xxxx    <span class="comment"># 如果是chentos的话，使用yum命令</span></span><br></pre></td></tr></table></figure><p><strong>3、下载压缩包安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=XXX/bin:PATH <span class="comment">#将可执行文件bin添加到PATH变量，可将这个命令配置在~/.bashrc文件，每次重启Linux加载这个文件</span></span><br></pre></td></tr></table></figure><p><strong>4、源码编译安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对当前环境评估，--prefix指定安装路径</span></span><br><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成安装包</span></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装软件</span></span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>引用文章中总结的图片<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzg4L2U1Lzg4NTViYjY0NWQ4ZWNjMzVjODBhYTg5Y2RlNWQxNmU1LmpwZw?x-oss-process=image/format,png" alt="Linux常用命令"></p><h3 id="课后作业">课后作业</h3><p>课后要求是安装jdk和mysql，搭建一个数据库服务。我没有去做，不过我找到一个部署的教程,很有参考意义:<br><a href="https://www.linuxprobe.com/chapter-20.html#2021_Mysql" rel="external nofollow noopener noreferrer" target="_blank">使用LNMP架构部署动态网站环境</a></p><br><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://time.geekbang.org/column/article/88761" rel="external nofollow noopener noreferrer" target="_blank">快速上手几个Linux命令：每家公司都有自己的黑话</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，&lt;code&gt;运行程序&lt;/code&gt;和&lt;code&gt;安装软件&lt;/code&gt;的命令整理一下。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>01 操作系统</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/01%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/01 操作系统/</id>
    <published>2020-03-21T12:33:10.000Z</published>
    <updated>2020-03-29T01:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色</p></blockquote><h3 id="计算机硬件组成">计算机硬件组成</h3><p>对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、硬盘、网卡…</p><p><img src="http://qiniu.benmoom.cn/01%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt="插入图片01"></p><p>但仅有硬件组成的电脑，还不能直接使用。&quot;硬件 + 操作系统&quot;才算是我们通常说的电脑，以后的学习主要围绕linux系统，这个话题展开。我们首先必须承认操作系统的重要性。</p><h3 id="想理解外包公司一样理解操作系统">想理解外包公司一样理解操作系统</h3><p>刘超老师将操作系统类比成一家外包公司。确实很形象，加深了我对linux系统的理解。<br>内核对于操作系统，相当于公司的老板，老板是不轻易干活的(一般有很多部门)，所以linux系统中也有很多子系统。对应关系有：</p><table><thead><tr><th>linux系统</th><th>外包公司</th></tr></thead><tbody><tr><td>用户</td><td>公司的客户</td></tr><tr><td>内核</td><td>公司的老板</td></tr><tr><td>系统调用</td><td>公司的办事大厅</td></tr><tr><td>设备管理系统</td><td>公司的客户对接和交付部门</td></tr><tr><td>网络管理系统</td><td>公司的对外合作部门</td></tr><tr><td>进程管理系统</td><td>公司的项目管理部门</td></tr><tr><td>内存管理系统</td><td>公司的会议室</td></tr><tr><td>文件系统系统</td><td>公司的档案室</td></tr></tbody></table><p>其他：<code>程序</code>相当于<code>项目计划书</code>，<code>进程</code>相当于<code>正在进行的项目</code>。</p><p><img src="http://qiniu.benmoom.cn/02%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpeg" alt="插入图片02"></p><h3 id="“点击QQ事件”">“点击QQ事件”</h3><p>为了更好的理解linux的运作机制，老师分析了&quot;用户点击qq&quot;事件。分为如下几个阶段</p><p><strong>阶段一：用户点击图标</strong><br>对于linux而言，驱动捕捉到用户点击事件，产生中断。cpu调用到驱动事先安排好的中断处理函数。</p><p>对于外包公司而言，对接人员记录客户提出的需求，进行项目开发的计划。</p><p><strong>阶段二：系统加载进程</strong><br>对于linux而言，将qq的程序文件从硬盘加载到内存，内存上以进程启动。这个阶段需要思考几个问题：<br>1. 硬盘上的文件如何管理？<br>2. 内存空间上的进程如何管理？<br>3. 多进程如何实现？<br>4. 进程自身如何实现功能？<br>硬件上的数据有<code>文件系统</code>进行统一管理；进程在内存空间上的映射由<code>内存管理系统</code>完成；多进程的实现通过<code>进程管理系统</code>；系统对进程提供统一的接口，实现核心功能。这层接口称为<code>系统调用层</code>。</p><p>对于外包公司而言，从档案库中取出项目计划书，成立项目组，划分会议室，完成立项的过程。然后执行项目，通过办事大厅处理业务，和各个部门打交道。这些都是动态的过程。之后就比较好理解了。</p><p><img src="http://qiniu.benmoom.cn/03linux%E5%AD%90%E7%B3%BB%E7%BB%9F.jpeg" alt="插入图片03"></p><p><strong>阶段三：进程调出对话框</strong><br>对于linux而言，进程调出显示对话框，进程-&gt;显卡驱动-&gt;显示界面</p><p>对于公司，这里显卡驱动相当于客户的交付人员，项目组通过交付人员将项目的成果交付给用户。</p><p><strong>阶段四：用户操作输入框</strong><br>用户在输入框输入，字符立即显示，键盘驱动-&gt;进程-&gt;显卡驱动-&gt;显示界面</p><p>对于公司，就是对接人员处理客户不断提出的需求–交付人员交付的过程</p><p><strong>阶段五：用户按回车发送</strong><br>对于linux系统，用户按下回车键，网络发送到远程的另一个用户，键盘驱动-&gt;进程-&gt;网卡驱动</p><p>对于公司，有时候为了实现需求，需要与其他公司的交互，通过对外合作部门。</p><h3 id="总结">总结</h3><p>以一张图片概括我对这篇文章的理解<br><img src="http://qiniu.benmoom.cn/a%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0.png" alt="插入图片-综述"></p><h3 id="课后作业">课后作业</h3><p>对于<strong>课堂练习</strong>，找出linux源码中几个子系统所在的目录（参考同学给出的答案）</p><p><strong>linux内核</strong>：<a href="https://www.kernel.org/" rel="external nofollow noopener noreferrer" target="_blank">https://www.kernel.org/</a></p><ul><li>系统调用 kernel/</li><li>进程管理 kernel/, arch/<arch>/kernel</arch></li><li>内存管理 mm/, arch/<arch>/mm</arch></li><li>文件系统 fs/</li><li>设备系统 drivers/char, drivers/block</li><li>网络系统 net/</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/88060" rel="external nofollow noopener noreferrer" target="_blank">《趣谈Linux操作系统》03章</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;计算机硬件组成&quot;&gt;计算机硬件组成&lt;/h3&gt;
&lt;p&gt;对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
  </entry>
  
</feed>
