<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hinzer&#39;s Wiki</title>
  
  <subtitle>先打基础</subtitle>
  <link href="/wiki/atom.xml" rel="self"/>
  
  <link href="https://hinzer.github.io/wiki/"/>
  <updated>2020-03-21T14:14:44.089Z</updated>
  <id>https://hinzer.github.io/wiki/</id>
  
  <author>
    <name>hinzer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Linux命令运行程序、安装软件</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B002/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/操作系统综述02/</id>
    <published>2020-03-21T14:01:02.000Z</published>
    <updated>2020-03-21T14:14:44.089Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，<code>运行程序</code>和<code>安装软件</code>的命令整理一下。</p></blockquote><h3 id="运行程序">运行程序</h3><p>通过命令行让Linux执行<code>程序</code>，有以下几种方式，也决定<code>进程</code>已什么方式运行。<br><strong>1、交互式运行</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>./filename  <span class="comment"># 交互式运行，Ctrl+C可以结束这个在执行的进程</span></span><br></pre></td></tr></table></figure><p><strong>2、后台方式运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 脱离终端后台运行，并将<span class="built_in">log</span>输出到xxx.outfile文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nohup命令使终端关闭也不影响进程(进程正常是终端进程fork过来的，父进程挂起....), 2&amp;&gt;1表示将标准输出合并错误输出到xxx.outfile,&amp;设置进程后台运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nohup ./<span class="built_in">command</span> &gt; xxx.outfile 2&amp;&gt;1 &amp;  <span class="comment"># 后台运行进程</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ps -ef |grep 关键字过滤出进程信息，通过awk <span class="string">'&#123;print $2&#125;'</span>找出进程id，然后通过xargs命令传递给<span class="built_in">kill</span> -9 ，最终干掉这个进程</span></span><br><span class="line">ps -ef |grep 关键字 |awk '&#123;print $2&#125;'|xargs kill -9 # kill 这个进程的方法</span><br></pre></td></tr></table></figure><p><strong>3、服务方式运行</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  systemctl工具管理服务</span></span><br><span class="line">$ systemctl <span class="builtin-name">enable</span> service-name</span><br><span class="line">$ systemctl start service-name</span><br><span class="line">$ systemctl stop service-name</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p><em>现在有一个小问题</em></p><blockquote><p>Q: 后台运行的进程和服务都是可以脱离终端独立存在的，那么两者有什么区别呢？<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>A：查到<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/11027121?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">系统服务</a>的概念，总结两点区别：1、服务是系统功能的进程；进程是用户的进程。2、服务不会与用户交互，在后台默默运行(这点和后台进程一样)</p></blockquote><p><br><br></p><h3 id="安装软件">安装软件</h3><p>无论是<code>Ubuntu</code>系还是<code>CentOS</code>系的Linux发行版，总有几种安装软件的方式，<code>下载安装包</code>、<code>通过软件管家</code>、<code>直接下载压缩包</code>或者通过<code>源码编译</code>。<br><strong>1、下载安装包安装</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>dpkg -i xxxx.deb   <span class="comment"># 如果是chentos的话，使用rpm命令</span></span><br></pre></td></tr></table></figure><p><strong>2、通过软件管家安装</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-<span class="keyword">get</span> install xxxx    <span class="comment"># 如果是chentos的话，使用yum命令</span></span><br></pre></td></tr></table></figure><p><strong>3、下载压缩包安装</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=XXX/bin:PATH #将可执行文件bin添加到PATH变量，可将这个命令配置在~/.bashrc文件，每次重启Linux加载这个文件</span><br></pre></td></tr></table></figure><p><strong>4、源码编译安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对当前环境评估，--prefix指定安装路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span>/program</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译生成安装包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装软件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>引用文章中总结的图片<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzg4L2U1Lzg4NTViYjY0NWQ4ZWNjMzVjODBhYTg5Y2RlNWQxNmU1LmpwZw?x-oss-process=image/format,png" alt="Linux常用命令"></p><h3 id="课后作业">课后作业</h3><p>课后要求是安装jdk和mysql，搭建一个数据库服务。我没有去做，不过我找到一个部署的教程,很有参考意义:<br><a href="https://www.linuxprobe.com/chapter-20.html#2021_Mysql" rel="external nofollow noopener noreferrer" target="_blank">使用LNMP架构部署动态网站环境</a></p><br><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://time.geekbang.org/column/article/88761" rel="external nofollow noopener noreferrer" target="_blank">快速上手几个Linux命令：每家公司都有自己的黑话</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，&lt;code&gt;运行程序&lt;/code&gt;和&lt;code&gt;安装软件&lt;/code&gt;的命令整理一下。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>把Linux内核当成一家软件外包公司的老板</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B001/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/操作系统综述01/</id>
    <published>2020-03-21T12:33:10.000Z</published>
    <updated>2020-03-21T14:10:22.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色</p></blockquote><h3 id="计算机硬件组成">计算机硬件组成</h3><p>对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、硬盘、网卡…</p><p><img src="http://qiniu.benmoom.cn/01%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt="插入图片01"></p><p>但仅有硬件组成的电脑，还不能直接使用。&quot;硬件 + 操作系统&quot;才算是我们通常说的电脑，以后的学习主要围绕linux系统，这个话题展开。我们首先必须承认操作系统的重要性。</p><h3 id="想理解外包公司一样理解操作系统">想理解外包公司一样理解操作系统</h3><p>刘超老师将操作系统类比成一家外包公司。确实很形象，加深了我对linux系统的理解。<br>内核对于操作系统，相当于公司的老板，老板是不轻易干活的(一般有很多部门)，所以linux系统中也有很多子系统。对应关系有：</p><table><thead><tr><th>linux系统</th><th>外包公司</th></tr></thead><tbody><tr><td>用户</td><td>公司的客户</td></tr><tr><td>内核</td><td>公司的老板</td></tr><tr><td>系统调用</td><td>公司的办事大厅</td></tr><tr><td>设备管理系统</td><td>公司的客户对接和交付部门</td></tr><tr><td>网络管理系统</td><td>公司的对外合作部门</td></tr><tr><td>进程管理系统</td><td>公司的项目管理部门</td></tr><tr><td>内存管理系统</td><td>公司的会议室</td></tr><tr><td>文件系统系统</td><td>公司的档案室</td></tr></tbody></table><p>其他：<code>程序</code>相当于<code>项目计划书</code>，<code>进程</code>相当于<code>正在进行的项目</code>。</p><p><img src="http://qiniu.benmoom.cn/02%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpeg" alt="插入图片02"></p><h3 id="“点击QQ事件”">“点击QQ事件”</h3><p>为了更好的理解linux的运作机制，老师分析了&quot;用户点击qq&quot;事件。分为如下几个阶段</p><p><strong>阶段一：用户点击图标</strong><br>对于linux而言，驱动捕捉到用户点击事件，产生中断。cpu调用到驱动事先安排好的中断处理函数。</p><p>对于外包公司而言，对接人员记录客户提出的需求，进行项目开发的计划。</p><p><strong>阶段二：系统加载进程</strong><br>对于linux而言，将qq的程序文件从硬盘加载到内存，内存上以进程启动。这个阶段需要思考几个问题：<br>1. 硬盘上的文件如何管理？<br>2. 内存空间上的进程如何管理？<br>3. 多进程如何实现？<br>4. 进程自身如何实现功能？<br>硬件上的数据有<code>文件系统</code>进行统一管理；进程在内存空间上的映射由<code>内存管理系统</code>完成；多进程的实现通过<code>进程管理系统</code>；系统对进程提供统一的接口，实现核心功能。这层接口称为<code>系统调用层</code>。</p><p>对于外包公司而言，从档案库中取出项目计划书，成立项目组，划分会议室，完成立项的过程。然后执行项目，通过办事大厅处理业务，和各个部门打交道。这些都是动态的过程。之后就比较好理解了。</p><p><img src="http://qiniu.benmoom.cn/03linux%E5%AD%90%E7%B3%BB%E7%BB%9F.jpeg" alt="插入图片03"></p><p><strong>阶段三：进程调出对话框</strong><br>对于linux而言，进程调出显示对话框，进程-&gt;显卡驱动-&gt;显示界面</p><p>对于公司，这里显卡驱动相当于客户的交付人员，项目组通过交付人员将项目的成果交付给用户。</p><p><strong>阶段四：用户操作输入框</strong><br>用户在输入框输入，字符立即显示，键盘驱动-&gt;进程-&gt;显卡驱动-&gt;显示界面</p><p>对于公司，就是对接人员处理客户不断提出的需求–交付人员交付的过程</p><p><strong>阶段五：用户按回车发送</strong><br>对于linux系统，用户按下回车键，网络发送到远程的另一个用户，键盘驱动-&gt;进程-&gt;网卡驱动</p><p>对于公司，有时候为了实现需求，需要与其他公司的交互，通过对外合作部门。</p><h3 id="总结">总结</h3><p>以一张图片概括我对这篇文章的理解<br><img src="http://qiniu.benmoom.cn/a%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0.png" alt="插入图片-综述"></p><h3 id="课后作业">课后作业</h3><p>对于<strong>课堂练习</strong>，找出linux源码中几个子系统所在的目录（参考同学给出的答案）</p><p><strong>linux内核</strong>：<a href="https://www.kernel.org/" rel="external nofollow noopener noreferrer" target="_blank">https://www.kernel.org/</a></p><ul><li>系统调用 kernel/</li><li>进程管理 kernel/, arch/<arch>/kernel</arch></li><li>内存管理 mm/, arch/<arch>/mm</arch></li><li>文件系统 fs/</li><li>设备系统 drivers/char, drivers/block</li><li>网络系统 net/</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/88060" rel="external nofollow noopener noreferrer" target="_blank">《趣谈Linux操作系统》03章</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;计算机硬件组成&quot;&gt;计算机硬件组成&lt;/h3&gt;
&lt;p&gt;对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git 调试</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git%E8%B0%83%E8%AF%95/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git调试/</id>
    <published>2020-03-20T01:20:14.000Z</published>
    <updated>2020-03-21T01:48:43.681Z</updated>
    
    <content type="html"><![CDATA[<p>文件标注<br>使用<code>git blame</code>能显示任何文件中每行最后一次修改的提交记录。<br>mi@ubuntu:base$ git blame Android.bp -L 230,231  #查看Android.bp的230-231行提交记录，<br>#commit id   #提交者        #时间                      #行          #内容<br>7c469179ce2a (junyulai      2019-01-16 20:23:34 +0800 230)         “core/java/android/net/ISocketKeepaliveCallback.aidl”,<br>e40eab608af2 (Benedict Wong 2018-11-14 17:50:13 -0800 231)         “core/java/android/net/ITestNetworkManager.aidl”,</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件标注&lt;br&gt;
使用&lt;code&gt;git blame&lt;/code&gt;能显示任何文件中每行最后一次修改的提交记录。&lt;br&gt;
mi@ubuntu:base$ git blame Android.bp -L 230,231  #查看Android.bp的230-231行提交记录，&lt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git merge失败</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/2020-03-20-bug-for-git/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/2020-03-20-bug-for-git/</id>
    <published>2020-03-19T16:11:37.000Z</published>
    <updated>2020-03-21T01:45:57.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>git merge本地分支出现报错 fatal: refusing to merge unrelated histories<br><img src="http://ww1.sinaimg.cn/large/0063ewMaly1gczozf2n8ij30vn0fognf.jpg" alt="git-merge.jpg"></p><h2 id="第一反应">第一反应</h2><p>我现在都是在本地操作还没有远程，我得理解master分支merge到slave分支，应该直接fast forward过去才对。<br>如果把master分支干掉，直接在slave分支那个位置创建一个master分支应该也没什么影响。就是特别像知道为啥会出错这个merge。</p><h2 id="问题分析">问题分析</h2><p>merge命令之后报错<code>fatal: refusing to merge unrelated histories。</code>，表示当前分支和slave分支不相关。有<a href="https://yq.aliyun.com/articles/614459" rel="external nofollow noopener noreferrer" target="_blank">对应的解决方案</a><br>加上<code>--allow-unrelated-histories</code>参数，忽略这个问题。<br>然而又报错，根据进一步提示，<code>git status</code>发现当前工作目录确实存在冲突。解决完冲突commit之后，再次merge就可以了。</p><p>不记得当时具体做了什么操作了，又重新做了几遍还是没能把当时的情景复现出来(merge直接fast forward了)。后来分析应该是某种原因导致了文件冲突，进而影响之后的merge操作。</p><h2 id="解决方法">解决方法</h2><p>如果是<code>git pull</code>或者<code>git push</code>报<code>fatal: refusing to merge unrelated histories</code>,直接在merge后加上<code>--allow-unrelated-histories</code>参数就ok了<br>如果是依然无效，不妨先<code>git status</code>查看一下当前版本库的状态有无问题(我这边是冲突引起的)。</p><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://yq.aliyun.com/articles/614459" rel="external nofollow noopener noreferrer" target="_blank">解决Git中fatal: refusing to merge unrelated histories</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;git merge本地分支出现报错 fatal: refusing to merge unrelated histories&lt;br&gt;
&lt;img src=&quot;http://ww1.sinaimg.cn/large/0063ewMa
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
      <category term="Bug" scheme="https://hinzer.github.io/wiki/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>git log</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-log/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-log/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:02.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>显示项目提交历史，通过参数选项可以控制log显示的方式。<code>git help log</code>查看具体描述。</p><p>git log 有两个高级用法：一是自定义提交的输出格式，二是过滤输出哪些提交。这两个用法合二为一，你就可以找到你项目中你需要的任何信息。</p><h3 id="使用准则">使用准则</h3><ul><li>git log允许你查看你项目历史中任何需要的内容。</li></ul><h3 id="命令速查">命令速查</h3><p>1、常规使用,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#log_options" rel="external nofollow noopener noreferrer" target="_blank">git log常用选项</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --graph --all <span class="comment">#简略显示各种分支的patch记录，个人比较下常用这个命令</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>    <span class="comment"># 显示每次提交的文件修改统计信息。</span></span><br><span class="line">git <span class="built_in">log</span> -p <span class="comment"># 按补丁格式显示每个提交引入的差异。</span></span><br></pre></td></tr></table></figure><p>2、定制化输出,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#pretty_format" rel="external nofollow noopener noreferrer" target="_blank">–pretty=format常用格式</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> --pretty=<span class="keyword">format</span>:<span class="string">"%h %s"</span> --graph</span><br><span class="line">$ git <span class="keyword">log</span> --date=<span class="keyword">format</span>:<span class="string">'%Y-%m-%d %H:%M:%S'</span> --pretty=<span class="keyword">format</span>:<span class="string">"%h-%an-%ad-%ae"</span> --graph --all</span><br></pre></td></tr></table></figure><ul><li>–date=format定制作者修订日期格式</li><li>–pretty=format定制log记录显示</li><li>–graph图形显示分支与合并历史</li><li>–all显示所有分支</li></ul><p>3、过滤出自己想要看到的log,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#limit_options" rel="external nofollow noopener noreferrer" target="_blank">限制输出长度</a></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> <span class="number">-3</span>  #按次数，最近<span class="number">3</span>次提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --since=<span class="number">2.</span>weeks #按时间，最近两周提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --<span class="keyword">until</span>=<span class="number">2020</span><span class="number">-03</span><span class="number">-20</span> #按时间，<span class="number">2020</span><span class="number">-03</span><span class="number">-20</span>前的提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --grep=<span class="string">"update"</span>#仅显示提交说明中包含<span class="string">"update"</span>的提交</span><br></pre></td></tr></table></figure><p>4、如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> --pretty=<span class="string">"%h - %s"</span> --author=<span class="string">'Junio C Hamano'</span> --since=<span class="string">"2008-10-01"</span> \</span><br><span class="line">   --before=<span class="string">"2008-11-01"</span> --<span class="keyword">no</span>-merges -- t/</span><br><span class="line"><span class="number">5610</span>e3b - Fix testcase failure <span class="keyword">when</span> extended attributes are in <span class="keyword">use</span></span><br><span class="line">acd3b9e - Enhance hold_lock_file_for<span class="number">_</span>&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic <span class="keyword">link</span> HEAD</span><br><span class="line">d1a43f2 - <span class="keyword">reset</span> --hard/<span class="keyword">read</span>-tree --<span class="keyword">reset</span> -u: remove unmerged new paths</span><br><span class="line"><span class="number">51</span>a94af - Fix <span class="string">"checkout --track -b newbranch"</span> on detached HEAD</span><br><span class="line">b0ad11e - pull: allow <span class="string">"git pull origin $something:$current_branch"</span> into an unborn branch</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" rel="external nofollow noopener noreferrer" target="_blank">Git 基础 - 查看提交历史</a></li><li><a href="https://jasonhzy.github.io/2016/05/05/git-log/" rel="external nofollow noopener noreferrer" target="_blank">Git日志格式、颜色设置</a></li><li><a href="https://blog.csdn.net/jk110333/article/details/8590746" rel="external nofollow noopener noreferrer" target="_blank">Linux下date命令，格式化输出，时间设置</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;显示项目提交历史，通过参数选项可以控制log显示的方式。&lt;code&gt;git help log&lt;/code&gt;查看具体描述。&lt;/p&gt;
&lt;p&gt;git log 有两个高级用法：一是自定义提交的输出格式，二是过滤输出哪些提交。这两个用法合二为一
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git log</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-merge/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-merge/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:21.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。<code>git help merge</code>命令查看具体描述。</p><p>将<code>topic</code>分支merge到<code>master</code>分支上(更新master分支)，使用<code>git merge topic</code></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">合并前:</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br><span class="line"><span class="comment">合并后:</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span>         <span class="comment">\</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span>--<span class="literal">-</span><span class="comment">H</span> <span class="comment">master</span></span><br></pre></td></tr></table></figure><h3 id="使用准则">使用准则</h3><ul><li>merge或者pull之前本地仓库是干净的应当commit本地，保证merge之后不会被破坏。或者<code>git stash</code>储藏本地的修改</li><li>merge冲突后可以使用<code>git status</code>查看分支状态，<code>git diff</code>显示工作区文件变化</li></ul><h3 id="命令速查">命令速查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span>   <span class="comment"># merge slave分支到当前HEAD分支， --no-ff </span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span> <span class="comment">--no-ff  # 不使用fast-forward模式，merge同时创建一个新的cmomit patch</span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span> <span class="comment">--allow-unrelated-histories   #</span></span><br><span class="line">$ git <span class="keyword">merge</span> -Xignore-<span class="keyword">space</span>-<span class="keyword">change</span> <span class="keyword">whitespace</span> <span class="comment"># 忽略空白merge</span></span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="comment">--abort # (merge失败)恢复到合并前的状态</span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="comment">--continue  # 冲突后执行</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/docs/git-merge/2.12.0" rel="external nofollow noopener noreferrer" target="_blank">git help merge</a></li><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6" rel="external nofollow noopener noreferrer" target="_blank">高级合并</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。&lt;code&gt;git help merge&lt;/code&gt;命令查看具体描述。&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;topic&lt;/code&gt;分支merge到&lt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git rebase</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-rebase/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-rebase/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:45.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>rebase也是整合不同分支的方法，和merge不同的是它会改变提交历史。<code>git help rebase</code>命令查看具体描述。<br>假设当前HEAD指向<code>topic</code>分支，下面执行rebase命令(将topic上的patch打到master上，并改变历史)，使用<code>git rebase master</code></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">rebase前:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br><span class="line"><span class="comment">rebase后:</span></span><br><span class="line"><span class="comment"></span>                             <span class="comment">A'</span>--<span class="comment">B'</span>--<span class="comment">C'</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                            <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br></pre></td></tr></table></figure><p>原理:首先找到这两个分支（即当前分支 topic、变基操作的目标基底分支 master 的最近共同祖先 E，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 G, 最后以此将之前另存为临时文件的修改依序应用</p><h3 id="使用准则">使用准则</h3><ul><li>rebase操作可以让提交历史更加简介，但注意不要影响远程分支的提交历史记录。不要在公共分支上使用rebase</li><li>如果你想把rebase之后的master分支推送到远程仓库，Git会阻止你这么做，因为两个分支包含冲突。但你可以传入<code>--force</code>标记来强行推送。</li><li></li></ul><h3 id="命令速查">命令速查</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase master topic #master是基底分支，将topic分支上的修改在master上重放</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git rebase --onto master<span class="built_in"> server client </span> #选中在<span class="built_in"> client </span>分支里但不在<span class="built_in"> server </span>分支里的修改，将它们在 master 分支上重放</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" rel="external nofollow noopener noreferrer" target="_blank"> Git 分支 - 变基</a></li><li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9" rel="external nofollow noopener noreferrer" target="_blank">Merge、Rebase 的选择</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;rebase也是整合不同分支的方法，和merge不同的是它会改变提交历史。&lt;code&gt;git help rebase&lt;/code&gt;命令查看具体描述。&lt;br&gt;
假设当前HEAD指向&lt;code&gt;topic&lt;/code&gt;分支，下面执行reb
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git reset、git checkout</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-reset_git-checkout/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-reset_git-checkout/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:59.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>1、<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" rel="external nofollow noopener noreferrer" target="_blank">git三棵树</a>,即</p><ul><li>HEAD，永远指向当前分支的最新一笔提交</li><li>Index，索引(暂存区)</li><li>Work Directory,工作目录</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git 底层命令</span></span><br><span class="line">git cat-<span class="built_in">file</span> -p HEAD <span class="comment">#显示HEAD内容</span></span><br><span class="line">git ls-tree -r HEAD <span class="comment">#显示树对象的内容</span></span><br><span class="line">git ls-<span class="built_in">files</span> -s <span class="comment">#显示索引(Index)的所有文件信息</span></span><br><span class="line">tree <span class="comment">#查看当前工作目录</span></span><br></pre></td></tr></table></figure><p>2、git-reset<br>将当前HEAD重置为指定状态。<code>git help reset</code>命令查看具体描述。</p><h3 id="使用准则">使用准则</h3><ul><li>运行<code>git --hard reset</code>之前请考虑一下。如果由于执行这个选项导致工作目录中文件(文件已经提交)被覆盖，可以尝试<code>git reflog</code>找回。</li></ul><h3 id="命令速查">命令速查</h3><p>1、作用于某个patch</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset <span class="params">--soft</span> [<span class="keyword">patch</span>]<span class="comment">#移动HEAD的指向，不改变Index和Work Directory</span></span><br><span class="line">git reset <span class="params">--mixed</span> [<span class="keyword">patch</span>] <span class="comment">#(默认reset)移动HEAD的指向，改变Index，但不改变Work Directory</span></span><br><span class="line">git reset <span class="params">--hard</span> [<span class="keyword">patch</span>]<span class="comment">#移动HEAD的指向，改变Index和Work Directory</span></span><br></pre></td></tr></table></figure><p>2、作用于某个path/file</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> [<span class="keyword">path</span>/<span class="keyword">file</span>]<span class="comment">#通过当前HEAD指向的patch改变当前Index(恢复暂存区)</span></span><br><span class="line">git <span class="keyword">reset</span> [<span class="keyword">patch</span>] [<span class="keyword">path</span>/<span class="keyword">file</span>] <span class="comment">#通过指定patch改变当前Index</span></span><br></pre></td></tr></table></figure><p>3、压缩提交</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset <span class="params">--soft</span> [<span class="keyword">patch</span>] <span class="comment">#HEAD移动到压缩提交的前一个patch，Index和Work Directory不变</span></span><br><span class="line">git commit <span class="comment">#通过Index创建新的patch</span></span><br></pre></td></tr></table></figure><p>###git reset 和 git checkout<br>总结了两点重要的区别，</p><ul><li>操作patch时，chekcout只移动HEAD指针本身(不改变HEAD分支)</li><li>操作path/file时，checkout会改变工作目录(类似git reset --hard)</li></ul><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 重置揭密</a></li><li><a href="https://github.com/zlargon/git-tutorial/blob/master/branch/commit_tree.md" rel="external nofollow noopener noreferrer" target="_blank">多种表示patch的方式</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86&quot; rel=&quot;exter
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git revert</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-revert/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-revert/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:13.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>revert还原提交，撤销已经存在的commit的所有更改，原来的commit将保留，并用新commit来记录还原后的结果。<code>git help revert</code>命令查看具体描述。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD <span class="comment"># 撤销当前HEAD指向的patch上的更改</span></span><br><span class="line"></span><br><span class="line">git revert <span class="keyword">commit</span><span class="comment"># 撤销制定commitid表示的patch上的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge之后的revert</span></span><br><span class="line">git revert -m <span class="number">1</span> <span class="keyword">HEAD</span> <span class="comment"># HEAD指向的节点有两个父节点,-m 1保留父节点1，撤销父节点2带来的改变</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6" rel="external nofollow noopener noreferrer" target="_blank">工具 - 高级合并</a></li><li><a href="https://www.cnblogs.com/0616--ataozhijia/p/3709917.html" rel="external nofollow noopener noreferrer" target="_blank">git revert 用法</a></li><li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/2.6-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9" rel="external nofollow noopener noreferrer" target="_blank">回滚错误的修改</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;revert还原提交，撤销已经存在的commit的所有更改，原来的commit将保留，并用新commit来记录还原后的结果。&lt;code&gt;git help revert&lt;/code&gt;命令查看具体描述。&lt;/p&gt;
&lt;h3 id=&quot;使用准则&quot;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git stash、git clean</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-stash_git-clean/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-stash_git-clean/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:29.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。或在清理(clean)文件。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git stash push <span class="comment"># stash跟踪文件的修改与暂存的改动</span></span><br><span class="line"><span class="variable">$</span> git stash push -<span class="literal">-keep</span><span class="literal">-index</span> <span class="comment"># --keep-index 选项使存储的同时保留索引。</span></span><br><span class="line"><span class="variable">$</span> git stash push -<span class="literal">-all</span><span class="comment"># -u 选项存储untracked文件，</span></span><br><span class="line"><span class="variable">$</span> git stash push <span class="literal">-u</span> <span class="comment"># stash全部文件(包括被忽略文件)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git stash list <span class="comment"># 列出当前的stash</span></span><br><span class="line"><span class="variable">$</span> git stash apply   <span class="comment"># 应用stash, 加上--index 选项可以让之前暂存的文件重新暂存</span></span><br><span class="line"><span class="variable">$</span> git stash drop stash<span class="selector-tag">@</span>&#123;<span class="number">0</span>&#125;<span class="comment"># 移除stash,</span></span><br><span class="line"><span class="variable">$</span> git stash pop <span class="comment"># 应用stash@&#123;0&#125;,并移除它</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git stash branch dev  <span class="comment"># 创建新分支dev，然后应用stash,然后drop stash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git clean <span class="operator">-f</span> <span class="literal">-d</span> <span class="comment"># 移除工作目录中所有未追踪的文件以及空的子目录(不包括被忽略文件)</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-n</span> <span class="comment"># 演戏以下，加-n参数</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-n</span> <span class="literal">-x</span> <span class="comment"># -x选择清理忽略文件</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-x</span> <span class="literal">-i</span> <span class="comment"># -i交互模式</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 贮藏与清理</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。或在清理(clean)文件。&lt;/p&gt;
&lt;h3 id=&quot;使用准则
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git 对象</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git对象/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:40.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="窥探">窥探</h2><p>git对文件内容管理核心是基于<code>键值对数据库</code>，位于<code>.git/objects</code>。通过<code>key-value</code>方式管理内容。<br>对象数据库中存储的三种对象，每一个对象在数据库中以<code>key-value</code>形式存在</p><ul><li>数据对象（blob object），记录文件内容,解决内容存储问题</li><li>树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起</li><li>提交对象（commit object），对应一次提交，解决项目快照的问题</li></ul><p><img src="https://www.git-scm.com/book/en/v2/images/data-model-3.png" alt="对象关系图"></p><h2 id="命令速查">命令速查</h2><p>1、<strong>通用操作</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find</span> .git/objects -<span class="built_in">type</span> <span class="keyword">f</span>  # 列出所有git对象</span><br><span class="line"></span><br><span class="line">git <span class="keyword">cat</span>-<span class="keyword">file</span> -<span class="keyword">p</span> <span class="symbol">&lt;key&gt;</span> # 查看对象内容信息</span><br><span class="line">git <span class="keyword">cat</span>-<span class="keyword">file</span> -t <span class="symbol">&lt;key&gt;</span> # 查看对象类型</span><br><span class="line"></span><br><span class="line">git <span class="keyword">cat</span>-<span class="keyword">file</span> -<span class="keyword">p</span> master^&#123;tree&#125; #查看master分支上最近提交的树对象</span><br></pre></td></tr></table></figure><p><em>PS: 尝试<code>git add</code>、<code>git commit</code>等上层命令，然后<code>find .git/objects -type f</code>查看git对象的变化。<br>发现：git每次add文件，添加数据对象；commit之后，又创建了树对象、和提交对象。<br>于是得出结论：git会记录每一次变化的文件版本(生成blob对象)，对于没有修改的文件tree还是原来的指向。</em></p><p>2、<strong>创建数据对象</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 内容写入数据库，返回key值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin<span class="comment"># -w表示写入数据库, --stdin表示从标准输入流读取</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'version 1'</span> &gt; test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">hash</span>-object -w test.txt <span class="comment">#从文件读取内容写入数据库</span></span></span><br></pre></td></tr></table></figure><p>3、<strong>创建树对象</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 为文件添加暂存区(<span class="built_in">index</span>)</span><br><span class="line">$ git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> --cacheinfo <span class="number">100644</span> \</span><br><span class="line">  <span class="number">83</span>baae61804e65cc73a7201a7252750c76066a30 test.txt# --<span class="built_in">add</span>表示这个文件此前没有添加到<span class="built_in">index</span>, --cacheinfo表示添加的文件在数据库中 匹配此的参数格式为(文件模式 key 文件名)</span><br><span class="line">$ git <span class="keyword">write</span>-tree #通过暂存区创建树对象</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">$ <span class="keyword">echo</span> <span class="string">'new file'</span> &gt; <span class="keyword">new</span>.txt</span><br><span class="line">$ git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> --cacheinfo <span class="number">100644</span> \</span><br><span class="line">  <span class="number">1</span>f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line">$ git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> <span class="keyword">new</span>.txt</span><br><span class="line">文件名)</span><br><span class="line">$ git <span class="keyword">write</span>-tree #通过暂存区创建树对象</span><br></pre></td></tr></table></figure><p>4、<strong>创建提交对象</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'first commit'</span> | git commit-tree d8329f<span class="comment">#(没有父提交)第一步提交</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'second commit'</span> | git commit-tree 0155eb -p fdf4fc3  <span class="comment">#-p参数制定父提交对象的key</span></span></span><br></pre></td></tr></table></figure><p>5、<strong>查看提交历史</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span> 0155eb</span></span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1" rel="external nofollow noopener noreferrer" target="_blank">Git 内部原理 - Git 对象</a></li><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 重置揭密</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;窥探&quot;&gt;窥探&lt;/h2&gt;
&lt;p&gt;git对文件内容管理核心是基于&lt;code&gt;键值对数据库&lt;/code&gt;，位于&lt;code&gt;.git/objects&lt;/code&gt;。通过&lt;code&gt;key-value&lt;/code&gt;方式管理内容。&lt;br&gt;
对象数据库中存储的三种对象，每一个对
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git 引用</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git%E5%BC%95%E7%94%A8/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git引用/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:53.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>git用文件保存patch的哈希值，这个文件名代表一个分支。指针、分支、引用理解是表示一个概念。</p><p><img src="https://git-scm.com/book/en/v2/images/data-model-4.png" alt="git本地仓库"></p><p>1、在<code>.git</code>目录下查看</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HEAD <span class="comment">#指向当前分支</span></span><br><span class="line">refs<span class="regexp">/heads/</span>   <span class="comment">#分支，记录本地commit对象</span></span><br><span class="line">refs<span class="regexp">/tags/</span>  <span class="comment">#tag也记录commit对象，但是通常不会改变</span></span><br><span class="line">refs<span class="regexp">/remotes/origin/</span> <span class="comment">#服务器映射下来的远程只读分支</span></span><br></pre></td></tr></table></figure><p>2、查看HEAD内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mi@ubuntu:test3$ <span class="built_in">cd</span> .git</span><br><span class="line">mi@ubuntu:.git$ cat HEAD</span><br><span class="line">ref: refs/heads/master</span><br><span class="line">mi@ubuntu:.git$ cat refs/heads/master</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line"></span><br><span class="line">mi@ubuntu:.git$ git show HEAD</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master)</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8" rel="external nofollow noopener noreferrer" target="_blank">Git 内部原理 - Git 引用</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;git用文件保存patch的哈希值，这个文件名代表一个分支。指针、分支、引用理解是表示一个概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/data-model-4.
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>小狗钱钱阅读笔记</title>
    <link href="https://hinzer.github.io/wiki/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/"/>
    <id>https://hinzer.github.io/wiki/生活学习/读书笔记/小狗钱钱/</id>
    <published>2020-03-16T23:42:42.000Z</published>
    <updated>2020-03-16T23:43:58.987Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这本书的重点内容：</strong></p><ol><li>怎么攒钱？开始储蓄，迈出财富积累的第一步</li><li>怎么挣钱？付出劳动，挣出第一桶金</li><li>怎么用钱生钱？学会投资，养一只会下金蛋的鹅<br><br></li></ol><h2 id="怎么攒钱？">怎么攒钱？</h2><blockquote><p>攒钱这件事要从哪开始呢？小狗钱钱说，首先要从你脑子里的想法开始。我们首先要正确地认识钱，金钱既不是万能的，也不是万恶之源，它本身没有好坏之分，只是商品流通的媒介。金钱就像一个放大镜，它只是充分展示了人性本来的样子。一个幸福的人有了钱，会更加快乐；一个悲观的人有了钱，会更加忧虑。像比尔·盖茨、扎克伯格这样的人，有了钱，会捐出巨资，帮助他人。而像伊斯兰国这样的恐怖组织，会用钱去购买武器，伤害无辜。<br>你是什么样的人？如果有了钱，你会去做什么？对我们大多数人来说，有了钱，可以提高生活质量，去实现更多的梦想。反之，越是缺钱，我们就越容易被它牵制。小狗钱钱说，吉娅的父母之所以不停地谈钱，就是因为他们的经济状况太糟糕了，好比一个人掉进水里，随时可能会被淹没。</p></blockquote><br><h3 id="梦想清单">梦想清单</h3><p>用笔写下10个你想变得富有的理由，越具体越好，然后从中挑出三个最重要的。在书里，吉娅挑出的3个理由包括，作为交换生去美国，买一台电脑，以及帮助爸妈还清债务。<br><br></p><h3 id="梦想相册">梦想相册</h3><p>那怎么制作梦想相册呢？比如，吉娅想去美国当交换生，她就在相册里贴上迪士尼乐园、自由女神像的照片。相册做完后，吉娅也没有束之高阁，而是每天都看几遍，想象自己在美国认识新的朋友，看到各种新鲜事物。这种方式让吉娅充满了攒钱的动力。<br><br></p><h3 id="梦想储蓄罐">梦想储蓄罐</h3><p>存钱可以让我们避免不必要的花费，做到量入为出。比如吉娅为了存钱，克制住了自己的欲望，没有直接用一个月的零花钱来买一张CD；而且存起来的钱，无论是放到银行还是买理财产品，都可以让你享受到复利、也就是利滚利的好处。这点非常关键。<br>在这本书里，小狗钱钱给吉娅的建议是 5-4-1原则，就是说，除了最必要的日常开销，剩余的收入分成10份，其中五份用来投资，四份放在梦想储蓄罐里，一份当作奖励自己的零花钱。哪怕你每个月日常开销以后只剩100块，也可以按照5-4-1原则来分配</p><blockquote><p>这就是让你开始攒钱的三个步骤，制作梦想清单、梦想相册和梦想储蓄罐。一旦开始储蓄，你就迈出了财富积累的第一步</p></blockquote><br><p><em><strong>PS</strong>:如果一个人出现资产负债的话，又谈何财富积累呢？</em></p><h3 id="走出负债">走出负债</h3><ol><li>停掉手中所有的信用卡</li><li>在允许范围内，尽量按照较低的分期付款数目标准来支付</li><li>边攒钱边还消费贷款</li><li>那就是每次在付款之前，都再问自己一句“这真的有必要吗？”</li></ol><p><strong>小结</strong>：以上我们着重讲了财富积累的第一步，储蓄。想要获得财富，首先我们必须牢牢树立攒钱的意识。本书为我们介绍了开始攒钱的三个步骤，制作梦想清单、梦想相册和梦想储蓄罐。同时，针对有债务困扰的人，小狗钱钱也给了我们四点忠告，分别是：停掉所有信用卡、按照较低分期付款标准支付贷款、攒钱还款两不误，以及每次花钱之前，问问自己“这真的有必要吗”。<br><br></p><h2 id="怎么挣钱？">怎么挣钱？</h2><blockquote><p>小狗钱钱先告诉吉娅要攒下零花钱，但是零花钱只有那么一点，为了实现去美国当交换生的梦想，吉娅还要攒更多的钱才行，于是她开始琢磨怎么挣钱。<br>一个12岁的小女孩能做什么呢？吉娅自己也非常茫然。这和我们大部分人的情况很像，我们都想赚钱，但怎么赚呢？</p></blockquote><h3 id="赚钱法则">赚钱法则</h3><ol><li>你得为别人解决一个难题；</li><li>你要把精力集中在你知道的、能做的和拥有的事情上。<br><em><strong>PS</strong>:做自己擅长和喜欢的事情，这件事情要给别人带来价值。</em><br><br></li></ol><h3 id="写成功日记">写成功日记</h3><p>每天花10分钟，写下你这一天的五个成果。千万别被“成功”这两个字误导了，你所记录的这些事情，不一定非得多重要，任何芝麻蒜皮的小事都可以写进去。比如，吉娅在第一次写成功日记时写道：今天我学习了挣钱的知识，攒了5马克钱，还制作了梦想相册。<br><br><br></p><h2 id="怎么理财？">怎么理财？</h2><blockquote><p>什么是“会下金蛋的鹅”呢？书里说，从前有个农夫，他养了一只鹅。有一天，他在笼子里发现了一只金蛋，于是他把这只金蛋卖了，得到了很多钱。第二天笼子里又有了一个金蛋。这样的好运持续了好几天。可是贪得无厌的农夫依然不知足，他认为这只鹅下金蛋的速度太慢了。于是，一怒之下，他把鹅劈成了两半。就这样，他的鹅死了，再也没法下金蛋了。<br>在这个故事里，“鹅”代表本金，它下的“金蛋”代表利息，用本金获取利息，也就是用钱生钱。在这个过程里，这个金蛋也被叫做是“被动收入”。就是说，你不用付出任何劳动，就能自动获得的收入，比如，银行存款的利息，出租房子的租金、出书的版税、股票的分红等等。</p></blockquote><p><em><strong>PS</strong>:&quot;被动收入&quot;是实现财务自由的关键因素</em><br><br></p><h3 id="股票与基金">股票与基金</h3><p><strong>股票</strong>:大家对股票更熟悉一点，你买了这家公司的股票，就成了它的股东，每年可以享受分红。而且，你可以在证券市场上买进或是卖出股票。当然，作者说的欧美股票市场，和我们国家的股市，在规范程度和投资回报上都有所不同，借鉴意义有限，所以我们点到为止。<br><strong>基金</strong>:基金就像一口大锅，投资者可以把自己的钱投进这口锅里，然后由基金经理人，帮大家投资买股票。你只需要付给经理人一定的佣金就行。因为基金这口锅里，有多种不同股票，里面某只股票的涨跌已经被分散稀释，所以风险比股票小，当然收益也相对比较少。但是从长期来看，找到稳定上涨的基金，投资5-10年，它就相当于是零风险，而且你的收益将会非常可观。<br><br></p><h3 id="如何挑选基金">如何挑选基金</h3><ul><li>有10年以上历史的基金更值得购买。既然它在过去长期保持丰厚的利润，那么未来也是可以预期的。</li><li>选择大型的跨国股票基金。这种基金在全球范围内选取股票，风险比较低。</li><li>对比过去10年间，各种基金年终利润的走势图，选出最好的来投。<br><br></li></ul><h3 id="计算收益-72法则">计算收益(72法则)</h3><ul><li><strong>如何知道你投资的钱多长时间能翻一倍呢？</strong>:用 72除以一项投资的年收益率，得出的数字就是这笔钱翻一倍，所用的时间。比如，你买了一款年收益为6%的理财产品，用72除以6等于12，就是说，12年之后这笔钱就翻了一倍。</li><li><strong>一笔钱多长时间会贬值二分之一</strong>:同理，用72除以通货膨胀率，得出的数字就是这笔钱贬值到只剩一半的时间。比如，通货膨胀率是6%，那么72除以6就等于12，也就是说12年后，你的100块钱就只能买现在50块钱的东西了。对理财新手来说，72法则是一个简单好用的工具。<br><br></li></ul><h3 id="规避风险">规避风险</h3><ul><li><strong>不要把鸡蛋都放在同一个篮子里</strong>:把你手头的资金分配在不同的投资方式，而且这些投资方式的回报率之间关联性越低越好<br><br><br></li></ul><h2 id="总结"><strong>总结</strong></h2><ol><li>要牢牢树立储蓄的意识，有的理财书籍建议每个月拿出收入的50%作为储蓄，对很多人来说，这个很难做到。那不妨从10%开始，每月发了工资，立马分出10%作为储蓄，如果能按月坚持，你就迈出了财富积累的第一步。不管你目前是否负债，储蓄这件事最好都要开始做、坚持做。</li><li>要开源节流，就是要增加收入、控制消费。想要挣钱，就要为别人解决一个难题，这件事最好是你擅长的、喜欢的。有了收入，还要控制消费。因为消费通常会随着收入，水涨船高，人们甚至会超前消费，为了消费而去负债，比如，花信用卡、申请消费贷款等等。作者建议，量入为出，一定要避免不必要的消费</li><li>有了一定的储蓄，就达到了投资的门槛。投资就是要养一只会下金蛋的鹅。《小狗钱钱》建议吉娅设立一个金鹅账户，就是会下金蛋的鹅，可以按照5-4-1的原则，把每个月可支配收入的50%存入金鹅账户，用来投资，用钱生钱<br><br><br></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这本书的重点内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么攒钱？开始储蓄，迈出财富积累的第一步&lt;/li&gt;
&lt;li&gt;怎么挣钱？付出劳动，挣出第一桶金&lt;/li&gt;
&lt;li&gt;怎么用钱生钱？学会投资，养一只会下金蛋的鹅&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
      <category term="生活学习" scheme="https://hinzer.github.io/wiki/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="读书笔记" scheme="https://hinzer.github.io/wiki/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://hinzer.github.io/wiki/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>ctags基本用法</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/ctags/"/>
    <id>https://hinzer.github.io/wiki/技术开发/开发流程/ctags/</id>
    <published>2020-03-15T23:46:33.000Z</published>
    <updated>2020-03-17T17:10:50.248Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ctags是方便阅读源代码的工具。开发者在linux平台下和vim编辑器配合使用,这种策略经常被用于linux源码阅读。</p></blockquote><h2 id="开发环境">开发环境</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu18<span class="number">.04</span></span><br><span class="line"><span class="symbol">hinzer@</span>ubuntu:~$ uname -a</span><br><span class="line">Linux ubuntu <span class="number">5.3</span><span class="number">.0</span><span class="number">-40</span>-generic #<span class="number">32</span>~<span class="number">18.04</span><span class="number">.1</span>-Ubuntu SMP Mon Feb <span class="number">3</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">59</span> UTC <span class="number">2020</span> x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>关于2.6.11版本的kernel源码下载</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:source</span><span class="variable">$ </span>wget -O kernel <span class="symbol">https:</span>/<span class="regexp">/mirrors.edge.kernel.org/pub</span><span class="regexp">/linux/kernel</span><span class="regexp">/v2.6/linux</span><span class="number">-2.6</span>.<span class="number">11</span>.tar.gz</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:source</span><span class="variable">$ </span>tar -xzvf kernel.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装">安装</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install ctags -y</span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><ol><li>在当前目录下生成索引文件</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:source</span><span class="variable">$ </span>cd linux<span class="number">-2.6</span>.<span class="number">11</span>/</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:linux-</span><span class="number">2.6</span>.<span class="number">11</span><span class="variable">$ </span>ctags -R .<span class="comment">#生成索引tags</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>sudo vim /etc/vim/vimrc</code>配置vim</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>sudo vim ~<span class="regexp">/.vimrc #添加 set tags=/home</span><span class="regexp">/hinzer/source</span><span class="regexp">/linux-2.6.11/tags</span>;</span><br></pre></td></tr></table></figure><h2 id="使用演示">使用演示</h2><ol><li>命令行索引tag</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:linux-</span><span class="number">2.6</span>.<span class="number">11</span><span class="variable">$ </span>ctags -R .<span class="comment">#生成索引tags</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:linux-</span><span class="number">2.6</span>.<span class="number">11</span><span class="variable">$ </span>ll tags</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:linux-</span><span class="number">2.6</span>.<span class="number">11</span><span class="variable">$ </span>vim -t main  <span class="comment">#查找main函数</span></span><br></pre></td></tr></table></figure><ol start="2"><li>vim中使用ctags命令</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:ts</span>  <span class="comment">#tagslist,列出索引list</span></span><br><span class="line"><span class="symbol">:tp</span> <span class="comment">#tagspreview 上一个tag</span></span><br><span class="line"><span class="symbol">:tn</span> <span class="comment">#tagsnext 下一个tag</span></span><br><span class="line">Ctrl+ ] <span class="comment">#通过光标位置 跳转到定义处</span></span><br><span class="line">Ctrl+ T <span class="comment">#返回上一步的光标位置</span></span><br></pre></td></tr></table></figure><br><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://baike.baidu.com/item/ctags/3470337" rel="external nofollow noopener noreferrer" target="_blank">百度百科ctags</a></li><li><a href="www.kernel.org">linux kernel</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ctags是方便阅读源代码的工具。开发者在linux平台下和vim编辑器配合使用,这种策略经常被用于linux源码阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开发环境&quot;&gt;开发环境&lt;/h2&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="开发流程" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
    
      <category term="ctags" scheme="https://hinzer.github.io/wiki/tags/ctags/"/>
    
  </entry>
  
  <entry>
    <title>Welcome hinzer&#39;s Wiki Site</title>
    <link href="https://hinzer.github.io/wiki/index/"/>
    <id>https://hinzer.github.io/wiki/index/</id>
    <published>2020-03-14T17:55:57.000Z</published>
    <updated>2020-03-21T01:41:44.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于wiki">关于wiki</h2><p>知识是自己构建的，不是搬运来的。建立个人wiki的目的是将此作为一个知识整理的平台，虽然<a href="https://zh.wikipedia.org/wiki/Wiki" rel="external nofollow noopener noreferrer" target="_blank">维基百科</a>已经足够好了，但终究不是自己的，希望能建立自己的知识库(也可以理解为对已有知识的二次整理)。</p><p>万丈高楼平地起，起步阶段咱也不需要写的多好，随着理解的慢慢深入，自然能写出高水准的wiki。</p><p>这是一个基于<a href="https://hexo.io/zh-cn/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>框架的Wiki系统，Hexo是开源框架同时也支持很多主题，这里就采用了Wikitten的主题样式。然而我不关心这个，当然也不擅长这个(大佬们做好的轮子，拿来用就好了)。</p><h2 id="组织结构">组织结构</h2><p>先将wiki列表简单分几个大类</p><ol><li><p>技术开发<br>非核心技术，仅要求了解即可，方便以后随时查询。涉及面应该广一些，包括但不仅限于: 工程规范、开发工具、源码管理、测试方法。</p></li><li><p>计算机基础<br>核心技术，需要长期学习和理解的领域，掌握程度高一些。并不奢求一次就能写的多好，要求有更深的理解了，回来补充和修正。至少包括: 开发平台、常用算法、数据结构。</p></li><li><p>生活学习<br>其他方向归于这个分类</p></li></ol><h2 id="部署指南">部署指南</h2><p><a href="https://hexo.io/zh-cn/docs/" rel="external nofollow noopener noreferrer" target="_blank">Hexo 官方文档</a><br><a href="https://github.com/zthxxx/Wiki-site" rel="external nofollow noopener noreferrer" target="_blank">zthxxx wiki源码</a><br><a href="https://wikitten.vizuina.com/" rel="external nofollow noopener noreferrer" target="_blank">Wikitten 主题地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于wiki&quot;&gt;关于wiki&lt;/h2&gt;
&lt;p&gt;知识是自己构建的，不是搬运来的。建立个人wiki的目的是将此作为一个知识整理的平台，虽然&lt;a href=&quot;https://zh.wikipedia.org/wiki/Wiki&quot; rel=&quot;external nofoll
      
    
    </summary>
    
    
      <category term="wiki" scheme="https://hinzer.github.io/wiki/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>年度总结</title>
    <link href="https://hinzer.github.io/wiki/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://hinzer.github.io/wiki/生活学习/随笔记录/年度总结/</id>
    <published>2019-12-31T15:59:19.000Z</published>
    <updated>2020-03-16T23:21:23.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019年又要到底了，有必要写一个总结，看看过去的一年时间了干了些什么。。另，不知怎么，发现最近变得有些懒散，希望能重拾写作这个习惯。不管怎样，这不是一篇对自我批判或者激励自我的文章，总结记录，仅此而已。</p></blockquote><p>今年跨年在看罗胖演讲时间的朋友，最多听到的是<code>网络</code>、<code>连接</code>、<code>点亮</code>这些字眼，无论是个人、行业、国家，都在积极地对外输出自己的价值(连接)，塑造自己的品牌影响力(网络)。今后是网络化的时代。<br>对于我而言，如何和别人建立好的<code>连接</code>，结出自己的<code>网络</code>，可能需要想搞清楚几个问题：</p><ul><li>我是谁？</li><li>我干啥？</li><li>我为谁干？</li><li>别人需要我么？</li><li>社会更好了么？<br>这些问题我想留给下年，下一个年终总结。</li></ul><h2 id="过去的2019">过去的2019</h2><p>过去一年里发生了很多&quot;第一次&quot;，第一次去了杭州合肥这些城市、第一次写年终总结、第一次找工作的过程，经历了社招和校招，也体验过电话面试、现场面试和网络面试，如今第一次实习。</p><p><strong>求职</strong><br>这一年，我最大的期望就是找一份好的工作。在这个过程中，我发现有很多优秀的人、优秀的平台，通过他们的故事和分享，收获了很多实用的建议。</p><ul><li>经过2018年，我已经把之前报的嵌入式的课程学的差不多了，随后又补习了Python，3月份左右去考试拿了一个二级证书。</li><li>有了找实习的意识，也经历过很多面试。最后有拿到几个实习offer，最后学校没给批，自己也没过于坚持，就没去成。</li><li>通过博客认识了几个有意思的小伙伴，有职场人，也有在校同学，收获了很多有用的建议</li><li>开始关注牛客网，后来认识了谱哥。这时大三也快结束了，后来找工作的打法也是从谱哥那里学习的。现在已签的offer也是在牛客上找的。</li><li>好朋友强哥参加比赛，晋级北京总决赛，团队人员替换，我跟着强哥去北京待了一周，确实是长见识了。</li><li>暑假留校学习，完善自己的技术栈。刷剑指offer、网上找内推、投简历，这样坚持一个月。可能感到这样闷头学习没有意思，想出去面试一下，想着以后也要在家乡发展，我订一张火车票就回安徽。在合肥、杭州这些地方转悠一圈，面了十多家公司，有大有小，大多给了offer。这是我今年最正确的决定，后来的面试也有了一定的底气。</li><li>开学回到学校，这时发现我是班中唯一一个拿到offer的人，心中一阵窃喜。。后来参加一次网络面试，也就是我现在这家。再后来秋招正式开始也都没怎么参加。</li><li>拿到满意offer后，报名了驾考，过了科目一和科目二。</li></ul><p><strong>生活</strong><br>其实在大多时间还是宅在屋里，时间久了，养成一个孤僻的性格，现在多多少少有些抵触与外界的接触。</p><ul><li>这一年记录了77篇博客，大多是技术相关的，生活记录有些少了。</li><li>办了一张半年的健身卡，坚持每周4天，30min左右活动时间。每次健身之后可以获得身心愉悦，确实不错。</li><li>寒假和暑假的时间挺长，真正在家里没过多久。感觉在家里闲不住，想着以后就没有寒暑假了，应该多陪陪家人。</li><li>大学里的同学，同一专业的还认识一些。高中同学现在还能常保持联系的也就两个。很多以前关系还不错的朋友，不怎么联络，关系也就慢慢疏远了。</li><li>来到东北之后也很少出去走走，对校园之外的世界接触太少。貌似从大三之后就比较宅了，现在实习了。</li></ul><h2 id="对现状的思考">对现状的思考</h2><p>大四学生，目前在北京实习，内容是android系统适配，实习还算轻松，但职场上不能很好的适应，仍感到些许压力。</p><p><strong>入职</strong><br>第一次走出校门，进入职场。那天正好是双11，有一个多月了。现在对工作上需要哪些技术，基本上有一个了解。当然还有诸多问题，对自己定位不清晰、目前还没有一个明确的职业规划、所在岗位注重哪些能力，如何针对性的培养等等</p><p><strong>性格</strong><br>或许是出于小时候的成长环境的原因，养成了一个内向的性格。后来，进入大学后，也或许是内向的性格让我选择了学习技术(也可能因为兴趣，但那是之后的事情了),渐渐不与人交流，越来越不善表达了。我始终觉得自己和那些在大学里整天待在宿舍打游戏为了逃避学业，或者整天考研为了逃避就业没什么两样，多少有点逃避的意思。<br>幸运的是我在学习技术的过程中，有段时间真的体验到了乐趣；不幸的是，社交与沟通能力成为了我最大的短板，比较头疼。<br>求职找工作那段时间，我感觉比较&quot;充实&quot;,因为当时体会到以前学过的那些知识、技能给我带来的价值。后来进入职场，暴露出自己的社交能力的短板，确实比较难受。</p><p><strong>反省</strong><br>人的本性是在成功时寻找内因，失败了寻找外因。特别是在没有什么可以值得炫耀的时候，总是拒绝面对现实，拒绝反省自己。<br>其实经历的每一件事都是一次成长的机会，通过总结记录的方式，反思和审视自己。<br>我是一个&quot;懒人&quot;，平时很少思考，更不愿意去主动总结。大概原因归纳如下：</p><ol><li>对事情的理解往往只流于表面，没有深入的理解，也常常感到没有什么值得去写的东西</li><li>每次写作的过程中，往往&quot;咬文爵字&quot;，浪费很长时间，会感觉投入产出不成正比</li><li>总想利用大块时间一次性写完，但往往没有这种时间，要么贪玩，或者去做别的事情了</li></ol><p>针对上面问题的反省，我需要：</p><ol><li>最重要的一点，不要搞错总结的目的。总结是给自己看的，每次总结都能提炼出一些有用的东西，这就是总结的价值。</li><li>相信持续写下去，文字表述能力自然会提高上去。</li><li>养成提问和记录的习惯之后，随时记录考虑的问题，形成主题列表。确定要写的主题，先立大纲，拆分每个部分到碎片时间去实现，利用周末时间拼接起来。</li></ol><h2 id="即将到来的2020">即将到来的2020</h2><p>期望未来自己，可以协调好学习、工作、生活三者，让生活更加充实。</p><p><strong>期望改掉的毛病</strong></p><ul><li>[ ] 熬夜</li><li>[ ] 懒</li><li>[ ] 不善于表达，通常显得冷静而无情</li></ul><p><strong>期望养成的习惯</strong></p><ul><li>[ ] 早睡早起</li><li>[ ] 多进行思考总结，主要方式是记录，经常写日志进行日常总结、写博客进行工作总结</li><li>[ ] 必须直接地表达出对他人的欣赏，而不是仅仅保留在内心</li><li>[ ] 主动去联系老朋友，至少一个月联系一次嘛</li></ul><p><strong>期望达成的目标</strong></p><ul><li>[ ] 作息时间 5:10(早)~11:30(晚)</li><li>[ ] 持续写博客 每周至少产出一篇</li><li>[ ] 开始接触金融学 投资、理财、保险…</li><li>[ ] 多读一些心理学的书，多了解自己</li><li>[ ] 坚持健身(久坐生病，需要适当运动)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2019年又要到底了，有必要写一个总结，看看过去的一年时间了干了些什么。。另，不知怎么，发现最近变得有些懒散，希望能重拾写作这个习惯。不管怎样，这不是一篇对自我批判或者激励自我的文章，总结记录，仅此而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="生活学习" scheme="https://hinzer.github.io/wiki/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="随笔记录" scheme="https://hinzer.github.io/wiki/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="2019" scheme="https://hinzer.github.io/wiki/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>github搜索开源项目</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/github%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/github搜索开源项目/</id>
    <published>2019-12-29T11:40:58.000Z</published>
    <updated>2020-03-21T01:48:37.905Z</updated>
    
    <content type="html"><![CDATA[<p>1、<strong>从名字中搜关键词</strong><br>in:name example</p><p>2、<strong>搜索readme文件</strong><br>in:readme example</p><p>3、<strong>描述中搜索关键词</strong><br>in:description example</p><p>4、<strong>追加限定条件</strong><br>stars:&gt;3000  # 限定在stars数量大于3000的项目<br>fork:&gt;50# fork 数量<br>pushed:&gt;2019-09-10# 最后一次push的时间<br>language:java   # 限定语言</p><br><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://help.github.com/cn/github/searching-for-information-on-github" rel="external nofollow noopener noreferrer" target="_blank">github官方文档-搜索</a></li><li><a href="https://www.bilibili.com/video/av75587104" rel="external nofollow noopener noreferrer" target="_blank">如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、&lt;strong&gt;从名字中搜关键词&lt;/strong&gt;&lt;br&gt;
in:name example&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;搜索readme文件&lt;/strong&gt;&lt;br&gt;
in:readme example&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;描述中搜索关键词&lt;/str
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="github" scheme="https://hinzer.github.io/wiki/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>问问题的姿势</title>
    <link href="https://hinzer.github.io/wiki/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%96%B9%E6%B3%95%E4%B9%A0%E6%83%AF/2020-03-21-How-To-Ask-Questions-The-Smart-Way/"/>
    <id>https://hinzer.github.io/wiki/生活学习/方法习惯/2020-03-21-How-To-Ask-Questions-The-Smart-Way/</id>
    <published>2019-12-10T01:10:12.000Z</published>
    <updated>2020-03-21T01:38:13.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问问题，如何问">问问题，如何问</h2><p><strong>错误问法</strong>：<br>- 某某出错了，怎么办？ —&gt;太模糊<br>- 如何针对某某封装一个库？  —&gt;太庞大</p><p><strong>正确问法</strong>：<br>- 目的 + 就此目的提出的手段 + 走到这一步的障碍 (解答题)<br>- 提供选项 + 展现探索了哪些路径 (选择题)<br>- 付出态度，表达感谢 + 提供一份可供交换的视角 (交换价值)</p><p><strong>原则</strong>：<br>- 提供足够多的信息，让人能够回答<br>- 提供足够多的选项，让人方便回答<br>- 提供交换价值，建立讨论基础;表达感谢态度，让人乐于回答</p><br><h2 id="记录问题，定期回顾">记录问题，定期回顾</h2><ol><li>问题上下文</li><li>问题具体描述</li><li>问题的解决思考和思路</li><li>问题的解决方案和具体技术或办法</li><li>问题解决后留下的思考或其他延伸的疑问</li></ol><blockquote><p>这就是积累价值和传递价值的方式，定期记录与回顾，终有所获！</p></blockquote><br><h2 id="问问题，为何问">问问题，为何问</h2><p>…</p><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://github.com/FredWe/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md" rel="external nofollow noopener noreferrer" target="_blank">《提问的智慧》</a></li><li><a href="https://time.geekbang.org/column/intro/100012101" rel="external nofollow noopener noreferrer" target="_blank">《程序员进阶攻略》</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问问题，如何问&quot;&gt;问问题，如何问&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;错误问法&lt;/strong&gt;：&lt;br&gt;
- 某某出错了，怎么办？ —&amp;gt;太模糊&lt;br&gt;
- 如何针对某某封装一个库？  —&amp;gt;太庞大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确问法&lt;/strong&gt;：
      
    
    </summary>
    
      <category term="生活学习" scheme="https://hinzer.github.io/wiki/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="方法习惯" scheme="https://hinzer.github.io/wiki/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%96%B9%E6%B3%95%E4%B9%A0%E6%83%AF/"/>
    
    
      <category term="方法" scheme="https://hinzer.github.io/wiki/tags/%E6%96%B9%E6%B3%95/"/>
    
      <category term="问题" scheme="https://hinzer.github.io/wiki/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「转」详谈typedef的用法</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/typedef%E7%90%86%E8%A7%A3/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/编程语言/typedef理解/</id>
    <published>2019-10-09T23:42:21.000Z</published>
    <updated>2020-03-17T15:13:32.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们都知道typedef是类型重定义，既然是重定义就不可能出现新的数据类型，只是将已有的数据类型进行换个名字而已，但是这有什么用呢？</p></blockquote><br><p>可能我们学的时候，给的例子都是：typedef int INT; 然后再用INT去定义一些变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT;</span><br><span class="line">INT a;</span><br></pre></td></tr></table></figure><p>这个就等于int a; 我们当时感觉不出来有什么用，当学到结构体的时候，可能觉得会减少数据类型的写法，像<code>struct student</code>这样一个结构体定义变量的时候如果不用typedef就只能<code>struct student</code>(当然这是在C语言中，在C++中可以省略掉struct直接写student)，这样感觉很麻烦，所以才想到用typedef，但是这是他的用法之一，却不是为唯一的用法。</p><p><br><br><br>typedef的用法主要我总结了一下三点：</p><h2 id="用法一">用法一</h2><p><code>可以减少代码的书写量</code>,就像我们经常能考虑到的，结构体这样“新的”数据类型，用typedef可以简化，而且不容易出错.例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们定义学生结构体的时候要这么定义<code>struct student s1,s2,s3; </code>如果想定义结构体指针，我们可以这么定义,<code>struct student *ps1, ps2; </code>显然ps2不是指针类型，但是好多初学者对指针不熟悉，所以容易出错，但是当我们用typedef的时候，就不会出现这样的错误了，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125;stu, *pstu;</span><br></pre></td></tr></table></figure><p>我们定义的时候可以这么定义<code>stu s1, s2, s3;</code> 定义结构体指针的时候，可以这么定义,<code>pstu ps1, ps2;</code> 这样ps1， ps2都是指针类型的变量 这是typedef的用法之一，也是比较常用的。<br><br></p><h2 id="用法二">用法二</h2><p><code>实现代码的复用性和可扩展性</code>,如果一段代码没有扩展性和复用性，那么这段代码就不能算得上是一段特别规范的代码，就像我们为了实现代码的复用性，提高程序可读性的时候，用函数一样，提高代码的复用性和可扩展性是作为软件开发者必备的本领。一段好的代码，如果在别的项目中引用的话，如果功能类似，基本上改不了几行，这就是规范性的重要性(这里先不谈规范性，但是这个typedef的用法也涉及规范性，嘿嘿，所以规范是避免不了的)。就这么来说吧，假如我们定义了一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们想把成绩改成double类型的，应为int的精度太低了，但是下面用到的地方可能都要改掉，但是，我们要是用typedef一下， 问题就变得简单多了，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> typeitem；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"></span><br><span class="line">　　typeitem score;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样直接改typedef就行了，其他的代码根本不用动，这就是<code>分层</code>的原因，我们只改变最底层的，上层的东西根本不用变（就像在链表中，我们可以把它分为三层，纯数据层、节点层、head指针层，也就是整条链)这样分层处理问题会变得简单得多。还有就是平台不同可以兼容，就像有的平台不支持long double类型，但是你如果定义了long double 直接不能用，但是如果这么  typedef long double typeitem； 直接改成可以支持的类型就行啦，根本不用那么麻烦改下面的代码，这也是比较重要的用途。</p><h2 id="用法三">用法三</h2><p><em><code>简化，提高可读性</code>。想必大家觉得，这个用途不是包含在上面的用途之中了吗，为什么还要再说一遍呢，其实我举个例子你也就明白了，<code>typedef int array[10];</code>，这个代表什么意思，这可不是平时那种array[10]是个int了吧，这个代表，array是个重定义的类型，<code>array a；</code>就代表a是一个含有10个int型元素的数组，这么定义可能觉得简化不了多少，还不如直接int a[10];<br>看着明白呢，好! 继续往下看,<code>typedef array Array[5];</code> 这个呢，如果我这么定义一个变量 <code>Array arr[2]; </code>这个又是什么意思呢？这个就是定义个Array类型数组，其中这个“一维”数组有两个元素，但是每个元素又都是Array 类型的，每个Array又是一个5行10列二维数组，所以arr就是一个三维数组，他就等于<code>int arr[2][5][10];</code> 是不是看的有点蒙了， 其实在C语言中根本不存在多维数组，全部都是一维数组，只是一维数组里面又含一维数组，所以才构成了所谓的“多维”数组， 如果这样理解的话，是不是觉得多维数组也就不那么“神奇”了，变得简单了，没有那么晕了，这样定义的好处就是可以讲一个多维的数组转化成我们比较熟悉的一维数组，这样操作起来就比较容易了，可读性自然也会增强。所以这就是他的“简化”的作用。<br>其实我们还可以在函数指针上体现，想定义个函数指针<code>int (*p)();</code> 我们可以定义为<code>typedef int (*POWER)();</code> 接下来可以直接定义<code>POWER p1, p2; </code>他就等价于<code>int (*p1)(), int (*p2)(); </code>这样也非常易懂。</em><br><br></p><h2 id="定义方法">定义方法</h2><p>下面来谈一下他的定义过程，说了这么多，还没讲到怎么定义，其实也就三步:</p><ul><li><strong>第一步:</strong> 按照定义变量的方法先写出定义体(想必这么都比较熟悉吧), 例如: int a;</li><li><strong>第二步:</strong> 将变量名换成想要重定义的名字 例如: int INT;</li><li><strong>第三步:</strong> 在最前面加上typedef 例如: typedef int INT;<br>整个步骤就完成了，下面就可以用重定义的类型定义变量了:例如: INT a; 就是这么简单，不要想那么复杂。<br><br></li></ul><h2 id="与宏定义">与宏定义</h2><p>还有就是与宏定义区分开来，宏定义是在编译预处理的时候直接进行的替换，而typedef却不是，宏定义特别是写那个表达式的时候新手容易出错就是不能真正理解宏替换，就像这么例子: #define mul(a, b) a * b ，如果这么写mul(2, 3)那么恭喜，你对了， 但是如果这么写， mul(2 + 1, 3 + 4); 你的出来的结果一定是错的，它只是简单地替换， 不会像函数那样会先计算出来2 + 1 等于 3 然后在进行计算， 它只能替换为2 + 1 * 3 + 4 所以结果当然错了……新手注意点就好了，这东西挺简单的。<br><br></p><p>大致就将这么多，如果那里写的不好，多多指教，多多补充！</p><br><p>转载于：<a href="https://www.cnblogs.com/Howe-Young/p/3931678.html" rel="external nofollow noopener noreferrer" target="_blank">Howe_Young</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们都知道typedef是类型重定义，既然是重定义就不可能出现新的数据类型，只是将已有的数据类型进行换个名字而已，但是这有什么用呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
&lt;p&gt;可能我们学的时候，给的例子都是：typedef int INT
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="编程语言" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="typedef" scheme="https://hinzer.github.io/wiki/tags/typedef/"/>
    
      <category term="C" scheme="https://hinzer.github.io/wiki/tags/C/"/>
    
  </entry>
  
</feed>
