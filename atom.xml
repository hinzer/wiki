<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hinzer&#39;s Wiki</title>
  
  <subtitle>先打基础</subtitle>
  <link href="/wiki/atom.xml" rel="self"/>
  
  <link href="https://hinzer.github.io/wiki/"/>
  <updated>2020-03-28T00:31:38.000Z</updated>
  <id>https://hinzer.github.io/wiki/</id>
  
  <author>
    <name>hinzer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bugreport</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/bugreport/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/bugreport/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-28T00:31:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>原生android系统支持<code>adb bugreport</code>命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误</p><p>1、目录结构</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">mi@</span>ubuntu:bugreport$ tree -L <span class="number">1</span></span><br><span class="line">.</span><br><span class="line">├── bugreport-dipper_ru-QKQ1<span class="number">.190828</span><span class="number">.002</span><span class="number">-2020</span><span class="number">-03</span><span class="number">-26</span><span class="number">-16</span><span class="number">-15</span><span class="number">-04.</span>txt  #最重要的文件</span><br><span class="line">├── dumpstate_board.txt</span><br><span class="line">├── dumpstate_log.txt</span><br><span class="line">├── FS</span><br><span class="line">├── lshal-debug</span><br><span class="line">├── main_entry.txt</span><br><span class="line">├── outfile.log</span><br><span class="line">├── proto</span><br><span class="line">└── version.txt</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">6</span> files</span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><p>1、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#anrs-deadlocks" rel="external nofollow noopener noreferrer" target="_blank">ANR和死锁</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出无响应的应用(系统会终止该进程并将堆栈转储到 /data/anr)</span></span><br><span class="line">grep <span class="string">"am_anr"</span> bugreport-2015-10-01-18-13-48.txt  # 为二进制事件日志中的 am_anr 执行 grep 命令</span><br><span class="line">grep <span class="string">"ANR in"</span> bugreport-2015-10-01-18-13-48.txt  # 为 logcat 日志（其中包含关于发生 ANR 时是什么在占用 CPU 的更多信息）中的 ANR <span class="keyword">in</span> 执行 grep 命令</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找堆栈跟踪( ANR 对应的堆栈跟踪 --&gt; 进程主线程)</span></span><br><span class="line">------ VM TRACES AT LAST ANR</span><br><span class="line">------ TRACES JUST NOW 和 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找死锁(系统服务器发生死锁，监控程序最终会将其终止)</span></span><br><span class="line">WATCHDOG KILLING<span class="built_in"> SYSTEM </span>PROCESS</span><br></pre></td></tr></table></figure><p>2、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#activities" rel="external nofollow noopener noreferrer" target="_blank">Activity</a></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看聚焦状态的activity(崩溃期间处于聚焦状态的 Activity 表示当前用户操作)</span><br><span class="line">grep <span class="string">"am_focused_activity"</span> bugreport<span class="number">-2015</span><span class="number">-10</span><span class="number">-01</span><span class="number">-18</span><span class="number">-13</span><span class="number">-48.</span>txt</span><br><span class="line"></span><br><span class="line"># 查看进程启动事件</span><br><span class="line">grep <span class="string">"Start proc"</span> bugreport<span class="number">-2015</span><span class="number">-10</span><span class="number">-01</span><span class="number">-18</span><span class="number">-13</span><span class="number">-48.</span>txt</span><br><span class="line"></span><br><span class="line"># 设备是否发生系统颠簸</span><br><span class="line">grep -e <span class="string">"am_proc_died"</span> -e <span class="string">"am_proc_start"</span> bugreport<span class="number">-2015</span><span class="number">-10</span><span class="number">-01</span><span class="number">-18</span><span class="number">-13</span><span class="number">-48.</span>txt</span><br></pre></td></tr></table></figure><p>3、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#memory" rel="external nofollow noopener noreferrer" target="_blank">内存</a><br>4、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#broadcasts" rel="external nofollow noopener noreferrer" target="_blank">广播</a><br>5、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#monitor%20contention" rel="external nofollow noopener noreferrer" target="_blank">显示器争用</a><br>6、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#background-compilation" rel="external nofollow noopener noreferrer" target="_blank">后台编译</a><br>7、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#narrative" rel="external nofollow noopener noreferrer" target="_blank">叙述</a><br>8、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#power" rel="external nofollow noopener noreferrer" target="_blank">电源</a><br>9、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#packages" rel="external nofollow noopener noreferrer" target="_blank">程序包</a><br>10、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#processes" rel="external nofollow noopener noreferrer" target="_blank">进程</a><br>11、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#scans" rel="external nofollow noopener noreferrer" target="_blank">扫描</a></p><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://developer.android.com/studio/debug/bug-report" rel="external nofollow noopener noreferrer" target="_blank">获取并阅读错误报告</a></li><li><a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">阅读错误报告</a></li><li><a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=181967386" rel="external nofollow noopener noreferrer" target="_blank">Android Log机制、Logcat及MIUI 284日志介绍</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;原生android系统支持&lt;code&gt;adb bugreport&lt;/code&gt;命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误&lt;/p&gt;
&lt;p&gt;1、目录结构&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Log" scheme="https://hinzer.github.io/wiki/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>理解测试用例</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/如何编写一个好的测试用例/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-28T00:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试用例设计过程">测试用例设计过程</h3><p>以“用户登录”功能的测试用例设计为例，画了一张图来帮你理清这些概念之间的映射关系。图中的业务需求到软件功能需求、软件功能需求到测试需求，以及测试需求到测试用例的映射关系，<br><img src="https://static001.geekbang.org/resource/image/f1/f7/f1adcc92da9091037ccc022f29911ef7.png" alt="测试用例设计过程"></p><h3 id="什么才算是“好的”测试用例？">什么才算是“好的”测试用例？</h3><p>测试用例的好坏与被测试对象的测试结果无关，好的测试用例必须具备</p><ul><li><code>整体完备性</code>： “好的”测试用例一定是一个完备的整体，是有效测试用例组成的集合，能够完全覆盖测试需求。</li><li><code>等价类划分的准确性</code>： 指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。</li><li><code>等价类集合的完备性</code>： 需要保证所有可能的边界值和边界条件都已经正确识别。</li></ul><h3 id="三种最常用的测试用例设计方法">三种最常用的测试用例设计方法</h3><p>1、等价类划分方法<br>我们只要从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖结果。<br>一个具体的例子</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生信息系统中有一个“考试成绩”的输入项，成绩的取值范围是 <span class="number">0</span>~<span class="number">100</span> 之间的整数，考试成绩及格的分数线是 <span class="number">60</span>。</span><br></pre></td></tr></table></figure><p>最终测试用例为</p><ul><li>有效等价类 1：0~59 之间的任意整数；</li><li>有效等价类 2：59~100 之间的任意整数；</li><li>无效等价类 1：小于 0 的负数；</li><li>无效等价类 2：大于 100 的整数；</li><li>无效等价类 3：0~100 之间的任何浮点数；</li><li>无效等价类 4：其他任意非数字字符。</li></ul><p>2、边界值分析方法<br>边界值分析是对等价类划分的补充，你从工程实践经验中可以发现，大量的错误发生在输入输出的边界值上，所以需要对边界值进行重点测试，通常选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。<br>我们继续看学生信息系统中“考试成绩”的例子，选取的边界值数据应该包括：<br><code>-1，0，1，59，60，61，99，100，101</code>。</p><p>3、错误推测方法<br>错误推测方法是指基于对被测试软件系统设计的理解、过往经验以及个人直觉，推测出软件可能存在的缺陷，从而有针对性地设计测试用例的方法。这个方法强调的是对被测试软件的需求理解以及设计实现的细节把握，当然还有个人的能力。</p><h3 id="如何才能设计出“好的”测试用例？">如何才能设计出“好的”测试用例？</h3><p><a href="(https://time.geekbang.org/column/article/10150)">查看原文</a></p><h3 id="总结">总结</h3><p>首先，理解测试用例是一个完备的集合，好的测试用例从原始业务需求出发进行分析设计。其次，理解三种常用的测试用例设计方法<code>等价类划分方法</code>、<code>边界值分析方法</code>、<code>边界值分析方法</code></p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/10150" rel="external nofollow noopener noreferrer" target="_blank">如何设计一个“好的”测试用例？</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;测试用例设计过程&quot;&gt;测试用例设计过程&lt;/h3&gt;
&lt;p&gt;以“用户登录”功能的测试用例设计为例，画了一张图来帮你理清这些概念之间的映射关系。图中的业务需求到软件功能需求、软件功能需求到测试需求，以及测试需求到测试用例的映射关系，&lt;br&gt;
&lt;img src=&quot;https
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="代码测试" scheme="https://hinzer.github.io/wiki/tags/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    
      <category term="笔记" scheme="https://hinzer.github.io/wiki/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>bugreport</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/logcat/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/logcat/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-28T00:31:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>logcat是抓log的工具，从android logging系统抓取日志。</p><p>1、logcat相关目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码位置：`<span class="regexp">/system/</span>core<span class="regexp">/logcat/</span>`</span><br><span class="line">编译生成的可执行文件位于：`out<span class="regexp">/target/</span>product<span class="regexp">/umi/</span>system<span class="regexp">/bin/</span>logcat`(umi是产品名)</span><br><span class="line">对应到设备端的可执行文件：`<span class="regexp">/system/</span>bin<span class="regexp">/logcat`</span></span><br></pre></td></tr></table></figure><p>2、日志缓冲区</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">radio：查看包含无线装置/电话相关消息的缓冲区。</span><br><span class="line">events：查看已经过解译的二进制系统事件缓冲区消息。</span><br><span class="line">main：查看主日志缓冲区（默认），不包含系统和崩溃日志消息。</span><br><span class="line"><span class="keyword">system</span>：查看系统日志缓冲区（默认）。</span><br><span class="line">crash：查看崩溃日志缓冲区（默认）。</span><br><span class="line"><span class="keyword">all</span>：查看所有缓冲区。</span><br><span class="line"><span class="keyword">default</span>：报告 main、<span class="keyword">system</span> 和 crash 缓冲区。</span><br></pre></td></tr></table></figure><h3 id="使用规范">使用规范</h3><p>1、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#filteringOutput" rel="external nofollow noopener noreferrer" target="_blank">过滤日志输出</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">tag</span><span class="selector-pseudo">:priority</span>  标记:优先级</span><br><span class="line"><span class="selector-tag">adb</span> <span class="selector-tag">logcat</span> <span class="selector-tag">ActivityManager</span><span class="selector-pseudo">:I</span> <span class="selector-tag">MyApp</span><span class="selector-pseudo">:D</span> *<span class="selector-pseudo">:S</span></span><br></pre></td></tr></table></figure><p>2、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#outputFormat" rel="external nofollow noopener noreferrer" target="_blank">控制日志输出格式</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v &lt;format&gt;</span></span><br><span class="line"><span class="attribute">adb</span> logcat -v thread</span><br></pre></td></tr></table></figure><p>3、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#alternativeBuffers" rel="external nofollow noopener noreferrer" target="_blank">查看备用日志缓冲区</a></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -<span class="keyword">b </span>&lt;<span class="keyword">buffer&gt;</span></span><br><span class="line"><span class="keyword">db </span>logcat -<span class="keyword">b </span>radio</span><br></pre></td></tr></table></figure><h3 id="命令速查">命令速查</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取help</span></span><br><span class="line">$ adb shell logcat --help</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查log</span></span><br><span class="line">$ adb shell logcat -b<span class="built_in"> system </span>&gt; logSystem.txt  #查询此时system的日志，并且保存在logSystem.txt的文件中</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">Logcat 命令行工具</a></li><li><a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=181967386" rel="external nofollow noopener noreferrer" target="_blank">Android Log机制、Logcat及MIUI 284日志介绍</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;logcat是抓log的工具，从android logging系统抓取日志。&lt;/p&gt;
&lt;p&gt;1、logcat相关目录&lt;/p&gt;
&lt;figure class=&quot;highlight awk&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Log" scheme="https://hinzer.github.io/wiki/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>理解单元测试</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E7%90%86%E8%A7%A3%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/理解单元测试/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-28T00:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解概念">理解概念</h3><p>1、单元测试的概念理解</p><blockquote><p>单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类。</p></blockquote><p>一个工厂生产电视机的例子。如果把电视机的生产、测试和软件的开发、测试进行类比，你可以发现：</p><ul><li>电子元器件就像是软件中的单元，通常是函数或者类，对单个元器件的测试就像是软件测试中的<code>单元测试</code>；</li><li>组装完成的功能电路板就像是软件中的模块，对电路板的测试就像是软件中的<code>集成测试</code>；</li><li>电视机全部组装完成就像是软件完成了预发布版本，电视机全部组装完成后的开机测试就像是软件中的<code>系统测试</code>。</li></ul><p>2、单元测试对开发的好处</p><ol><li>单元测试属于最严格的软件测试手段，是最接近代码底层实现的验证手段，可以在软件开发的早期以最小的成本保证局部代码的质量。</li><li>单元测试都是以自动化的方式执行，所以在大量回归测试的场景下更能带来高收益。</li><li>单元测试的实施过程还可以帮助开发工程师改善代码的设计与实现，并能在单元测试代码里提供函数的使用示例，因为单元测试的具体表现形式就是对函数以各种不同输入参数组合进行调用，这些调用方法构成了函数的使用说明。</li></ol><h3 id="掌握方法">掌握方法</h3><blockquote><p>如何做好单元测试?你首先必须弄清楚单元测试的对象是代码，以及代码的基本特征和产生错误的原因，然后你必须掌握单元测试的基本方法和主要技术手段。<br>1、代码基本特征与产生错误的原因</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无论是开发语言还是脚本语言，都会有条件分支、循环处理和函数调用等最基本的逻辑控制，如果抛开代码需要实现的具体业务逻辑，仅看代码结构的话，你会发现所有的代码都是在对数据进行分类处理，每一次条件判定都是一次分类处理，嵌套的条件判定或者循环执行，也是在做分类处理。</span><br></pre></td></tr></table></figure><p>可见，要做到代码功能逻辑正确，必须做到分类正确并且完备无遗漏，同时每个分类的处理逻辑必须正确。而在开发实践的过程中，通常考虑从以下方面考虑</p><ul><li>如果要实现正确的功能逻辑，会有哪几种<code>正常的输入</code>；</li><li>是否有需要特殊处理的多种<code>边界输入</code>；</li><li>各种潜在<code>非法输入</code>的可能性以及如何处理。</li></ul><p>2、测试用例<br>单元测试的用例是一个<code>输入数据</code>和<code>预计输出</code>的集合。<br><strong>完整的输入数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">被测试函数的输入参数；</span><br><span class="line">被测试函数内部需要读取的全局静态变量；</span><br><span class="line">被测试函数内部需要读取的成员变量；</span><br><span class="line">函数内部调用子函数获得的数据；</span><br><span class="line">函数内部调用子函数改写的数据；</span><br><span class="line">嵌入式系统中，在中断调用时改写的数据</span><br></pre></td></tr></table></figure><p><strong>明确的预计输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">被测试函数的返回值；</span><br><span class="line">被测试函数的输出参数；</span><br><span class="line">被测试函数所改写的成员变量；</span><br><span class="line">被测试函数所改写的全局变量；</span><br><span class="line">被测试函数中进行的文件更新；</span><br><span class="line">被测试函数中进行的数据库更新；</span><br><span class="line">被测试函数中进行的消息队列更新；</span><br></pre></td></tr></table></figure><p>3、<code>驱动代码</code>，<code>桩代码</code>和<code>Mock代码</code><br><code>驱动代码</code>，<code>桩代码</code>和<code>Mock代码</code>，是单元测试中最常出现的三个名词<br><img src="https://static001.geekbang.org/resource/image/4b/2f/4b593086d9370bea9afc2d12219a0c2f.png" alt></p><ul><li><code>驱动代码</code>，指调用被测函数的代码，单元测试过程中，驱动模块通常包括调用被测函数前的数据准备、调用被测函数以及验证相关结果三个步骤。驱动代码的结构，通常由单元测试的框架决定。</li><li><code>桩代码</code>，是用来代替真实代码的临时代码。 比如，某个函数 A 的内部实现中调用了一个尚未实现的函数 B，为了对函数 A 的逻辑进行测试，那么就需要模拟一个函数 B，这个模拟的函数 B 的实现就是所谓的桩代码。</li><li><code>Mock</code>，Mock 代码和桩代码非常类似，都是用来代替真实代码的临时代码，起到隔离和补齐的作用。在使用 Mock 代码的测试中，对于结果的验证（也就是 assert），通常出现在 Mock 函数中。</li></ul><h3 id="实际流程">实际流程</h3><p>实际软件项目中开展单元测试</p><ol><li>并不是所有的代码都要进行单元测试，通常只有底层模块或者核心模块的测试中才会采用单元测试。</li><li>你需要确定单元测试框架的选型，这和开发语言直接相关。</li><li>为了能够衡量单元测试的代码覆盖率，通常你还需要引入计算代码覆盖率的工具。</li><li>最后你需要把单元测试执行、代码覆盖率统计和持续集成流水线做集成，以确保每次代码递交，都会自动触发单元测试，并在单元测试执行过程中自动统计代码覆盖率，最后以“单元测试通过率”和“代码覆盖率”为标准来决定本次代码递交是否能够被接受。</li></ol><h3 id="总结">总结</h3><p>全部笔记内容从茹炳晟的《软件测试52讲》整理。</p><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/10275" rel="external nofollow noopener noreferrer" target="_blank">什么是单元测试？如何做好单元测试？</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解概念&quot;&gt;理解概念&lt;/h3&gt;
&lt;p&gt;1、单元测试的概念理解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="代码测试" scheme="https://hinzer.github.io/wiki/tags/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    
      <category term="笔记" scheme="https://hinzer.github.io/wiki/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git fetch</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-fetch/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-fetch/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>从远程取最新的patch或者分支，引用的信息记录到<code>.git/FETCH_HEAD</code>这个文件中。可以借助<code>git fetch --help</code>查看具体描述。可以操作一个分支<code>git pull = git getch + git merge</code>，也可以单独pick一个patch<code>git fetch + git cherry-pick</code>。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### 从gerrit上取一个patch，然后pick到当前分支</span><br><span class="line">git fetch ssh:<span class="comment">//wangjianfeng1@git.mioffice.cn:29418/device/xiaomi/merlin refs/changes/17/909617/1</span></span><br><span class="line">git cherry-pick FETCH_HEAD</span><br><span class="line"></span><br><span class="line">### 获取远程库的分支更新，然后merge到本地分支</span><br><span class="line">git fetch origin master:tmp #从远程仓库master分支获取最新，在本地建立tmp分支</span><br><span class="line">git diff tmp #將當前分支和tmp進行對比</span><br><span class="line">git merge tmp #合并tmp分支到当前分支</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.cnblogs.com/qiu-Ann/p/7902855.html" rel="external nofollow noopener noreferrer" target="_blank">git fetch 和git pull 的差别</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;从远程取最新的patch或者分支，引用的信息记录到&lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;这个文件中。可以借助&lt;code&gt;git fetch --help&lt;/code&gt;查看具体描述。可以操作一个分支&lt;code&gt;git 
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>push代码</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/push%E4%BB%A3%E7%A0%81/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/push代码/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:27:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用法">用法</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wjf@ubuntu:base$ pwd</span><br><span class="line">/home/wjf/miui/umi-q/frameworks/base</span><br><span class="line">wjf@ubuntu:base$ repo info .</span><br><span class="line">Manifest branch: miui-q-umi-stable</span><br><span class="line">Manifest merge branch: refs/heads/stable</span><br><span class="line">Manifest groups: all,-notdefault</span><br><span class="line">----------------------------</span><br><span class="line">Project: platform/frameworks/base</span><br><span class="line">Mount path: /home/wjf/miui/umi-q/frameworks/base</span><br><span class="line">Current revision: miui-q-umi-stable</span><br><span class="line">Local Branches: 0</span><br><span class="line">----------------------------</span><br><span class="line">wjf@ubuntu:base$ git push ssh://wangjianfeng1@gerrit.pt.miui.com:29418/platform/frameworks/base HEAD:refs/for/miui-q-umi-stable</span><br></pre></td></tr></table></figure><ul><li><code>git push</code> git语法表示远程推送,<code>git push help</code>查看详细情况</li><li><code>ssh://wangjianfeng1@gerrit.pt.miui.com:29418/platform/frameworks/base</code>表示使用ssh协议访问gerrit服务器的29418端口，通过url定位到frameworks/base这个目录，是要推送的目录</li><li><code>HEAD:refs/for/miui-q-umi-stable</code>,HEAD指向当前的本地分支，refs/for/miui-q-umi-stable表示远程分支名。</li></ul><p><em>ps: 在修改目录下，git remote -v命令查看代码服务器的git仓库的链接，repo info .获取gerrit仓库远程提交点（分支名）</em></p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.cnblogs.com/sparkdev/p/6071533.html" rel="external nofollow noopener noreferrer" target="_blank">SSH协议语法格式</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用法&quot;&gt;用法&lt;/h3&gt;
&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>打patch</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/%E6%89%93patch/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/打patch/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>patch是某一次提交给文件内容的改变，打patch是将某一次改变的内容应用到当前的版本库。</p><h3 id="常规操作">常规操作</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成patch</span></span><br><span class="line">git diff <span class="string">./</span> &gt; xxx.<span class="keyword">patch</span>  <span class="comment">#将差异的内容制作成patch</span></span><br><span class="line">mkdir update &amp;&amp; git diff commit-id-time1 commit-id-time2 <span class="params">--name-only</span> | xargs -i cp '&#123;&#125;' <span class="string">./update/</span> <span class="params">--parents</span> <span class="comment">#制作patch 把两个commit-id 之间修改的文件复制到update目录中 而且会把中间的目录也一并生成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打patch</span></span><br><span class="line"><span class="keyword">patch</span> -p1 &lt; xxx.<span class="keyword">patch</span></span><br></pre></td></tr></table></figure><h3 id="另外">另外</h3><p>不过我们有线上的gerrit仓库，日常使用<code>git fetch</code> + <code>git cherry-pick</code>效果是一样的，cherry-pick直接pick某一个patch.</p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/tf1Wyudp7l9XWM0ILAhZpQ" rel="external nofollow noopener noreferrer" target="_blank">你知道用git打补丁吗？</a></li><li><a href="https://www.git-scm.com/book/en/v2/Appendix-C%3A-Git-Commands-Patching" rel="external nofollow noopener noreferrer" target="_blank">Git Commands - Patching</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;patch是某一次提交给文件内容的改变，打patch是将某一次改变的内容应用到当前的版本库。&lt;/p&gt;
&lt;h3 id=&quot;常规操作&quot;&gt;常规操作&lt;/h3&gt;
&lt;figure class=&quot;highlight jboss-cli&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用Linux命令运行程序、安装软件</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B002/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/操作系统综述02/</id>
    <published>2020-03-21T14:01:02.000Z</published>
    <updated>2020-03-22T04:57:49.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，<code>运行程序</code>和<code>安装软件</code>的命令整理一下。</p></blockquote><h3 id="运行程序">运行程序</h3><p>通过命令行让Linux执行<code>程序</code>，有以下几种方式，也决定<code>进程</code>已什么方式运行。<br><strong>1、交互式运行</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>./filename  <span class="comment"># 交互式运行，Ctrl+C可以结束这个在执行的进程</span></span><br></pre></td></tr></table></figure><p><strong>2、后台方式运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 脱离终端后台运行，并将<span class="built_in">log</span>输出到xxx.outfile文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nohup命令使终端关闭也不影响进程(进程正常是终端进程fork过来的，父进程挂起....), 2&amp;&gt;1表示将标准输出合并错误输出到xxx.outfile,&amp;设置进程后台运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nohup ./<span class="built_in">command</span> &gt; xxx.outfile 2&amp;&gt;1 &amp;  <span class="comment"># 后台运行进程</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ps -ef |grep 关键字过滤出进程信息，通过awk <span class="string">'&#123;print $2&#125;'</span>找出进程id，然后通过xargs命令传递给<span class="built_in">kill</span> -9 ，最终干掉这个进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef |grep 关键字 |awk <span class="string">'&#123;print $2&#125;'</span>|xargs <span class="built_in">kill</span> -9 <span class="comment"># kill 这个进程的方法</span></span></span><br></pre></td></tr></table></figure><p><strong>3、服务方式运行</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  systemctl工具管理服务</span></span><br><span class="line">$ systemctl <span class="builtin-name">enable</span> service-name</span><br><span class="line">$ systemctl start service-name</span><br><span class="line">$ systemctl stop service-name</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p><em>现在有一个小问题</em></p><blockquote><p>Q: 后台运行的进程和服务都是可以脱离终端独立存在的，那么两者有什么区别呢？<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>A：查到<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/11027121?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">系统服务</a>的概念，总结两点区别：1、服务是系统功能的进程；进程是用户的进程。2、服务不会与用户交互，在后台默默运行(这点和后台进程一样)</p></blockquote><p><br><br></p><h3 id="安装软件">安装软件</h3><p>无论是<code>Ubuntu</code>系还是<code>CentOS</code>系的Linux发行版，总有几种安装软件的方式，<code>下载安装包</code>、<code>通过软件管家</code>、<code>直接下载压缩包</code>或者通过<code>源码编译</code>。<br><strong>1、下载安装包安装</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>dpkg -i xxxx.deb   <span class="comment"># 如果是chentos的话，使用rpm命令</span></span><br></pre></td></tr></table></figure><p><strong>2、通过软件管家安装</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-<span class="keyword">get</span> install xxxx    <span class="comment"># 如果是chentos的话，使用yum命令</span></span><br></pre></td></tr></table></figure><p><strong>3、下载压缩包安装</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=XXX/bin:PATH #将可执行文件bin添加到PATH变量，可将这个命令配置在~/.bashrc文件，每次重启Linux加载这个文件</span><br></pre></td></tr></table></figure><p><strong>4、源码编译安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对当前环境评估，--prefix指定安装路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span>/program</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译生成安装包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装软件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>引用文章中总结的图片<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzg4L2U1Lzg4NTViYjY0NWQ4ZWNjMzVjODBhYTg5Y2RlNWQxNmU1LmpwZw?x-oss-process=image/format,png" alt="Linux常用命令"></p><h3 id="课后作业">课后作业</h3><p>课后要求是安装jdk和mysql，搭建一个数据库服务。我没有去做，不过我找到一个部署的教程,很有参考意义:<br><a href="https://www.linuxprobe.com/chapter-20.html#2021_Mysql" rel="external nofollow noopener noreferrer" target="_blank">使用LNMP架构部署动态网站环境</a></p><br><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://time.geekbang.org/column/article/88761" rel="external nofollow noopener noreferrer" target="_blank">快速上手几个Linux命令：每家公司都有自己的黑话</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，&lt;code&gt;运行程序&lt;/code&gt;和&lt;code&gt;安装软件&lt;/code&gt;的命令整理一下。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>把Linux内核当成一家软件外包公司的老板</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B001/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/操作系统综述01/</id>
    <published>2020-03-21T12:33:10.000Z</published>
    <updated>2020-03-21T14:10:22.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色</p></blockquote><h3 id="计算机硬件组成">计算机硬件组成</h3><p>对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、硬盘、网卡…</p><p><img src="http://qiniu.benmoom.cn/01%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt="插入图片01"></p><p>但仅有硬件组成的电脑，还不能直接使用。&quot;硬件 + 操作系统&quot;才算是我们通常说的电脑，以后的学习主要围绕linux系统，这个话题展开。我们首先必须承认操作系统的重要性。</p><h3 id="想理解外包公司一样理解操作系统">想理解外包公司一样理解操作系统</h3><p>刘超老师将操作系统类比成一家外包公司。确实很形象，加深了我对linux系统的理解。<br>内核对于操作系统，相当于公司的老板，老板是不轻易干活的(一般有很多部门)，所以linux系统中也有很多子系统。对应关系有：</p><table><thead><tr><th>linux系统</th><th>外包公司</th></tr></thead><tbody><tr><td>用户</td><td>公司的客户</td></tr><tr><td>内核</td><td>公司的老板</td></tr><tr><td>系统调用</td><td>公司的办事大厅</td></tr><tr><td>设备管理系统</td><td>公司的客户对接和交付部门</td></tr><tr><td>网络管理系统</td><td>公司的对外合作部门</td></tr><tr><td>进程管理系统</td><td>公司的项目管理部门</td></tr><tr><td>内存管理系统</td><td>公司的会议室</td></tr><tr><td>文件系统系统</td><td>公司的档案室</td></tr></tbody></table><p>其他：<code>程序</code>相当于<code>项目计划书</code>，<code>进程</code>相当于<code>正在进行的项目</code>。</p><p><img src="http://qiniu.benmoom.cn/02%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpeg" alt="插入图片02"></p><h3 id="“点击QQ事件”">“点击QQ事件”</h3><p>为了更好的理解linux的运作机制，老师分析了&quot;用户点击qq&quot;事件。分为如下几个阶段</p><p><strong>阶段一：用户点击图标</strong><br>对于linux而言，驱动捕捉到用户点击事件，产生中断。cpu调用到驱动事先安排好的中断处理函数。</p><p>对于外包公司而言，对接人员记录客户提出的需求，进行项目开发的计划。</p><p><strong>阶段二：系统加载进程</strong><br>对于linux而言，将qq的程序文件从硬盘加载到内存，内存上以进程启动。这个阶段需要思考几个问题：<br>1. 硬盘上的文件如何管理？<br>2. 内存空间上的进程如何管理？<br>3. 多进程如何实现？<br>4. 进程自身如何实现功能？<br>硬件上的数据有<code>文件系统</code>进行统一管理；进程在内存空间上的映射由<code>内存管理系统</code>完成；多进程的实现通过<code>进程管理系统</code>；系统对进程提供统一的接口，实现核心功能。这层接口称为<code>系统调用层</code>。</p><p>对于外包公司而言，从档案库中取出项目计划书，成立项目组，划分会议室，完成立项的过程。然后执行项目，通过办事大厅处理业务，和各个部门打交道。这些都是动态的过程。之后就比较好理解了。</p><p><img src="http://qiniu.benmoom.cn/03linux%E5%AD%90%E7%B3%BB%E7%BB%9F.jpeg" alt="插入图片03"></p><p><strong>阶段三：进程调出对话框</strong><br>对于linux而言，进程调出显示对话框，进程-&gt;显卡驱动-&gt;显示界面</p><p>对于公司，这里显卡驱动相当于客户的交付人员，项目组通过交付人员将项目的成果交付给用户。</p><p><strong>阶段四：用户操作输入框</strong><br>用户在输入框输入，字符立即显示，键盘驱动-&gt;进程-&gt;显卡驱动-&gt;显示界面</p><p>对于公司，就是对接人员处理客户不断提出的需求–交付人员交付的过程</p><p><strong>阶段五：用户按回车发送</strong><br>对于linux系统，用户按下回车键，网络发送到远程的另一个用户，键盘驱动-&gt;进程-&gt;网卡驱动</p><p>对于公司，有时候为了实现需求，需要与其他公司的交互，通过对外合作部门。</p><h3 id="总结">总结</h3><p>以一张图片概括我对这篇文章的理解<br><img src="http://qiniu.benmoom.cn/a%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0.png" alt="插入图片-综述"></p><h3 id="课后作业">课后作业</h3><p>对于<strong>课堂练习</strong>，找出linux源码中几个子系统所在的目录（参考同学给出的答案）</p><p><strong>linux内核</strong>：<a href="https://www.kernel.org/" rel="external nofollow noopener noreferrer" target="_blank">https://www.kernel.org/</a></p><ul><li>系统调用 kernel/</li><li>进程管理 kernel/, arch/<arch>/kernel</arch></li><li>内存管理 mm/, arch/<arch>/mm</arch></li><li>文件系统 fs/</li><li>设备系统 drivers/char, drivers/block</li><li>网络系统 net/</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/88060" rel="external nofollow noopener noreferrer" target="_blank">《趣谈Linux操作系统》03章</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;计算机硬件组成&quot;&gt;计算机硬件组成&lt;/h3&gt;
&lt;p&gt;对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git 调试</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git%E8%B0%83%E8%AF%95/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git调试/</id>
    <published>2020-03-20T01:20:14.000Z</published>
    <updated>2020-03-28T00:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念理解">概念理解</h3><p><code>git blame</code>和<code>git bisect</code>能帮助调试git项目，找到出bug的原因。</p><h3 id="操作方法">操作方法</h3><p>1、文件标注<br>使用<code>git blame</code>能显示任何文件中每行最后一次修改的提交记录。<code>git blame --help</code>查看具体描述</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">mi@</span>ubuntu:base$ git blame Android.bp -L <span class="number">230</span>,<span class="number">231</span>  #查看Android.bp的<span class="number">230</span><span class="number">-231</span>行提交记录，</span><br><span class="line">#commit id   #提交者        #时间                      #行          #内容</span><br><span class="line"><span class="number">7</span>c469179ce2a (junyulai      <span class="number">2019</span><span class="number">-01</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">23</span>:<span class="number">34</span> +<span class="number">0800</span> <span class="number">230</span>)         <span class="string">"core/java/android/net/ISocketKeepaliveCallback.aidl"</span>,</span><br><span class="line">e40eab608af2 (Benedict Wong <span class="number">2018</span><span class="number">-11</span><span class="number">-14</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">13</span> <span class="number">-0800</span> <span class="number">231</span>)         <span class="string">"core/java/android/net/ITestNetworkManager.aidl"</span>,</span><br></pre></td></tr></table></figure><p>2、二分查找<br><code>git bisect</code>能在commit区间中检出中间的patch，通过不断地二分查找，最终定位到带bug的patch</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始</span></span><br><span class="line">$ git <span class="keyword">bisect </span>start  <span class="comment"># 启动二分</span></span><br><span class="line">$ git <span class="keyword">bisect </span><span class="keyword">bad </span><span class="comment"># 当前提交有bug</span></span><br><span class="line">$ git <span class="keyword">bisect </span>good &lt;good_commit&gt;  <span class="comment">#指定已知的最后一次正常状态是哪次提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 --&gt; 二分判断</span></span><br><span class="line">$ git <span class="keyword">bisect </span>good  <span class="comment"># 当前提交无bug</span></span><br><span class="line">$ git <span class="keyword">bisect </span><span class="keyword">bad </span>  <span class="comment"># 当前提交有bug</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束</span></span><br><span class="line">$ git <span class="keyword">bisect </span>reset</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E4%BD%BF%E7%94%A8-Git-%E8%B0%83%E8%AF%95" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 使用 Git 调试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念理解&quot;&gt;概念理解&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git blame&lt;/code&gt;和&lt;code&gt;git bisect&lt;/code&gt;能帮助调试git项目，找到出bug的原因。&lt;/p&gt;
&lt;h3 id=&quot;操作方法&quot;&gt;操作方法&lt;/h3&gt;
&lt;p&gt;1、文件标注&lt;br&gt;
使用&lt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git merge失败</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/2020-03-20-bug-for-git/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/2020-03-20-bug-for-git/</id>
    <published>2020-03-19T16:11:37.000Z</published>
    <updated>2020-03-21T01:45:57.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>git merge本地分支出现报错 fatal: refusing to merge unrelated histories<br><img src="http://ww1.sinaimg.cn/large/0063ewMaly1gczozf2n8ij30vn0fognf.jpg" alt="git-merge.jpg"></p><h2 id="第一反应">第一反应</h2><p>我现在都是在本地操作还没有远程，我得理解master分支merge到slave分支，应该直接fast forward过去才对。<br>如果把master分支干掉，直接在slave分支那个位置创建一个master分支应该也没什么影响。就是特别像知道为啥会出错这个merge。</p><h2 id="问题分析">问题分析</h2><p>merge命令之后报错<code>fatal: refusing to merge unrelated histories。</code>，表示当前分支和slave分支不相关。有<a href="https://yq.aliyun.com/articles/614459" rel="external nofollow noopener noreferrer" target="_blank">对应的解决方案</a><br>加上<code>--allow-unrelated-histories</code>参数，忽略这个问题。<br>然而又报错，根据进一步提示，<code>git status</code>发现当前工作目录确实存在冲突。解决完冲突commit之后，再次merge就可以了。</p><p>不记得当时具体做了什么操作了，又重新做了几遍还是没能把当时的情景复现出来(merge直接fast forward了)。后来分析应该是某种原因导致了文件冲突，进而影响之后的merge操作。</p><h2 id="解决方法">解决方法</h2><p>如果是<code>git pull</code>或者<code>git push</code>报<code>fatal: refusing to merge unrelated histories</code>,直接在merge后加上<code>--allow-unrelated-histories</code>参数就ok了<br>如果是依然无效，不妨先<code>git status</code>查看一下当前版本库的状态有无问题(我这边是冲突引起的)。</p><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://yq.aliyun.com/articles/614459" rel="external nofollow noopener noreferrer" target="_blank">解决Git中fatal: refusing to merge unrelated histories</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;git merge本地分支出现报错 fatal: refusing to merge unrelated histories&lt;br&gt;
&lt;img src=&quot;http://ww1.sinaimg.cn/large/0063ewMa
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
      <category term="Bug" scheme="https://hinzer.github.io/wiki/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>git log</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-log/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-log/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:02.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>显示项目提交历史，通过参数选项可以控制log显示的方式。<code>git help log</code>查看具体描述。</p><p>git log 有两个高级用法：一是自定义提交的输出格式，二是过滤输出哪些提交。这两个用法合二为一，你就可以找到你项目中你需要的任何信息。</p><h3 id="使用准则">使用准则</h3><ul><li>git log允许你查看你项目历史中任何需要的内容。</li></ul><h3 id="命令速查">命令速查</h3><p>1、常规使用,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#log_options" rel="external nofollow noopener noreferrer" target="_blank">git log常用选项</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --graph --all <span class="comment">#简略显示各种分支的patch记录，个人比较下常用这个命令</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>    <span class="comment"># 显示每次提交的文件修改统计信息。</span></span><br><span class="line">git <span class="built_in">log</span> -p <span class="comment"># 按补丁格式显示每个提交引入的差异。</span></span><br></pre></td></tr></table></figure><p>2、定制化输出,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#pretty_format" rel="external nofollow noopener noreferrer" target="_blank">–pretty=format常用格式</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> --pretty=<span class="keyword">format</span>:<span class="string">"%h %s"</span> --graph</span><br><span class="line">$ git <span class="keyword">log</span> --date=<span class="keyword">format</span>:<span class="string">'%Y-%m-%d %H:%M:%S'</span> --pretty=<span class="keyword">format</span>:<span class="string">"%h-%an-%ad-%ae"</span> --graph --all</span><br></pre></td></tr></table></figure><ul><li>–date=format定制作者修订日期格式</li><li>–pretty=format定制log记录显示</li><li>–graph图形显示分支与合并历史</li><li>–all显示所有分支</li></ul><p>3、过滤出自己想要看到的log,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#limit_options" rel="external nofollow noopener noreferrer" target="_blank">限制输出长度</a></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> <span class="number">-3</span>  #按次数，最近<span class="number">3</span>次提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --since=<span class="number">2.</span>weeks #按时间，最近两周提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --<span class="keyword">until</span>=<span class="number">2020</span><span class="number">-03</span><span class="number">-20</span> #按时间，<span class="number">2020</span><span class="number">-03</span><span class="number">-20</span>前的提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --grep=<span class="string">"update"</span>#仅显示提交说明中包含<span class="string">"update"</span>的提交</span><br></pre></td></tr></table></figure><p>4、如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> --pretty=<span class="string">"%h - %s"</span> --author=<span class="string">'Junio C Hamano'</span> --since=<span class="string">"2008-10-01"</span> \</span><br><span class="line">   --before=<span class="string">"2008-11-01"</span> --<span class="keyword">no</span>-merges -- t/</span><br><span class="line"><span class="number">5610</span>e3b - Fix testcase failure <span class="keyword">when</span> extended attributes are in <span class="keyword">use</span></span><br><span class="line">acd3b9e - Enhance hold_lock_file_for<span class="number">_</span>&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic <span class="keyword">link</span> HEAD</span><br><span class="line">d1a43f2 - <span class="keyword">reset</span> --hard/<span class="keyword">read</span>-tree --<span class="keyword">reset</span> -u: remove unmerged new paths</span><br><span class="line"><span class="number">51</span>a94af - Fix <span class="string">"checkout --track -b newbranch"</span> on detached HEAD</span><br><span class="line">b0ad11e - pull: allow <span class="string">"git pull origin $something:$current_branch"</span> into an unborn branch</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" rel="external nofollow noopener noreferrer" target="_blank">Git 基础 - 查看提交历史</a></li><li><a href="https://jasonhzy.github.io/2016/05/05/git-log/" rel="external nofollow noopener noreferrer" target="_blank">Git日志格式、颜色设置</a></li><li><a href="https://blog.csdn.net/jk110333/article/details/8590746" rel="external nofollow noopener noreferrer" target="_blank">Linux下date命令，格式化输出，时间设置</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;显示项目提交历史，通过参数选项可以控制log显示的方式。&lt;code&gt;git help log&lt;/code&gt;查看具体描述。&lt;/p&gt;
&lt;p&gt;git log 有两个高级用法：一是自定义提交的输出格式，二是过滤输出哪些提交。这两个用法合二为一
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git log</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-merge/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-merge/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:21.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。<code>git help merge</code>命令查看具体描述。</p><p>将<code>topic</code>分支merge到<code>master</code>分支上(更新master分支)，使用<code>git merge topic</code></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">合并前:</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br><span class="line"><span class="comment">合并后:</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span>         <span class="comment">\</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span>--<span class="literal">-</span><span class="comment">H</span> <span class="comment">master</span></span><br></pre></td></tr></table></figure><h3 id="使用准则">使用准则</h3><ul><li>merge或者pull之前本地仓库是干净的应当commit本地，保证merge之后不会被破坏。或者<code>git stash</code>储藏本地的修改</li><li>merge冲突后可以使用<code>git status</code>查看分支状态，<code>git diff</code>显示工作区文件变化</li></ul><h3 id="命令速查">命令速查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span>   <span class="comment"># merge slave分支到当前HEAD分支， --no-ff </span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span> <span class="comment">--no-ff  # 不使用fast-forward模式，merge同时创建一个新的cmomit patch</span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span> <span class="comment">--allow-unrelated-histories   #</span></span><br><span class="line">$ git <span class="keyword">merge</span> -Xignore-<span class="keyword">space</span>-<span class="keyword">change</span> <span class="keyword">whitespace</span> <span class="comment"># 忽略空白merge</span></span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="comment">--abort # (merge失败)恢复到合并前的状态</span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="comment">--continue  # 冲突后执行</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/docs/git-merge/2.12.0" rel="external nofollow noopener noreferrer" target="_blank">git help merge</a></li><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6" rel="external nofollow noopener noreferrer" target="_blank">高级合并</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。&lt;code&gt;git help merge&lt;/code&gt;命令查看具体描述。&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;topic&lt;/code&gt;分支merge到&lt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git rebase</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-rebase/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-rebase/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:45.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>rebase也是整合不同分支的方法，和merge不同的是它会改变提交历史。<code>git help rebase</code>命令查看具体描述。<br>假设当前HEAD指向<code>topic</code>分支，下面执行rebase命令(将topic上的patch打到master上，并改变历史)，使用<code>git rebase master</code></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">rebase前:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br><span class="line"><span class="comment">rebase后:</span></span><br><span class="line"><span class="comment"></span>                             <span class="comment">A'</span>--<span class="comment">B'</span>--<span class="comment">C'</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                            <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br></pre></td></tr></table></figure><p>原理:首先找到这两个分支（即当前分支 topic、变基操作的目标基底分支 master 的最近共同祖先 E，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 G, 最后以此将之前另存为临时文件的修改依序应用</p><h3 id="使用准则">使用准则</h3><ul><li>rebase操作可以让提交历史更加简介，但注意不要影响远程分支的提交历史记录。不要在公共分支上使用rebase</li><li>如果你想把rebase之后的master分支推送到远程仓库，Git会阻止你这么做，因为两个分支包含冲突。但你可以传入<code>--force</code>标记来强行推送。</li><li></li></ul><h3 id="命令速查">命令速查</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase master topic #master是基底分支，将topic分支上的修改在master上重放</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git rebase --onto master<span class="built_in"> server client </span> #选中在<span class="built_in"> client </span>分支里但不在<span class="built_in"> server </span>分支里的修改，将它们在 master 分支上重放</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" rel="external nofollow noopener noreferrer" target="_blank"> Git 分支 - 变基</a></li><li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9" rel="external nofollow noopener noreferrer" target="_blank">Merge、Rebase 的选择</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;rebase也是整合不同分支的方法，和merge不同的是它会改变提交历史。&lt;code&gt;git help rebase&lt;/code&gt;命令查看具体描述。&lt;br&gt;
假设当前HEAD指向&lt;code&gt;topic&lt;/code&gt;分支，下面执行reb
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git reset、git checkout</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-reset_git-checkout/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-reset_git-checkout/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:59.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>1、<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" rel="external nofollow noopener noreferrer" target="_blank">git三棵树</a>,即</p><ul><li>HEAD，永远指向当前分支的最新一笔提交</li><li>Index，索引(暂存区)</li><li>Work Directory,工作目录</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git 底层命令</span></span><br><span class="line">git cat-<span class="built_in">file</span> -p HEAD <span class="comment">#显示HEAD内容</span></span><br><span class="line">git ls-tree -r HEAD <span class="comment">#显示树对象的内容</span></span><br><span class="line">git ls-<span class="built_in">files</span> -s <span class="comment">#显示索引(Index)的所有文件信息</span></span><br><span class="line">tree <span class="comment">#查看当前工作目录</span></span><br></pre></td></tr></table></figure><p>2、git-reset<br>将当前HEAD重置为指定状态。<code>git help reset</code>命令查看具体描述。</p><h3 id="使用准则">使用准则</h3><ul><li>运行<code>git --hard reset</code>之前请考虑一下。如果由于执行这个选项导致工作目录中文件(文件已经提交)被覆盖，可以尝试<code>git reflog</code>找回。</li></ul><h3 id="命令速查">命令速查</h3><p>1、作用于某个patch</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset <span class="params">--soft</span> [<span class="keyword">patch</span>]<span class="comment">#移动HEAD的指向，不改变Index和Work Directory</span></span><br><span class="line">git reset <span class="params">--mixed</span> [<span class="keyword">patch</span>] <span class="comment">#(默认reset)移动HEAD的指向，改变Index，但不改变Work Directory</span></span><br><span class="line">git reset <span class="params">--hard</span> [<span class="keyword">patch</span>]<span class="comment">#移动HEAD的指向，改变Index和Work Directory</span></span><br></pre></td></tr></table></figure><p>2、作用于某个path/file</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> [<span class="keyword">path</span>/<span class="keyword">file</span>]<span class="comment">#通过当前HEAD指向的patch改变当前Index(恢复暂存区)</span></span><br><span class="line">git <span class="keyword">reset</span> [<span class="keyword">patch</span>] [<span class="keyword">path</span>/<span class="keyword">file</span>] <span class="comment">#通过指定patch改变当前Index</span></span><br></pre></td></tr></table></figure><p>3、压缩提交</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset <span class="params">--soft</span> [<span class="keyword">patch</span>] <span class="comment">#HEAD移动到压缩提交的前一个patch，Index和Work Directory不变</span></span><br><span class="line">git commit <span class="comment">#通过Index创建新的patch</span></span><br></pre></td></tr></table></figure><p>###git reset 和 git checkout<br>总结了两点重要的区别，</p><ul><li>操作patch时，chekcout只移动HEAD指针本身(不改变HEAD分支)</li><li>操作path/file时，checkout会改变工作目录(类似git reset --hard)</li></ul><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 重置揭密</a></li><li><a href="https://github.com/zlargon/git-tutorial/blob/master/branch/commit_tree.md" rel="external nofollow noopener noreferrer" target="_blank">多种表示patch的方式</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86&quot; rel=&quot;exter
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git revert</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-revert/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-revert/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:13.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>revert还原提交，撤销已经存在的commit的所有更改，原来的commit将保留，并用新commit来记录还原后的结果。<code>git help revert</code>命令查看具体描述。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD <span class="comment"># 撤销当前HEAD指向的patch上的更改</span></span><br><span class="line"></span><br><span class="line">git revert <span class="keyword">commit</span><span class="comment"># 撤销制定commitid表示的patch上的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge之后的revert</span></span><br><span class="line">git revert -m <span class="number">1</span> <span class="keyword">HEAD</span> <span class="comment"># HEAD指向的节点有两个父节点,-m 1保留父节点1，撤销父节点2带来的改变</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6" rel="external nofollow noopener noreferrer" target="_blank">工具 - 高级合并</a></li><li><a href="https://www.cnblogs.com/0616--ataozhijia/p/3709917.html" rel="external nofollow noopener noreferrer" target="_blank">git revert 用法</a></li><li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/2.6-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9" rel="external nofollow noopener noreferrer" target="_blank">回滚错误的修改</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;revert还原提交，撤销已经存在的commit的所有更改，原来的commit将保留，并用新commit来记录还原后的结果。&lt;code&gt;git help revert&lt;/code&gt;命令查看具体描述。&lt;/p&gt;
&lt;h3 id=&quot;使用准则&quot;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git stash、git clean</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-stash_git-clean/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-stash_git-clean/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:29.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。或在清理(clean)文件。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git stash push <span class="comment"># stash跟踪文件的修改与暂存的改动</span></span><br><span class="line"><span class="variable">$</span> git stash push -<span class="literal">-keep</span><span class="literal">-index</span> <span class="comment"># --keep-index 选项使存储的同时保留索引。</span></span><br><span class="line"><span class="variable">$</span> git stash push -<span class="literal">-all</span><span class="comment"># -u 选项存储untracked文件，</span></span><br><span class="line"><span class="variable">$</span> git stash push <span class="literal">-u</span> <span class="comment"># stash全部文件(包括被忽略文件)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git stash list <span class="comment"># 列出当前的stash</span></span><br><span class="line"><span class="variable">$</span> git stash apply   <span class="comment"># 应用stash, 加上--index 选项可以让之前暂存的文件重新暂存</span></span><br><span class="line"><span class="variable">$</span> git stash drop stash<span class="selector-tag">@</span>&#123;<span class="number">0</span>&#125;<span class="comment"># 移除stash,</span></span><br><span class="line"><span class="variable">$</span> git stash pop <span class="comment"># 应用stash@&#123;0&#125;,并移除它</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git stash branch dev  <span class="comment"># 创建新分支dev，然后应用stash,然后drop stash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git clean <span class="operator">-f</span> <span class="literal">-d</span> <span class="comment"># 移除工作目录中所有未追踪的文件以及空的子目录(不包括被忽略文件)</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-n</span> <span class="comment"># 演戏以下，加-n参数</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-n</span> <span class="literal">-x</span> <span class="comment"># -x选择清理忽略文件</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-x</span> <span class="literal">-i</span> <span class="comment"># -i交互模式</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 贮藏与清理</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。或在清理(clean)文件。&lt;/p&gt;
&lt;h3 id=&quot;使用准则
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git 对象</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git对象/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:40.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="窥探">窥探</h2><p>git对文件内容管理核心是基于<code>键值对数据库</code>，位于<code>.git/objects</code>。通过<code>key-value</code>方式管理内容。<br>对象数据库中存储的三种对象，每一个对象在数据库中以<code>key-value</code>形式存在</p><ul><li>数据对象（blob object），记录文件内容,解决内容存储问题</li><li>树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起</li><li>提交对象（commit object），对应一次提交，解决项目快照的问题</li></ul><p><img src="https://www.git-scm.com/book/en/v2/images/data-model-3.png" alt="对象关系图"></p><h2 id="命令速查">命令速查</h2><p>1、<strong>通用操作</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find</span> .git/objects -<span class="built_in">type</span> <span class="keyword">f</span>  # 列出所有git对象</span><br><span class="line"></span><br><span class="line">git <span class="keyword">cat</span>-<span class="keyword">file</span> -<span class="keyword">p</span> <span class="symbol">&lt;key&gt;</span> # 查看对象内容信息</span><br><span class="line">git <span class="keyword">cat</span>-<span class="keyword">file</span> -t <span class="symbol">&lt;key&gt;</span> # 查看对象类型</span><br><span class="line"></span><br><span class="line">git <span class="keyword">cat</span>-<span class="keyword">file</span> -<span class="keyword">p</span> master^&#123;tree&#125; #查看master分支上最近提交的树对象</span><br></pre></td></tr></table></figure><p><em>PS: 尝试<code>git add</code>、<code>git commit</code>等上层命令，然后<code>find .git/objects -type f</code>查看git对象的变化。<br>发现：git每次add文件，添加数据对象；commit之后，又创建了树对象、和提交对象。<br>于是得出结论：git会记录每一次变化的文件版本(生成blob对象)，对于没有修改的文件tree还是原来的指向。</em></p><p>2、<strong>创建数据对象</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 内容写入数据库，返回key值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin<span class="comment"># -w表示写入数据库, --stdin表示从标准输入流读取</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'version 1'</span> &gt; test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">hash</span>-object -w test.txt <span class="comment">#从文件读取内容写入数据库</span></span></span><br></pre></td></tr></table></figure><p>3、<strong>创建树对象</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 为文件添加暂存区(<span class="built_in">index</span>)</span><br><span class="line">$ git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> --cacheinfo <span class="number">100644</span> \</span><br><span class="line">  <span class="number">83</span>baae61804e65cc73a7201a7252750c76066a30 test.txt# --<span class="built_in">add</span>表示这个文件此前没有添加到<span class="built_in">index</span>, --cacheinfo表示添加的文件在数据库中 匹配此的参数格式为(文件模式 key 文件名)</span><br><span class="line">$ git <span class="keyword">write</span>-tree #通过暂存区创建树对象</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">$ <span class="keyword">echo</span> <span class="string">'new file'</span> &gt; <span class="keyword">new</span>.txt</span><br><span class="line">$ git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> --cacheinfo <span class="number">100644</span> \</span><br><span class="line">  <span class="number">1</span>f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line">$ git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> <span class="keyword">new</span>.txt</span><br><span class="line">文件名)</span><br><span class="line">$ git <span class="keyword">write</span>-tree #通过暂存区创建树对象</span><br></pre></td></tr></table></figure><p>4、<strong>创建提交对象</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'first commit'</span> | git commit-tree d8329f<span class="comment">#(没有父提交)第一步提交</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'second commit'</span> | git commit-tree 0155eb -p fdf4fc3  <span class="comment">#-p参数制定父提交对象的key</span></span></span><br></pre></td></tr></table></figure><p>5、<strong>查看提交历史</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span> 0155eb</span></span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1" rel="external nofollow noopener noreferrer" target="_blank">Git 内部原理 - Git 对象</a></li><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 重置揭密</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;窥探&quot;&gt;窥探&lt;/h2&gt;
&lt;p&gt;git对文件内容管理核心是基于&lt;code&gt;键值对数据库&lt;/code&gt;，位于&lt;code&gt;.git/objects&lt;/code&gt;。通过&lt;code&gt;key-value&lt;/code&gt;方式管理内容。&lt;br&gt;
对象数据库中存储的三种对象，每一个对
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git 引用</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git%E5%BC%95%E7%94%A8/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git引用/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:53.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>git用文件保存patch的哈希值，这个文件名代表一个分支。指针、分支、引用理解是表示一个概念。</p><p><img src="https://git-scm.com/book/en/v2/images/data-model-4.png" alt="git本地仓库"></p><p>1、在<code>.git</code>目录下查看</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HEAD <span class="comment">#指向当前分支</span></span><br><span class="line">refs<span class="regexp">/heads/</span>   <span class="comment">#分支，记录本地commit对象</span></span><br><span class="line">refs<span class="regexp">/tags/</span>  <span class="comment">#tag也记录commit对象，但是通常不会改变</span></span><br><span class="line">refs<span class="regexp">/remotes/origin/</span> <span class="comment">#服务器映射下来的远程只读分支</span></span><br></pre></td></tr></table></figure><p>2、查看HEAD内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mi@ubuntu:test3$ <span class="built_in">cd</span> .git</span><br><span class="line">mi@ubuntu:.git$ cat HEAD</span><br><span class="line">ref: refs/heads/master</span><br><span class="line">mi@ubuntu:.git$ cat refs/heads/master</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line"></span><br><span class="line">mi@ubuntu:.git$ git show HEAD</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master)</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8" rel="external nofollow noopener noreferrer" target="_blank">Git 内部原理 - Git 引用</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;git用文件保存patch的哈希值，这个文件名代表一个分支。指针、分支、引用理解是表示一个概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/data-model-4.
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>小狗钱钱阅读笔记</title>
    <link href="https://hinzer.github.io/wiki/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/"/>
    <id>https://hinzer.github.io/wiki/生活学习/读书笔记/小狗钱钱/</id>
    <published>2020-03-16T23:42:42.000Z</published>
    <updated>2020-03-16T23:43:58.987Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这本书的重点内容：</strong></p><ol><li>怎么攒钱？开始储蓄，迈出财富积累的第一步</li><li>怎么挣钱？付出劳动，挣出第一桶金</li><li>怎么用钱生钱？学会投资，养一只会下金蛋的鹅<br><br></li></ol><h2 id="怎么攒钱？">怎么攒钱？</h2><blockquote><p>攒钱这件事要从哪开始呢？小狗钱钱说，首先要从你脑子里的想法开始。我们首先要正确地认识钱，金钱既不是万能的，也不是万恶之源，它本身没有好坏之分，只是商品流通的媒介。金钱就像一个放大镜，它只是充分展示了人性本来的样子。一个幸福的人有了钱，会更加快乐；一个悲观的人有了钱，会更加忧虑。像比尔·盖茨、扎克伯格这样的人，有了钱，会捐出巨资，帮助他人。而像伊斯兰国这样的恐怖组织，会用钱去购买武器，伤害无辜。<br>你是什么样的人？如果有了钱，你会去做什么？对我们大多数人来说，有了钱，可以提高生活质量，去实现更多的梦想。反之，越是缺钱，我们就越容易被它牵制。小狗钱钱说，吉娅的父母之所以不停地谈钱，就是因为他们的经济状况太糟糕了，好比一个人掉进水里，随时可能会被淹没。</p></blockquote><br><h3 id="梦想清单">梦想清单</h3><p>用笔写下10个你想变得富有的理由，越具体越好，然后从中挑出三个最重要的。在书里，吉娅挑出的3个理由包括，作为交换生去美国，买一台电脑，以及帮助爸妈还清债务。<br><br></p><h3 id="梦想相册">梦想相册</h3><p>那怎么制作梦想相册呢？比如，吉娅想去美国当交换生，她就在相册里贴上迪士尼乐园、自由女神像的照片。相册做完后，吉娅也没有束之高阁，而是每天都看几遍，想象自己在美国认识新的朋友，看到各种新鲜事物。这种方式让吉娅充满了攒钱的动力。<br><br></p><h3 id="梦想储蓄罐">梦想储蓄罐</h3><p>存钱可以让我们避免不必要的花费，做到量入为出。比如吉娅为了存钱，克制住了自己的欲望，没有直接用一个月的零花钱来买一张CD；而且存起来的钱，无论是放到银行还是买理财产品，都可以让你享受到复利、也就是利滚利的好处。这点非常关键。<br>在这本书里，小狗钱钱给吉娅的建议是 5-4-1原则，就是说，除了最必要的日常开销，剩余的收入分成10份，其中五份用来投资，四份放在梦想储蓄罐里，一份当作奖励自己的零花钱。哪怕你每个月日常开销以后只剩100块，也可以按照5-4-1原则来分配</p><blockquote><p>这就是让你开始攒钱的三个步骤，制作梦想清单、梦想相册和梦想储蓄罐。一旦开始储蓄，你就迈出了财富积累的第一步</p></blockquote><br><p><em><strong>PS</strong>:如果一个人出现资产负债的话，又谈何财富积累呢？</em></p><h3 id="走出负债">走出负债</h3><ol><li>停掉手中所有的信用卡</li><li>在允许范围内，尽量按照较低的分期付款数目标准来支付</li><li>边攒钱边还消费贷款</li><li>那就是每次在付款之前，都再问自己一句“这真的有必要吗？”</li></ol><p><strong>小结</strong>：以上我们着重讲了财富积累的第一步，储蓄。想要获得财富，首先我们必须牢牢树立攒钱的意识。本书为我们介绍了开始攒钱的三个步骤，制作梦想清单、梦想相册和梦想储蓄罐。同时，针对有债务困扰的人，小狗钱钱也给了我们四点忠告，分别是：停掉所有信用卡、按照较低分期付款标准支付贷款、攒钱还款两不误，以及每次花钱之前，问问自己“这真的有必要吗”。<br><br></p><h2 id="怎么挣钱？">怎么挣钱？</h2><blockquote><p>小狗钱钱先告诉吉娅要攒下零花钱，但是零花钱只有那么一点，为了实现去美国当交换生的梦想，吉娅还要攒更多的钱才行，于是她开始琢磨怎么挣钱。<br>一个12岁的小女孩能做什么呢？吉娅自己也非常茫然。这和我们大部分人的情况很像，我们都想赚钱，但怎么赚呢？</p></blockquote><h3 id="赚钱法则">赚钱法则</h3><ol><li>你得为别人解决一个难题；</li><li>你要把精力集中在你知道的、能做的和拥有的事情上。<br><em><strong>PS</strong>:做自己擅长和喜欢的事情，这件事情要给别人带来价值。</em><br><br></li></ol><h3 id="写成功日记">写成功日记</h3><p>每天花10分钟，写下你这一天的五个成果。千万别被“成功”这两个字误导了，你所记录的这些事情，不一定非得多重要，任何芝麻蒜皮的小事都可以写进去。比如，吉娅在第一次写成功日记时写道：今天我学习了挣钱的知识，攒了5马克钱，还制作了梦想相册。<br><br><br></p><h2 id="怎么理财？">怎么理财？</h2><blockquote><p>什么是“会下金蛋的鹅”呢？书里说，从前有个农夫，他养了一只鹅。有一天，他在笼子里发现了一只金蛋，于是他把这只金蛋卖了，得到了很多钱。第二天笼子里又有了一个金蛋。这样的好运持续了好几天。可是贪得无厌的农夫依然不知足，他认为这只鹅下金蛋的速度太慢了。于是，一怒之下，他把鹅劈成了两半。就这样，他的鹅死了，再也没法下金蛋了。<br>在这个故事里，“鹅”代表本金，它下的“金蛋”代表利息，用本金获取利息，也就是用钱生钱。在这个过程里，这个金蛋也被叫做是“被动收入”。就是说，你不用付出任何劳动，就能自动获得的收入，比如，银行存款的利息，出租房子的租金、出书的版税、股票的分红等等。</p></blockquote><p><em><strong>PS</strong>:&quot;被动收入&quot;是实现财务自由的关键因素</em><br><br></p><h3 id="股票与基金">股票与基金</h3><p><strong>股票</strong>:大家对股票更熟悉一点，你买了这家公司的股票，就成了它的股东，每年可以享受分红。而且，你可以在证券市场上买进或是卖出股票。当然，作者说的欧美股票市场，和我们国家的股市，在规范程度和投资回报上都有所不同，借鉴意义有限，所以我们点到为止。<br><strong>基金</strong>:基金就像一口大锅，投资者可以把自己的钱投进这口锅里，然后由基金经理人，帮大家投资买股票。你只需要付给经理人一定的佣金就行。因为基金这口锅里，有多种不同股票，里面某只股票的涨跌已经被分散稀释，所以风险比股票小，当然收益也相对比较少。但是从长期来看，找到稳定上涨的基金，投资5-10年，它就相当于是零风险，而且你的收益将会非常可观。<br><br></p><h3 id="如何挑选基金">如何挑选基金</h3><ul><li>有10年以上历史的基金更值得购买。既然它在过去长期保持丰厚的利润，那么未来也是可以预期的。</li><li>选择大型的跨国股票基金。这种基金在全球范围内选取股票，风险比较低。</li><li>对比过去10年间，各种基金年终利润的走势图，选出最好的来投。<br><br></li></ul><h3 id="计算收益-72法则">计算收益(72法则)</h3><ul><li><strong>如何知道你投资的钱多长时间能翻一倍呢？</strong>:用 72除以一项投资的年收益率，得出的数字就是这笔钱翻一倍，所用的时间。比如，你买了一款年收益为6%的理财产品，用72除以6等于12，就是说，12年之后这笔钱就翻了一倍。</li><li><strong>一笔钱多长时间会贬值二分之一</strong>:同理，用72除以通货膨胀率，得出的数字就是这笔钱贬值到只剩一半的时间。比如，通货膨胀率是6%，那么72除以6就等于12，也就是说12年后，你的100块钱就只能买现在50块钱的东西了。对理财新手来说，72法则是一个简单好用的工具。<br><br></li></ul><h3 id="规避风险">规避风险</h3><ul><li><strong>不要把鸡蛋都放在同一个篮子里</strong>:把你手头的资金分配在不同的投资方式，而且这些投资方式的回报率之间关联性越低越好<br><br><br></li></ul><h2 id="总结"><strong>总结</strong></h2><ol><li>要牢牢树立储蓄的意识，有的理财书籍建议每个月拿出收入的50%作为储蓄，对很多人来说，这个很难做到。那不妨从10%开始，每月发了工资，立马分出10%作为储蓄，如果能按月坚持，你就迈出了财富积累的第一步。不管你目前是否负债，储蓄这件事最好都要开始做、坚持做。</li><li>要开源节流，就是要增加收入、控制消费。想要挣钱，就要为别人解决一个难题，这件事最好是你擅长的、喜欢的。有了收入，还要控制消费。因为消费通常会随着收入，水涨船高，人们甚至会超前消费，为了消费而去负债，比如，花信用卡、申请消费贷款等等。作者建议，量入为出，一定要避免不必要的消费</li><li>有了一定的储蓄，就达到了投资的门槛。投资就是要养一只会下金蛋的鹅。《小狗钱钱》建议吉娅设立一个金鹅账户，就是会下金蛋的鹅，可以按照5-4-1的原则，把每个月可支配收入的50%存入金鹅账户，用来投资，用钱生钱<br><br><br></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这本书的重点内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么攒钱？开始储蓄，迈出财富积累的第一步&lt;/li&gt;
&lt;li&gt;怎么挣钱？付出劳动，挣出第一桶金&lt;/li&gt;
&lt;li&gt;怎么用钱生钱？学会投资，养一只会下金蛋的鹅&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
      <category term="生活学习" scheme="https://hinzer.github.io/wiki/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="读书笔记" scheme="https://hinzer.github.io/wiki/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://hinzer.github.io/wiki/tags/book/"/>
    
  </entry>
  
</feed>
