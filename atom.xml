<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hinzer&#39;s Wiki</title>
  
  <subtitle>先打基础</subtitle>
  <link href="/wiki/atom.xml" rel="self"/>
  
  <link href="https://hinzer.github.io/wiki/"/>
  <updated>2020-03-29T13:19:48.000Z</updated>
  <id>https://hinzer.github.io/wiki/</id>
  
  <author>
    <name>hinzer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>00 配置开发环境</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/00%20%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/00 配置开发环境/</id>
    <published>2020-03-29T01:03:10.000Z</published>
    <updated>2020-03-29T13:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ubuntu系统环境">ubuntu系统环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:~$ uname -a</span><br><span class="line">Linux ubuntu 5.3.0-42-generic <span class="comment">#34~18.04.1-Ubuntu SMP Fri Feb 28 13:42:26 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><h3 id="配置android开发环境">配置android开发环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译所需的工具和相关库</span></span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line">sudo apt-get install -y git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libssl-dev libssl-dev openssl autoconf m4 libxml2-utils bc  libxml-simple-perl</span><br><span class="line"></span><br><span class="line"><span class="comment"># git和repo工具管理android源码</span></span><br><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:<span class="variable">$PATH</span></span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:~/bin'</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置git账信息</span></span><br><span class="line">git config --global user.name <span class="string">"xxx"</span></span><br><span class="line">git config --global user.email <span class="string">"xxxx@aaa.bb"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷写和调试工具</span></span><br><span class="line">sudo apt-get install adb -y</span><br><span class="line">sudo apt-get install fastboot -y</span><br><span class="line">sudo apt-get install android-tools-adb</span><br><span class="line">sudo apt-get install android-tools-fastboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置规则，解决无usb权限问题</span></span><br><span class="line">sudo touch /etc/udev/rules.d/70-android.rules</span><br><span class="line">sudo vim /etc/udev/rules.d/70-android.rules <span class="comment">#添加：SUBSYSTEM=="usb", MODE="0666" </span></span><br><span class="line">sudo chmod a+rx /etc/udev/rules.d/70-android.rules</span><br><span class="line">sudo service udev restart</span><br></pre></td></tr></table></figure><h3 id="下载android源码"><a href="https://source.android.com/setup/build/downloading" rel="external nofollow noopener noreferrer" target="_blank">下载android源码</a></h3><p>由于国内访问google镜像受限，推荐使用<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" rel="external nofollow noopener noreferrer" target="_blank">清华大学开源镜像站</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/<span class="built_in">source</span>/android-10</span><br><span class="line"><span class="built_in">cd</span> ~/<span class="built_in">source</span>/android-10</span><br><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r8   <span class="comment"># 拉取repo长裤，-u指定远程repo仓库url，-b指定获取特定分支branch</span></span><br><span class="line">repo sync <span class="comment"># 同步代码</span></span><br></pre></td></tr></table></figure><p>要要查看分支列表，请参<a href="https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds" rel="external nofollow noopener noreferrer" target="_blank">阅源代码标记和细分版本</a></p><h3 id="编译调试"><a href="https://source.android.com/setup/build/building#run-it" rel="external nofollow noopener noreferrer" target="_blank">编译调试</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整编源码</span></span><br><span class="line"><span class="built_in">source</span> ./build/envsetup.sh <span class="comment"># 导出所需环境变量</span></span><br><span class="line">lunch &lt;product_name&gt; <span class="comment"># 选择要编译的product</span></span><br><span class="line">make -j4 <span class="comment"># 开始编译，-j4表示使用4个线程编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行虚拟机</span></span><br><span class="line">emulator   <span class="comment"># 查看系统信息确认是我们刚刚编译的系统</span></span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/build/downloading#getting-the-files" rel="external nofollow noopener noreferrer" target="_blank">android源码公开文档 - 下载源代码</a></li><li><a href="https://source.android.com/setup/build/building" rel="external nofollow noopener noreferrer" target="_blank">android源码公开文档 - 编译系统</a></li><li><a href="http://qiushao.net/2019/11/15/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/0-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-0.开发环境准备</a></li><li><a href="http://qiushao.net/2019/11/16/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/1-Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-1.Android系统源码下载编译</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ubuntu系统环境&quot;&gt;ubuntu系统环境&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>03 系统调用</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/03%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/03 系统调用/</id>
    <published>2020-03-28T09:31:02.000Z</published>
    <updated>2020-03-29T03:23:49.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关概念">相关概念</h3><p>1、程序vs进程vs命令<br>Linux系统上所有的操作由<code>进程</code>完成，<code>进程</code>的运行是动态的，在此之前是一个静态的<code>程序</code>。用户用一个程序来启动一个进程，这个程序可以是别人写好的(最终被编译成可执行文件)，比如<code>ls</code>、<code>pwd</code>、<code>cat</code>，也可以是我们自己写的。</p><p>2、系统调用<br>无论如何，程序最后运行起来都是进程，并且一个程序想要在系统上跑，要用到<code>系统调用</code>,这是系统给用户提供的API接口。</p><p>3、strace命令<br>Linux有个命令strace，常用来跟踪进程执行时系统调用和所接收的信号。通过<code>manstrace</code>查看具体描述。</p><p>4、Glibc<br>作为一个开发者，也许平时并没有直接使用系统调用，而是Glibc库。Glibc是Linux下使用的开源的标准C库它是GNU发布的libc库。<code>Glibc</code>即系统调用的封装。</p><h3 id="介绍系统调用">介绍系统调用</h3><p>然后本文开始介绍这些系统调用，先上图<br><img src="https://static001.geekbang.org/resource/image/ff/f0/ffb6847b94cb0fd086095ac263ac4ff0.jpg" alt="系统调用"></p><p>1、进程管理<br>linux操作系统使用叫<code>fork</code>的系统调用来创建进程，进程运行过程:</p><blockquote><p>当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。按理说，如果不进行特殊的处理，父进程和子进程都按相同的程序代码进行下去，这样就没有意义了。<br>所以，我们往往会这样处理：对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过if-else语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用execve来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支（fork）了。</p></blockquote><p>其他进程都是父进程fork出来的，对于操作系统而言，系统启动的时候先创建一个所有用户进程的“祖宗进程”。</p><p>2、内存管理<br>在操作系统中，每个进程都有自己的<code>进程内存空间</code>。其中布局就有<code>代码段</code>、<code>数据段</code>、<code>堆</code>。<br>一个进程的内存空间是很大的，32位的是4G，64位的就更大了。物理空间是有限的，所以进程的空间不能事先分配好的，一定是需要的时候再分配。<br><code>brk</code>和<code>mmap</code>是官员堆分配内存的系统调用，分配内存数量比较小的时候，使用<code>brk</code>会和原来的堆的数据连在一起。当分配的内存数量比较大的时候，使用mmap，会重新划分一块区域。</p><p>3、文件管理<br>文件系统相当于公司的资料库，用于保存一些永久性质的数据。能做到长期保存，文件之所以能做到这一点，一方面是因为<code>介质</code>，另一方面是因为<code>格式</code>。<br>对于文件的操作，无非是<code>创建</code>、<code>打开</code>、<code>读</code>、<code>写</code>等等,对应的系统调用常有:</p><blockquote><p>对于已经有的文件，可以使用open打开这个文件，close关闭这个文件；<br>对于没有的文件，可以使用creat创建文件；<br>打开文件以后，可以使用lseek跳到文件的某个位置；<br>可以对文件的内容进行读写，读的系统调用是read，写是write。</p></blockquote><p><a href="https://static001.geekbang.org/resource/image/e4/df/e49b5c2a78ac09903d697126bfe6c5df.jpeg" rel="external nofollow noopener noreferrer" target="_blank">Linux中一切皆文件</a>,就包括<code>二进制文件</code>、<code>文本文件</code>、<code>stdout文件</code>、<code>Socket文件</code>、<code>设备文件</code>、<code>目录文件</code>，包括进程运行起来在<code>/proc</code>下生成的进程号也是文件。<br>对于每一个文件，Linux分配了<code>文件描述符</code>，这是一个整数。</p><p>4、信号处理<br>信号是异步处理机制，用于紧急突发情况。常见信号有</p><blockquote><p>在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；<br>如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西；<br>硬件故障，设备出了问题，当然要通知项目组；<br>用户进程通过kill函数，将一个用户信号发送给另一个进程。<br>每一种信号都有默认动作，当然用户也能编写信号处理函数，通过<code>sigaction</code>系统调用进行处理。</p></blockquote><p>5、进程间通信<br>本地进程之间实现数据的互通，比较常见的处理机制有<code>消息队列</code>和<code>共享内存</code>。</p><ul><li>通过<code>msgget</code>创建一个新的队列，<code>msgsnd</code>将消息发送到消息队列，而消息接收方可以使用<code>msgrcv</code>从队列中取消息</li><li>我们可以通过<code>shmget</code>创建一个共享内存块，通过<code>shmat</code>将共享内存映射到自己的内存空间，然后就可以读写了。</li></ul><p>6、网络通信<br>内核中有TCP/IP网络协议栈的实现，可以通过socket来实现跨系统的进程间通信。</p><h3 id="查看源码中的系统调用">查看源码中的系统调用</h3><p><a href="https://www.kernel.org/" rel="external nofollow noopener noreferrer" target="_blank">下载内核源码</a>，找到<code>./include/asm-x86_64/unistd.h</code>文件，里面对于系统调用的定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:linux-2.6.11$ head ./include/asm-x86_64/unistd.h</span><br><span class="line"><span class="comment">#ifndef _ASM_X86_64_UNISTD_H_</span></span><br><span class="line"><span class="comment">#define _ASM_X86_64_UNISTD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef __SYSCALL</span></span><br><span class="line"><span class="comment">#define __SYSCALL(a,b) </span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This file contains the system call numbers.</span><br><span class="line"> *</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://time.geekbang.org/column/article/89251" rel="external nofollow noopener noreferrer" target="_blank">趣谈Linux操作系统 - 刘超</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相关概念&quot;&gt;相关概念&lt;/h3&gt;
&lt;p&gt;1、程序vs进程vs命令&lt;br&gt;
Linux系统上所有的操作由&lt;code&gt;进程&lt;/code&gt;完成，&lt;code&gt;进程&lt;/code&gt;的运行是动态的，在此之前是一个静态的&lt;code&gt;程序&lt;/code&gt;。用户用一个程序来启动一个进程，
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>bugreport</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/logcat/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/logcat/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-29T03:38:51.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>logcat是抓log的工具，从android logging系统抓取日志。</p><p>1、logcat相关目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码位置：`/system/core/logcat/`</span><br><span class="line">编译生成的可执行文件位于：`out/target/product/umi/system/bin/logcat`(umi是产品名)</span><br><span class="line">对应到设备端的可执行文件：`/system/bin/logcat`</span><br></pre></td></tr></table></figure><p>2、日志缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">radio：查看包含无线装置/电话相关消息的缓冲区。</span><br><span class="line">events：查看已经过解译的二进制系统事件缓冲区消息。</span><br><span class="line">main：查看主日志缓冲区（默认），不包含系统和崩溃日志消息。</span><br><span class="line">system：查看系统日志缓冲区（默认）。</span><br><span class="line">crash：查看崩溃日志缓冲区（默认）。</span><br><span class="line">all：查看所有缓冲区。</span><br><span class="line">default：报告 main、system 和 crash 缓冲区。</span><br></pre></td></tr></table></figure><h3 id="使用规范">使用规范</h3><p>1、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#filteringOutput" rel="external nofollow noopener noreferrer" target="_blank">过滤日志输出</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag:priority  标记:优先级</span></span><br><span class="line">$ adb shell logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure><p>2、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#outputFormat" rel="external nofollow noopener noreferrer" target="_blank">控制日志输出格式</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v &lt;format&gt;</span></span><br><span class="line">$ adb shell logcat -v thread</span><br></pre></td></tr></table></figure><p>3、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#alternativeBuffers" rel="external nofollow noopener noreferrer" target="_blank">查看备用日志缓冲区</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -b &lt;buffer&gt;</span></span><br><span class="line">$ adb shell logcat -b radio</span><br></pre></td></tr></table></figure><h3 id="命令速查">命令速查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取help</span></span><br><span class="line">$ adb shell logcat --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查log</span></span><br><span class="line">$ adb shell logcat -b system &gt; logSystem.txt  <span class="comment">#查询此时system的日志，并且保存在logSystem.txt的文件中</span></span><br><span class="line">^C</span><br></pre></td></tr></table></figure><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">Logcat 命令行工具</a></li><li><a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=181967386" rel="external nofollow noopener noreferrer" target="_blank">Android Log机制、Logcat及MIUI 284日志介绍</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;logcat是抓log的工具，从android logging系统抓取日志。&lt;/p&gt;
&lt;p&gt;1、logcat相关目录&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Log" scheme="https://hinzer.github.io/wiki/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>理解测试用例</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/如何编写一个好的测试用例/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-29T03:38:59.625Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试用例设计过程">测试用例设计过程</h3><p>以“用户登录”功能的测试用例设计为例，画了一张图来帮你理清这些概念之间的映射关系。图中的业务需求到软件功能需求、软件功能需求到测试需求，以及测试需求到测试用例的映射关系，<br><img src="https://static001.geekbang.org/resource/image/f1/f7/f1adcc92da9091037ccc022f29911ef7.png" alt="测试用例设计过程"></p><h3 id="什么才算是“好的”测试用例？">什么才算是“好的”测试用例？</h3><p>测试用例的好坏与被测试对象的测试结果无关，好的测试用例必须具备</p><ul><li><code>整体完备性</code>： “好的”测试用例一定是一个完备的整体，是有效测试用例组成的集合，能够完全覆盖测试需求。</li><li><code>等价类划分的准确性</code>： 指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。</li><li><code>等价类集合的完备性</code>： 需要保证所有可能的边界值和边界条件都已经正确识别。</li></ul><h3 id="三种最常用的测试用例设计方法">三种最常用的测试用例设计方法</h3><p>1、等价类划分方法<br>我们只要从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖结果。<br>一个具体的例子</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生信息系统中有一个“考试成绩”的输入项，成绩的取值范围是 <span class="number">0</span>~<span class="number">100</span> 之间的整数，考试成绩及格的分数线是 <span class="number">60</span>。</span><br></pre></td></tr></table></figure><p>最终测试用例为</p><ul><li>有效等价类 1：0~59 之间的任意整数；</li><li>有效等价类 2：59~100 之间的任意整数；</li><li>无效等价类 1：小于 0 的负数；</li><li>无效等价类 2：大于 100 的整数；</li><li>无效等价类 3：0~100 之间的任何浮点数；</li><li>无效等价类 4：其他任意非数字字符。</li></ul><p>2、边界值分析方法<br>边界值分析是对等价类划分的补充，你从工程实践经验中可以发现，大量的错误发生在输入输出的边界值上，所以需要对边界值进行重点测试，通常选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。<br>我们继续看学生信息系统中“考试成绩”的例子，选取的边界值数据应该包括：<br><code>-1，0，1，59，60，61，99，100，101</code>。</p><p>3、错误推测方法<br>错误推测方法是指基于对被测试软件系统设计的理解、过往经验以及个人直觉，推测出软件可能存在的缺陷，从而有针对性地设计测试用例的方法。这个方法强调的是对被测试软件的需求理解以及设计实现的细节把握，当然还有个人的能力。</p><h3 id="如何才能设计出“好的”测试用例？">如何才能设计出“好的”测试用例？</h3><p><a href="(https://time.geekbang.org/column/article/10150)">查看原文</a></p><h3 id="总结">总结</h3><p>首先，理解测试用例是一个完备的集合，好的测试用例从原始业务需求出发进行分析设计。其次，理解三种常用的测试用例设计方法<code>等价类划分方法</code>、<code>边界值分析方法</code>、<code>边界值分析方法</code></p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/10150" rel="external nofollow noopener noreferrer" target="_blank">如何设计一个“好的”测试用例？</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;测试用例设计过程&quot;&gt;测试用例设计过程&lt;/h3&gt;
&lt;p&gt;以“用户登录”功能的测试用例设计为例，画了一张图来帮你理清这些概念之间的映射关系。图中的业务需求到软件功能需求、软件功能需求到测试需求，以及测试需求到测试用例的映射关系，&lt;br&gt;
&lt;img src=&quot;https
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="代码测试" scheme="https://hinzer.github.io/wiki/tags/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    
      <category term="笔记" scheme="https://hinzer.github.io/wiki/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>理解单元测试</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/%E7%90%86%E8%A7%A3%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/理解单元测试/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-28T00:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解概念">理解概念</h3><p>1、单元测试的概念理解</p><blockquote><p>单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类。</p></blockquote><p>一个工厂生产电视机的例子。如果把电视机的生产、测试和软件的开发、测试进行类比，你可以发现：</p><ul><li>电子元器件就像是软件中的单元，通常是函数或者类，对单个元器件的测试就像是软件测试中的<code>单元测试</code>；</li><li>组装完成的功能电路板就像是软件中的模块，对电路板的测试就像是软件中的<code>集成测试</code>；</li><li>电视机全部组装完成就像是软件完成了预发布版本，电视机全部组装完成后的开机测试就像是软件中的<code>系统测试</code>。</li></ul><p>2、单元测试对开发的好处</p><ol><li>单元测试属于最严格的软件测试手段，是最接近代码底层实现的验证手段，可以在软件开发的早期以最小的成本保证局部代码的质量。</li><li>单元测试都是以自动化的方式执行，所以在大量回归测试的场景下更能带来高收益。</li><li>单元测试的实施过程还可以帮助开发工程师改善代码的设计与实现，并能在单元测试代码里提供函数的使用示例，因为单元测试的具体表现形式就是对函数以各种不同输入参数组合进行调用，这些调用方法构成了函数的使用说明。</li></ol><h3 id="掌握方法">掌握方法</h3><blockquote><p>如何做好单元测试?你首先必须弄清楚单元测试的对象是代码，以及代码的基本特征和产生错误的原因，然后你必须掌握单元测试的基本方法和主要技术手段。<br>1、代码基本特征与产生错误的原因</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无论是开发语言还是脚本语言，都会有条件分支、循环处理和函数调用等最基本的逻辑控制，如果抛开代码需要实现的具体业务逻辑，仅看代码结构的话，你会发现所有的代码都是在对数据进行分类处理，每一次条件判定都是一次分类处理，嵌套的条件判定或者循环执行，也是在做分类处理。</span><br></pre></td></tr></table></figure><p>可见，要做到代码功能逻辑正确，必须做到分类正确并且完备无遗漏，同时每个分类的处理逻辑必须正确。而在开发实践的过程中，通常考虑从以下方面考虑</p><ul><li>如果要实现正确的功能逻辑，会有哪几种<code>正常的输入</code>；</li><li>是否有需要特殊处理的多种<code>边界输入</code>；</li><li>各种潜在<code>非法输入</code>的可能性以及如何处理。</li></ul><p>2、测试用例<br>单元测试的用例是一个<code>输入数据</code>和<code>预计输出</code>的集合。<br><strong>完整的输入数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">被测试函数的输入参数；</span><br><span class="line">被测试函数内部需要读取的全局静态变量；</span><br><span class="line">被测试函数内部需要读取的成员变量；</span><br><span class="line">函数内部调用子函数获得的数据；</span><br><span class="line">函数内部调用子函数改写的数据；</span><br><span class="line">嵌入式系统中，在中断调用时改写的数据</span><br></pre></td></tr></table></figure><p><strong>明确的预计输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">被测试函数的返回值；</span><br><span class="line">被测试函数的输出参数；</span><br><span class="line">被测试函数所改写的成员变量；</span><br><span class="line">被测试函数所改写的全局变量；</span><br><span class="line">被测试函数中进行的文件更新；</span><br><span class="line">被测试函数中进行的数据库更新；</span><br><span class="line">被测试函数中进行的消息队列更新；</span><br></pre></td></tr></table></figure><p>3、<code>驱动代码</code>，<code>桩代码</code>和<code>Mock代码</code><br><code>驱动代码</code>，<code>桩代码</code>和<code>Mock代码</code>，是单元测试中最常出现的三个名词<br><img src="https://static001.geekbang.org/resource/image/4b/2f/4b593086d9370bea9afc2d12219a0c2f.png" alt></p><ul><li><code>驱动代码</code>，指调用被测函数的代码，单元测试过程中，驱动模块通常包括调用被测函数前的数据准备、调用被测函数以及验证相关结果三个步骤。驱动代码的结构，通常由单元测试的框架决定。</li><li><code>桩代码</code>，是用来代替真实代码的临时代码。 比如，某个函数 A 的内部实现中调用了一个尚未实现的函数 B，为了对函数 A 的逻辑进行测试，那么就需要模拟一个函数 B，这个模拟的函数 B 的实现就是所谓的桩代码。</li><li><code>Mock</code>，Mock 代码和桩代码非常类似，都是用来代替真实代码的临时代码，起到隔离和补齐的作用。在使用 Mock 代码的测试中，对于结果的验证（也就是 assert），通常出现在 Mock 函数中。</li></ul><h3 id="实际流程">实际流程</h3><p>实际软件项目中开展单元测试</p><ol><li>并不是所有的代码都要进行单元测试，通常只有底层模块或者核心模块的测试中才会采用单元测试。</li><li>你需要确定单元测试框架的选型，这和开发语言直接相关。</li><li>为了能够衡量单元测试的代码覆盖率，通常你还需要引入计算代码覆盖率的工具。</li><li>最后你需要把单元测试执行、代码覆盖率统计和持续集成流水线做集成，以确保每次代码递交，都会自动触发单元测试，并在单元测试执行过程中自动统计代码覆盖率，最后以“单元测试通过率”和“代码覆盖率”为标准来决定本次代码递交是否能够被接受。</li></ol><h3 id="总结">总结</h3><p>全部笔记内容从茹炳晟的《软件测试52讲》整理。</p><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/10275" rel="external nofollow noopener noreferrer" target="_blank">什么是单元测试？如何做好单元测试？</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解概念&quot;&gt;理解概念&lt;/h3&gt;
&lt;p&gt;1、单元测试的概念理解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="代码测试" scheme="https://hinzer.github.io/wiki/tags/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    
      <category term="笔记" scheme="https://hinzer.github.io/wiki/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>bugreport</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/bugreport/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/bugreport/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-29T03:37:01.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>原生android系统支持<code>adb bugreport</code>命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误</p><p>1、目录结构</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">mi@</span>ubuntu:bugreport$ tree -L <span class="number">1</span></span><br><span class="line">.</span><br><span class="line">├── bugreport-dipper_ru-QKQ1<span class="number">.190828</span><span class="number">.002</span><span class="number">-2020</span><span class="number">-03</span><span class="number">-26</span><span class="number">-16</span><span class="number">-15</span><span class="number">-04.</span>txt  #最重要的文件</span><br><span class="line">├── dumpstate_board.txt</span><br><span class="line">├── dumpstate_log.txt</span><br><span class="line">├── FS</span><br><span class="line">├── lshal-debug</span><br><span class="line">├── main_entry.txt</span><br><span class="line">├── outfile.log</span><br><span class="line">├── proto</span><br><span class="line">└── version.txt</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">6</span> files</span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><p>1、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#anrs-deadlocks" rel="external nofollow noopener noreferrer" target="_blank">ANR和死锁</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 找出无响应的应用(系统会终止该进程并将堆栈转储到 /data/anr)</span><br><span class="line">grep &quot;am_anr&quot; bugreport-2015-10-01-18-13-48.txt  # 为二进制事件日志中的 am_anr 执行 grep 命令</span><br><span class="line">grep &quot;ANR in&quot; bugreport-2015-10-01-18-13-48.txt  # 为 logcat 日志（其中包含关于发生 ANR 时是什么在占用 CPU 的更多信息）中的 ANR in 执行 grep 命令</span><br><span class="line"></span><br><span class="line"># 查找堆栈跟踪( ANR 对应的堆栈跟踪 --&gt; 进程主线程)</span><br><span class="line">------ VM TRACES AT LAST ANR</span><br><span class="line">------ TRACES JUST NOW 和 </span><br><span class="line"></span><br><span class="line"># 查找死锁(系统服务器发生死锁，监控程序最终会将其终止)</span><br><span class="line">WATCHDOG KILLING SYSTEM PROCESS</span><br></pre></td></tr></table></figure><p>2、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#activities" rel="external nofollow noopener noreferrer" target="_blank">Activity</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看聚焦状态的activity(崩溃期间处于聚焦状态的 Activity 表示当前用户操作)</span><br><span class="line">grep &quot;am_focused_activity&quot; bugreport-2015-10-01-18-13-48.txt</span><br><span class="line"></span><br><span class="line"># 查看进程启动事件</span><br><span class="line">grep &quot;Start proc&quot; bugreport-2015-10-01-18-13-48.txt</span><br><span class="line"></span><br><span class="line"># 设备是否发生系统颠簸</span><br><span class="line">grep -e &quot;am_proc_died&quot; -e &quot;am_proc_start&quot; bugreport-2015-10-01-18-13-48.txt</span><br></pre></td></tr></table></figure><p>3、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#memory" rel="external nofollow noopener noreferrer" target="_blank">内存</a><br>4、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#broadcasts" rel="external nofollow noopener noreferrer" target="_blank">广播</a><br>5、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#monitor%20contention" rel="external nofollow noopener noreferrer" target="_blank">显示器争用</a><br>6、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#background-compilation" rel="external nofollow noopener noreferrer" target="_blank">后台编译</a><br>7、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#narrative" rel="external nofollow noopener noreferrer" target="_blank">叙述</a><br>8、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#power" rel="external nofollow noopener noreferrer" target="_blank">电源</a><br>9、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#packages" rel="external nofollow noopener noreferrer" target="_blank">程序包</a><br>10、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#processes" rel="external nofollow noopener noreferrer" target="_blank">进程</a><br>11、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#scans" rel="external nofollow noopener noreferrer" target="_blank">扫描</a></p><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://developer.android.com/studio/debug/bug-report" rel="external nofollow noopener noreferrer" target="_blank">获取并阅读错误报告</a></li><li><a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">阅读错误报告</a></li><li><a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=181967386" rel="external nofollow noopener noreferrer" target="_blank">Android Log机制、Logcat及MIUI 284日志介绍</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;原生android系统支持&lt;code&gt;adb bugreport&lt;/code&gt;命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误&lt;/p&gt;
&lt;p&gt;1、目录结构&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Log" scheme="https://hinzer.github.io/wiki/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>git fetch</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-fetch/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-fetch/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>从远程取最新的patch或者分支，引用的信息记录到<code>.git/FETCH_HEAD</code>这个文件中。可以借助<code>git fetch --help</code>查看具体描述。可以操作一个分支<code>git pull = git getch + git merge</code>，也可以单独pick一个patch<code>git fetch + git cherry-pick</code>。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### 从gerrit上取一个patch，然后pick到当前分支</span><br><span class="line">git fetch ssh:<span class="comment">//wangjianfeng1@git.mioffice.cn:29418/device/xiaomi/merlin refs/changes/17/909617/1</span></span><br><span class="line">git cherry-pick FETCH_HEAD</span><br><span class="line"></span><br><span class="line">### 获取远程库的分支更新，然后merge到本地分支</span><br><span class="line">git fetch origin master:tmp #从远程仓库master分支获取最新，在本地建立tmp分支</span><br><span class="line">git diff tmp #將當前分支和tmp進行對比</span><br><span class="line">git merge tmp #合并tmp分支到当前分支</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.cnblogs.com/qiu-Ann/p/7902855.html" rel="external nofollow noopener noreferrer" target="_blank">git fetch 和git pull 的差别</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;从远程取最新的patch或者分支，引用的信息记录到&lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;这个文件中。可以借助&lt;code&gt;git fetch --help&lt;/code&gt;查看具体描述。可以操作一个分支&lt;code&gt;git 
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>push代码</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/push%E4%BB%A3%E7%A0%81/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/push代码/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:27:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用法">用法</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wjf@ubuntu:base$ pwd</span><br><span class="line">/home/wjf/miui/umi-q/frameworks/base</span><br><span class="line">wjf@ubuntu:base$ repo info .</span><br><span class="line">Manifest branch: miui-q-umi-stable</span><br><span class="line">Manifest merge branch: refs/heads/stable</span><br><span class="line">Manifest groups: all,-notdefault</span><br><span class="line">----------------------------</span><br><span class="line">Project: platform/frameworks/base</span><br><span class="line">Mount path: /home/wjf/miui/umi-q/frameworks/base</span><br><span class="line">Current revision: miui-q-umi-stable</span><br><span class="line">Local Branches: 0</span><br><span class="line">----------------------------</span><br><span class="line">wjf@ubuntu:base$ git push ssh://wangjianfeng1@gerrit.pt.miui.com:29418/platform/frameworks/base HEAD:refs/for/miui-q-umi-stable</span><br></pre></td></tr></table></figure><ul><li><code>git push</code> git语法表示远程推送,<code>git push help</code>查看详细情况</li><li><code>ssh://wangjianfeng1@gerrit.pt.miui.com:29418/platform/frameworks/base</code>表示使用ssh协议访问gerrit服务器的29418端口，通过url定位到frameworks/base这个目录，是要推送的目录</li><li><code>HEAD:refs/for/miui-q-umi-stable</code>,HEAD指向当前的本地分支，refs/for/miui-q-umi-stable表示远程分支名。</li></ul><p><em>ps: 在修改目录下，git remote -v命令查看代码服务器的git仓库的链接，repo info .获取gerrit仓库远程提交点（分支名）</em></p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.cnblogs.com/sparkdev/p/6071533.html" rel="external nofollow noopener noreferrer" target="_blank">SSH协议语法格式</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用法&quot;&gt;用法&lt;/h3&gt;
&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>打patch</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/%E6%89%93patch/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/打patch/</id>
    <published>2020-03-28T00:24:37.000Z</published>
    <updated>2020-03-28T00:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>patch是某一次提交给文件内容的改变，打patch是将某一次改变的内容应用到当前的版本库。</p><h3 id="常规操作">常规操作</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成patch</span></span><br><span class="line">git diff <span class="string">./</span> &gt; xxx.<span class="keyword">patch</span>  <span class="comment">#将差异的内容制作成patch</span></span><br><span class="line">mkdir update &amp;&amp; git diff commit-id-time1 commit-id-time2 <span class="params">--name-only</span> | xargs -i cp '&#123;&#125;' <span class="string">./update/</span> <span class="params">--parents</span> <span class="comment">#制作patch 把两个commit-id 之间修改的文件复制到update目录中 而且会把中间的目录也一并生成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打patch</span></span><br><span class="line"><span class="keyword">patch</span> -p1 &lt; xxx.<span class="keyword">patch</span></span><br></pre></td></tr></table></figure><h3 id="另外">另外</h3><p>不过我们有线上的gerrit仓库，日常使用<code>git fetch</code> + <code>git cherry-pick</code>效果是一样的，cherry-pick直接pick某一个patch.</p><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/tf1Wyudp7l9XWM0ILAhZpQ" rel="external nofollow noopener noreferrer" target="_blank">你知道用git打补丁吗？</a></li><li><a href="https://www.git-scm.com/book/en/v2/Appendix-C%3A-Git-Commands-Patching" rel="external nofollow noopener noreferrer" target="_blank">Git Commands - Patching</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;patch是某一次提交给文件内容的改变，打patch是将某一次改变的内容应用到当前的版本库。&lt;/p&gt;
&lt;h3 id=&quot;常规操作&quot;&gt;常规操作&lt;/h3&gt;
&lt;figure class=&quot;highlight jboss-cli&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>android源码管理工具</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/android%E6%BA%90%E7%A0%81%E5%B7%A5%E5%85%B7/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/android源码工具/</id>
    <published>2020-03-27T16:11:37.000Z</published>
    <updated>2020-03-29T01:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Google使用git和repo管理AOSP源码。</p></blockquote><h3 id="概念区分">概念区分</h3><p>1、Git和git(<a href="https://source.android.com/setup/develop#git" rel="external nofollow noopener noreferrer" target="_blank">https://source.android.com/setup/develop#git</a>)<br>Git是版本控制系统，我们使用git工具进行代码仓库和分支的管理。比如我可以使用<code>git clone</code>从远程仓库的一个分支下载代码到本地，可以<code>git push</code>将本地仓库的某一个分支推送到远程仓库的分支，关于git使用可以参考<a href="https://www.git-scm.com/book/en/v2" rel="external nofollow noopener noreferrer" target="_blank">progit</a><br>Google将android源码拆分成许多个Git仓库，我们知道每一个git仓库下有<code>.git</code>文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="meta">@ubuntu</span>:android<span class="number">-10</span>$ find -name <span class="string">".git"</span></span><br><span class="line">.<span class="regexp">/developers/</span>demos/.git</span><br><span class="line">.<span class="regexp">/developers/</span>build/.git</span><br><span class="line">.<span class="regexp">/developers/</span>samples<span class="regexp">/android/</span>.git</span><br><span class="line">.<span class="regexp">/.repo/</span>repo/.git</span><br><span class="line">.<span class="regexp">/.repo/</span>manifests/.git</span><br><span class="line">.<span class="regexp">/cts/</span>.git</span><br><span class="line">.<span class="regexp">/platform_testing/</span>.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>go<span class="regexp">/linux-x86/</span>.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>go<span class="regexp">/darwin-x86/</span>.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>build-tools/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>clang<span class="regexp">/host/</span>linux-x86/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>clang<span class="regexp">/host/</span>darwin-x86/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>checkcolor/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>android-emulator/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>asuite/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>gradle-plugin/.git</span><br><span class="line">.<span class="regexp">/prebuilts/</span>manifest-merger/.git</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>2、Repo和repo(<a href="https://source.android.com/setup/develop#repo" rel="external nofollow noopener noreferrer" target="_blank">https://source.android.com/setup/develop#repo</a>)<br>然后使用一个Repo仓库对这些拆分开来的Git仓库集中起来进行管理，在源码根目录下有一个<code>.repo</code>文件，其中<code>manifest.xml</code>是一个清单文件，记录了<code>远程分支</code>、<code>本地分支</code>、<code>本地目录</code>之间对应关系。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>tree .repo -L <span class="number">1</span></span><br><span class="line">.repo</span><br><span class="line">├── manifests       <span class="comment"># 所有清单文件保存</span></span><br><span class="line">├── manifests.git</span><br><span class="line">├── manifest.xml     <span class="comment"># 重要，当前清单文件的指向！！</span></span><br><span class="line">├── project.list</span><br><span class="line">├── project-objects</span><br><span class="line">├── projects</span><br><span class="line">└── repo</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>在<code>.repo</code>目录之前，还有一个repo工具(通过它来初始化repo仓库)，这是一个python写的脚本，可以直接阅读源码(也就是可执行文件的位置)查看代码逻辑。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>whereis repo</span><br><span class="line"><span class="symbol">repo:</span> /home/hinzer/bin/repo</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>cat /home/hinzer/bin/repo</span><br></pre></td></tr></table></figure><p><em>PS: google将android源码拆分成许多个Git仓库，又通过Repo将这些拆分还原回一个android源码。像不像计算机原理中的<code>化整为零，还零为整</code>的思想？</em></p><h3 id="平时使用">平时使用</h3><p>1、Repo和Git<br>Repo 并非用来取代 Git，只是为了让您在 Android 环境中更轻松地使用 Git。一般我们使用<code>repo</code>命令建立Repo仓库，同步android源码；使用<code>git</code>命令对我们修改的其中一个模块提交。</p><p>2、Gerrit仓库<br>一个网页系统，用于代码审核，也方便查看别人提交的patch。</p><p>3、OpenGrok<br>网页系统，在线阅读源码的利器。</p><p>4、Android Studio<br>用于开发 Android 应用的官方集成开发环境 (IDE)。</p><h3 id="相关资料">相关资料</h3><blockquote><ul><li><a href="https://git-scm.com/doc" rel="external nofollow noopener noreferrer" target="_blank">Git 文档</a></li><li><a href="https://source.android.com/setup/develop/repo" rel="external nofollow noopener noreferrer" target="_blank">Repo 命令参考文档</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Google使用git和repo管理AOSP源码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概念区分&quot;&gt;概念区分&lt;/h3&gt;
&lt;p&gt;1、Git和git(&lt;a href=&quot;https://source.android.com/setup/d
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
      <category term="Repo" scheme="https://hinzer.github.io/wiki/tags/Repo/"/>
    
  </entry>
  
  <entry>
    <title>02 Linux命令</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/02%20Linux%E5%91%BD%E4%BB%A4/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/02 Linux命令/</id>
    <published>2020-03-21T14:01:02.000Z</published>
    <updated>2020-03-29T03:23:42.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，<code>运行程序</code>和<code>安装软件</code>的命令整理一下。</p></blockquote><h3 id="运行程序">运行程序</h3><p>通过命令行让Linux执行<code>程序</code>，有以下几种方式，也决定<code>进程</code>已什么方式运行。<br><strong>1、交互式运行</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>./filename  <span class="comment"># 交互式运行，Ctrl+C可以结束这个在执行的进程</span></span><br></pre></td></tr></table></figure><p><strong>2、后台方式运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脱离终端后台运行，并将log输出到xxx.outfile文件。</span></span><br><span class="line"><span class="comment"># nohup命令使终端关闭也不影响进程(进程正常是终端进程fork过来的，父进程挂起....), 2&amp;&gt;1表示将标准输出合并错误输出到xxx.outfile,&amp;设置进程后台运行</span></span><br><span class="line">$ nohup ./<span class="built_in">command</span> &gt; xxx.outfile 2&amp;&gt;1 &amp;  <span class="comment"># 后台运行进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps -ef |grep 关键字过滤出进程信息，通过awk '&#123;print $2&#125;'找出进程id，然后通过xargs命令传递给kill -9 ，最终干掉这个进程</span></span><br><span class="line">$ ps -ef |grep 关键字 |awk <span class="string">'&#123;print $2&#125;'</span>|xargs <span class="built_in">kill</span> -9 <span class="comment"># kill 这个进程的方法</span></span><br></pre></td></tr></table></figure><p><strong>3、服务方式运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  systemctl工具管理服务</span></span><br><span class="line">$ systemctl <span class="built_in">enable</span> service-name</span><br><span class="line">$ systemctl start service-name</span><br><span class="line">$ systemctl stop service-name</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p><em>现在有一个小问题</em></p><blockquote><p>Q: 后台运行的进程和服务都是可以脱离终端独立存在的，那么两者有什么区别呢？<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>A：查到<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/11027121?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">系统服务</a>的概念，总结两点区别：1、服务是系统功能的进程；进程是用户的进程。2、服务不会与用户交互，在后台默默运行(这点和后台进程一样)</p></blockquote><p><br><br></p><h3 id="安装软件">安装软件</h3><p>无论是<code>Ubuntu</code>系还是<code>CentOS</code>系的Linux发行版，总有几种安装软件的方式，<code>下载安装包</code>、<code>通过软件管家</code>、<code>直接下载压缩包</code>或者通过<code>源码编译</code>。<br><strong>1、下载安装包安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -i xxxx.deb   <span class="comment"># 如果是chentos的话，使用rpm命令</span></span><br></pre></td></tr></table></figure><p><strong>2、通过软件管家安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install xxxx    <span class="comment"># 如果是chentos的话，使用yum命令</span></span><br></pre></td></tr></table></figure><p><strong>3、下载压缩包安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=XXX/bin:PATH <span class="comment">#将可执行文件bin添加到PATH变量，可将这个命令配置在~/.bashrc文件，每次重启Linux加载这个文件</span></span><br></pre></td></tr></table></figure><p><strong>4、源码编译安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对当前环境评估，--prefix指定安装路径</span></span><br><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成安装包</span></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装软件</span></span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>引用文章中总结的图片<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzg4L2U1Lzg4NTViYjY0NWQ4ZWNjMzVjODBhYTg5Y2RlNWQxNmU1LmpwZw?x-oss-process=image/format,png" alt="Linux常用命令"></p><h3 id="课后作业">课后作业</h3><p>课后要求是安装jdk和mysql，搭建一个数据库服务。我没有去做，不过我找到一个部署的教程,很有参考意义:<br><a href="https://www.linuxprobe.com/chapter-20.html#2021_Mysql" rel="external nofollow noopener noreferrer" target="_blank">使用LNMP架构部署动态网站环境</a></p><br><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://time.geekbang.org/column/article/88761" rel="external nofollow noopener noreferrer" target="_blank">快速上手几个Linux命令：每家公司都有自己的黑话</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，&lt;code&gt;运行程序&lt;/code&gt;和&lt;code&gt;安装软件&lt;/code&gt;的命令整理一下。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>01 操作系统</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/01%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/01 操作系统/</id>
    <published>2020-03-21T12:33:10.000Z</published>
    <updated>2020-03-29T01:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色</p></blockquote><h3 id="计算机硬件组成">计算机硬件组成</h3><p>对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、硬盘、网卡…</p><p><img src="http://qiniu.benmoom.cn/01%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt="插入图片01"></p><p>但仅有硬件组成的电脑，还不能直接使用。&quot;硬件 + 操作系统&quot;才算是我们通常说的电脑，以后的学习主要围绕linux系统，这个话题展开。我们首先必须承认操作系统的重要性。</p><h3 id="想理解外包公司一样理解操作系统">想理解外包公司一样理解操作系统</h3><p>刘超老师将操作系统类比成一家外包公司。确实很形象，加深了我对linux系统的理解。<br>内核对于操作系统，相当于公司的老板，老板是不轻易干活的(一般有很多部门)，所以linux系统中也有很多子系统。对应关系有：</p><table><thead><tr><th>linux系统</th><th>外包公司</th></tr></thead><tbody><tr><td>用户</td><td>公司的客户</td></tr><tr><td>内核</td><td>公司的老板</td></tr><tr><td>系统调用</td><td>公司的办事大厅</td></tr><tr><td>设备管理系统</td><td>公司的客户对接和交付部门</td></tr><tr><td>网络管理系统</td><td>公司的对外合作部门</td></tr><tr><td>进程管理系统</td><td>公司的项目管理部门</td></tr><tr><td>内存管理系统</td><td>公司的会议室</td></tr><tr><td>文件系统系统</td><td>公司的档案室</td></tr></tbody></table><p>其他：<code>程序</code>相当于<code>项目计划书</code>，<code>进程</code>相当于<code>正在进行的项目</code>。</p><p><img src="http://qiniu.benmoom.cn/02%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpeg" alt="插入图片02"></p><h3 id="“点击QQ事件”">“点击QQ事件”</h3><p>为了更好的理解linux的运作机制，老师分析了&quot;用户点击qq&quot;事件。分为如下几个阶段</p><p><strong>阶段一：用户点击图标</strong><br>对于linux而言，驱动捕捉到用户点击事件，产生中断。cpu调用到驱动事先安排好的中断处理函数。</p><p>对于外包公司而言，对接人员记录客户提出的需求，进行项目开发的计划。</p><p><strong>阶段二：系统加载进程</strong><br>对于linux而言，将qq的程序文件从硬盘加载到内存，内存上以进程启动。这个阶段需要思考几个问题：<br>1. 硬盘上的文件如何管理？<br>2. 内存空间上的进程如何管理？<br>3. 多进程如何实现？<br>4. 进程自身如何实现功能？<br>硬件上的数据有<code>文件系统</code>进行统一管理；进程在内存空间上的映射由<code>内存管理系统</code>完成；多进程的实现通过<code>进程管理系统</code>；系统对进程提供统一的接口，实现核心功能。这层接口称为<code>系统调用层</code>。</p><p>对于外包公司而言，从档案库中取出项目计划书，成立项目组，划分会议室，完成立项的过程。然后执行项目，通过办事大厅处理业务，和各个部门打交道。这些都是动态的过程。之后就比较好理解了。</p><p><img src="http://qiniu.benmoom.cn/03linux%E5%AD%90%E7%B3%BB%E7%BB%9F.jpeg" alt="插入图片03"></p><p><strong>阶段三：进程调出对话框</strong><br>对于linux而言，进程调出显示对话框，进程-&gt;显卡驱动-&gt;显示界面</p><p>对于公司，这里显卡驱动相当于客户的交付人员，项目组通过交付人员将项目的成果交付给用户。</p><p><strong>阶段四：用户操作输入框</strong><br>用户在输入框输入，字符立即显示，键盘驱动-&gt;进程-&gt;显卡驱动-&gt;显示界面</p><p>对于公司，就是对接人员处理客户不断提出的需求–交付人员交付的过程</p><p><strong>阶段五：用户按回车发送</strong><br>对于linux系统，用户按下回车键，网络发送到远程的另一个用户，键盘驱动-&gt;进程-&gt;网卡驱动</p><p>对于公司，有时候为了实现需求，需要与其他公司的交互，通过对外合作部门。</p><h3 id="总结">总结</h3><p>以一张图片概括我对这篇文章的理解<br><img src="http://qiniu.benmoom.cn/a%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0.png" alt="插入图片-综述"></p><h3 id="课后作业">课后作业</h3><p>对于<strong>课堂练习</strong>，找出linux源码中几个子系统所在的目录（参考同学给出的答案）</p><p><strong>linux内核</strong>：<a href="https://www.kernel.org/" rel="external nofollow noopener noreferrer" target="_blank">https://www.kernel.org/</a></p><ul><li>系统调用 kernel/</li><li>进程管理 kernel/, arch/<arch>/kernel</arch></li><li>内存管理 mm/, arch/<arch>/mm</arch></li><li>文件系统 fs/</li><li>设备系统 drivers/char, drivers/block</li><li>网络系统 net/</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/88060" rel="external nofollow noopener noreferrer" target="_blank">《趣谈Linux操作系统》03章</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;计算机硬件组成&quot;&gt;计算机硬件组成&lt;/h3&gt;
&lt;p&gt;对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>git 调试</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git%E8%B0%83%E8%AF%95/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git调试/</id>
    <published>2020-03-20T01:20:14.000Z</published>
    <updated>2020-03-28T00:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念理解">概念理解</h3><p><code>git blame</code>和<code>git bisect</code>能帮助调试git项目，找到出bug的原因。</p><h3 id="操作方法">操作方法</h3><p>1、文件标注<br>使用<code>git blame</code>能显示任何文件中每行最后一次修改的提交记录。<code>git blame --help</code>查看具体描述</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">mi@</span>ubuntu:base$ git blame Android.bp -L <span class="number">230</span>,<span class="number">231</span>  #查看Android.bp的<span class="number">230</span><span class="number">-231</span>行提交记录，</span><br><span class="line">#commit id   #提交者        #时间                      #行          #内容</span><br><span class="line"><span class="number">7</span>c469179ce2a (junyulai      <span class="number">2019</span><span class="number">-01</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">23</span>:<span class="number">34</span> +<span class="number">0800</span> <span class="number">230</span>)         <span class="string">"core/java/android/net/ISocketKeepaliveCallback.aidl"</span>,</span><br><span class="line">e40eab608af2 (Benedict Wong <span class="number">2018</span><span class="number">-11</span><span class="number">-14</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">13</span> <span class="number">-0800</span> <span class="number">231</span>)         <span class="string">"core/java/android/net/ITestNetworkManager.aidl"</span>,</span><br></pre></td></tr></table></figure><p>2、二分查找<br><code>git bisect</code>能在commit区间中检出中间的patch，通过不断地二分查找，最终定位到带bug的patch</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始</span></span><br><span class="line">$ git <span class="keyword">bisect </span>start  <span class="comment"># 启动二分</span></span><br><span class="line">$ git <span class="keyword">bisect </span><span class="keyword">bad </span><span class="comment"># 当前提交有bug</span></span><br><span class="line">$ git <span class="keyword">bisect </span>good &lt;good_commit&gt;  <span class="comment">#指定已知的最后一次正常状态是哪次提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 --&gt; 二分判断</span></span><br><span class="line">$ git <span class="keyword">bisect </span>good  <span class="comment"># 当前提交无bug</span></span><br><span class="line">$ git <span class="keyword">bisect </span><span class="keyword">bad </span>  <span class="comment"># 当前提交有bug</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束</span></span><br><span class="line">$ git <span class="keyword">bisect </span>reset</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E4%BD%BF%E7%94%A8-Git-%E8%B0%83%E8%AF%95" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 使用 Git 调试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念理解&quot;&gt;概念理解&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git blame&lt;/code&gt;和&lt;code&gt;git bisect&lt;/code&gt;能帮助调试git项目，找到出bug的原因。&lt;/p&gt;
&lt;h3 id=&quot;操作方法&quot;&gt;操作方法&lt;/h3&gt;
&lt;p&gt;1、文件标注&lt;br&gt;
使用&lt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git merge失败</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/2020-03-20-bug-for-git/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/2020-03-20-bug-for-git/</id>
    <published>2020-03-19T16:11:37.000Z</published>
    <updated>2020-03-21T01:45:57.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>git merge本地分支出现报错 fatal: refusing to merge unrelated histories<br><img src="http://ww1.sinaimg.cn/large/0063ewMaly1gczozf2n8ij30vn0fognf.jpg" alt="git-merge.jpg"></p><h2 id="第一反应">第一反应</h2><p>我现在都是在本地操作还没有远程，我得理解master分支merge到slave分支，应该直接fast forward过去才对。<br>如果把master分支干掉，直接在slave分支那个位置创建一个master分支应该也没什么影响。就是特别像知道为啥会出错这个merge。</p><h2 id="问题分析">问题分析</h2><p>merge命令之后报错<code>fatal: refusing to merge unrelated histories。</code>，表示当前分支和slave分支不相关。有<a href="https://yq.aliyun.com/articles/614459" rel="external nofollow noopener noreferrer" target="_blank">对应的解决方案</a><br>加上<code>--allow-unrelated-histories</code>参数，忽略这个问题。<br>然而又报错，根据进一步提示，<code>git status</code>发现当前工作目录确实存在冲突。解决完冲突commit之后，再次merge就可以了。</p><p>不记得当时具体做了什么操作了，又重新做了几遍还是没能把当时的情景复现出来(merge直接fast forward了)。后来分析应该是某种原因导致了文件冲突，进而影响之后的merge操作。</p><h2 id="解决方法">解决方法</h2><p>如果是<code>git pull</code>或者<code>git push</code>报<code>fatal: refusing to merge unrelated histories</code>,直接在merge后加上<code>--allow-unrelated-histories</code>参数就ok了<br>如果是依然无效，不妨先<code>git status</code>查看一下当前版本库的状态有无问题(我这边是冲突引起的)。</p><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://yq.aliyun.com/articles/614459" rel="external nofollow noopener noreferrer" target="_blank">解决Git中fatal: refusing to merge unrelated histories</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;git merge本地分支出现报错 fatal: refusing to merge unrelated histories&lt;br&gt;
&lt;img src=&quot;http://ww1.sinaimg.cn/large/0063ewMa
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
      <category term="Bug" scheme="https://hinzer.github.io/wiki/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>git log</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-log/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-log/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:02.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>显示项目提交历史，通过参数选项可以控制log显示的方式。<code>git help log</code>查看具体描述。</p><p>git log 有两个高级用法：一是自定义提交的输出格式，二是过滤输出哪些提交。这两个用法合二为一，你就可以找到你项目中你需要的任何信息。</p><h3 id="使用准则">使用准则</h3><ul><li>git log允许你查看你项目历史中任何需要的内容。</li></ul><h3 id="命令速查">命令速查</h3><p>1、常规使用,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#log_options" rel="external nofollow noopener noreferrer" target="_blank">git log常用选项</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --graph --all <span class="comment">#简略显示各种分支的patch记录，个人比较下常用这个命令</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>    <span class="comment"># 显示每次提交的文件修改统计信息。</span></span><br><span class="line">git <span class="built_in">log</span> -p <span class="comment"># 按补丁格式显示每个提交引入的差异。</span></span><br></pre></td></tr></table></figure><p>2、定制化输出,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#pretty_format" rel="external nofollow noopener noreferrer" target="_blank">–pretty=format常用格式</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> --pretty=<span class="keyword">format</span>:<span class="string">"%h %s"</span> --graph</span><br><span class="line">$ git <span class="keyword">log</span> --date=<span class="keyword">format</span>:<span class="string">'%Y-%m-%d %H:%M:%S'</span> --pretty=<span class="keyword">format</span>:<span class="string">"%h-%an-%ad-%ae"</span> --graph --all</span><br></pre></td></tr></table></figure><ul><li>–date=format定制作者修订日期格式</li><li>–pretty=format定制log记录显示</li><li>–graph图形显示分支与合并历史</li><li>–all显示所有分支</li></ul><p>3、过滤出自己想要看到的log,查看<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#limit_options" rel="external nofollow noopener noreferrer" target="_blank">限制输出长度</a></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> <span class="number">-3</span>  #按次数，最近<span class="number">3</span>次提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --since=<span class="number">2.</span>weeks #按时间，最近两周提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --<span class="keyword">until</span>=<span class="number">2020</span><span class="number">-03</span><span class="number">-20</span> #按时间，<span class="number">2020</span><span class="number">-03</span><span class="number">-20</span>前的提交<span class="built-in">log</span></span><br><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --grep=<span class="string">"update"</span>#仅显示提交说明中包含<span class="string">"update"</span>的提交</span><br></pre></td></tr></table></figure><p>4、如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> --pretty=<span class="string">"%h - %s"</span> --author=<span class="string">'Junio C Hamano'</span> --since=<span class="string">"2008-10-01"</span> \</span><br><span class="line">   --before=<span class="string">"2008-11-01"</span> --<span class="keyword">no</span>-merges -- t/</span><br><span class="line"><span class="number">5610</span>e3b - Fix testcase failure <span class="keyword">when</span> extended attributes are in <span class="keyword">use</span></span><br><span class="line">acd3b9e - Enhance hold_lock_file_for<span class="number">_</span>&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic <span class="keyword">link</span> HEAD</span><br><span class="line">d1a43f2 - <span class="keyword">reset</span> --hard/<span class="keyword">read</span>-tree --<span class="keyword">reset</span> -u: remove unmerged new paths</span><br><span class="line"><span class="number">51</span>a94af - Fix <span class="string">"checkout --track -b newbranch"</span> on detached HEAD</span><br><span class="line">b0ad11e - pull: allow <span class="string">"git pull origin $something:$current_branch"</span> into an unborn branch</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" rel="external nofollow noopener noreferrer" target="_blank">Git 基础 - 查看提交历史</a></li><li><a href="https://jasonhzy.github.io/2016/05/05/git-log/" rel="external nofollow noopener noreferrer" target="_blank">Git日志格式、颜色设置</a></li><li><a href="https://blog.csdn.net/jk110333/article/details/8590746" rel="external nofollow noopener noreferrer" target="_blank">Linux下date命令，格式化输出，时间设置</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;显示项目提交历史，通过参数选项可以控制log显示的方式。&lt;code&gt;git help log&lt;/code&gt;查看具体描述。&lt;/p&gt;
&lt;p&gt;git log 有两个高级用法：一是自定义提交的输出格式，二是过滤输出哪些提交。这两个用法合二为一
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git log</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-merge/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-merge/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:21.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。<code>git help merge</code>命令查看具体描述。</p><p>将<code>topic</code>分支merge到<code>master</code>分支上(更新master分支)，使用<code>git merge topic</code></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">合并前:</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br><span class="line"><span class="comment">合并后:</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span>         <span class="comment">\</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span>--<span class="literal">-</span><span class="comment">H</span> <span class="comment">master</span></span><br></pre></td></tr></table></figure><h3 id="使用准则">使用准则</h3><ul><li>merge或者pull之前本地仓库是干净的应当commit本地，保证merge之后不会被破坏。或者<code>git stash</code>储藏本地的修改</li><li>merge冲突后可以使用<code>git status</code>查看分支状态，<code>git diff</code>显示工作区文件变化</li></ul><h3 id="命令速查">命令速查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span>   <span class="comment"># merge slave分支到当前HEAD分支， --no-ff </span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span> <span class="comment">--no-ff  # 不使用fast-forward模式，merge同时创建一个新的cmomit patch</span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">slave</span> <span class="comment">--allow-unrelated-histories   #</span></span><br><span class="line">$ git <span class="keyword">merge</span> -Xignore-<span class="keyword">space</span>-<span class="keyword">change</span> <span class="keyword">whitespace</span> <span class="comment"># 忽略空白merge</span></span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="comment">--abort # (merge失败)恢复到合并前的状态</span></span><br><span class="line">$ git <span class="keyword">merge</span> <span class="comment">--continue  # 冲突后执行</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/docs/git-merge/2.12.0" rel="external nofollow noopener noreferrer" target="_blank">git help merge</a></li><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6" rel="external nofollow noopener noreferrer" target="_blank">高级合并</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。&lt;code&gt;git help merge&lt;/code&gt;命令查看具体描述。&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;topic&lt;/code&gt;分支merge到&lt;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git rebase</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-rebase/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-rebase/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:45.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>rebase也是整合不同分支的方法，和merge不同的是它会改变提交历史。<code>git help rebase</code>命令查看具体描述。<br>假设当前HEAD指向<code>topic</code>分支，下面执行rebase命令(将topic上的patch打到master上，并改变历史)，使用<code>git rebase master</code></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">rebase前:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>--<span class="literal">-</span><span class="comment">C</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br><span class="line"><span class="comment">rebase后:</span></span><br><span class="line"><span class="comment"></span>                             <span class="comment">A'</span>--<span class="comment">B'</span>--<span class="comment">C'</span> <span class="comment">topic</span></span><br><span class="line"><span class="comment"></span>                            <span class="comment">/</span></span><br><span class="line"><span class="comment"></span>               <span class="comment">D</span>--<span class="literal">-</span><span class="comment">E</span>--<span class="literal">-</span><span class="comment">F</span>--<span class="literal">-</span><span class="comment">G</span> <span class="comment">master</span></span><br></pre></td></tr></table></figure><p>原理:首先找到这两个分支（即当前分支 topic、变基操作的目标基底分支 master 的最近共同祖先 E，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 G, 最后以此将之前另存为临时文件的修改依序应用</p><h3 id="使用准则">使用准则</h3><ul><li>rebase操作可以让提交历史更加简介，但注意不要影响远程分支的提交历史记录。不要在公共分支上使用rebase</li><li>如果你想把rebase之后的master分支推送到远程仓库，Git会阻止你这么做，因为两个分支包含冲突。但你可以传入<code>--force</code>标记来强行推送。</li><li></li></ul><h3 id="命令速查">命令速查</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase master topic #master是基底分支，将topic分支上的修改在master上重放</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git rebase --onto master<span class="built_in"> server client </span> #选中在<span class="built_in"> client </span>分支里但不在<span class="built_in"> server </span>分支里的修改，将它们在 master 分支上重放</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" rel="external nofollow noopener noreferrer" target="_blank"> Git 分支 - 变基</a></li><li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9" rel="external nofollow noopener noreferrer" target="_blank">Merge、Rebase 的选择</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;rebase也是整合不同分支的方法，和merge不同的是它会改变提交历史。&lt;code&gt;git help rebase&lt;/code&gt;命令查看具体描述。&lt;br&gt;
假设当前HEAD指向&lt;code&gt;topic&lt;/code&gt;分支，下面执行reb
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git reset、git checkout</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-reset_git-checkout/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-reset_git-checkout/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:46:59.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>1、<a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" rel="external nofollow noopener noreferrer" target="_blank">git三棵树</a>,即</p><ul><li>HEAD，永远指向当前分支的最新一笔提交</li><li>Index，索引(暂存区)</li><li>Work Directory,工作目录</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git 底层命令</span></span><br><span class="line">git cat-<span class="built_in">file</span> -p HEAD <span class="comment">#显示HEAD内容</span></span><br><span class="line">git ls-tree -r HEAD <span class="comment">#显示树对象的内容</span></span><br><span class="line">git ls-<span class="built_in">files</span> -s <span class="comment">#显示索引(Index)的所有文件信息</span></span><br><span class="line">tree <span class="comment">#查看当前工作目录</span></span><br></pre></td></tr></table></figure><p>2、git-reset<br>将当前HEAD重置为指定状态。<code>git help reset</code>命令查看具体描述。</p><h3 id="使用准则">使用准则</h3><ul><li>运行<code>git --hard reset</code>之前请考虑一下。如果由于执行这个选项导致工作目录中文件(文件已经提交)被覆盖，可以尝试<code>git reflog</code>找回。</li></ul><h3 id="命令速查">命令速查</h3><p>1、作用于某个patch</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset <span class="params">--soft</span> [<span class="keyword">patch</span>]<span class="comment">#移动HEAD的指向，不改变Index和Work Directory</span></span><br><span class="line">git reset <span class="params">--mixed</span> [<span class="keyword">patch</span>] <span class="comment">#(默认reset)移动HEAD的指向，改变Index，但不改变Work Directory</span></span><br><span class="line">git reset <span class="params">--hard</span> [<span class="keyword">patch</span>]<span class="comment">#移动HEAD的指向，改变Index和Work Directory</span></span><br></pre></td></tr></table></figure><p>2、作用于某个path/file</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> [<span class="keyword">path</span>/<span class="keyword">file</span>]<span class="comment">#通过当前HEAD指向的patch改变当前Index(恢复暂存区)</span></span><br><span class="line">git <span class="keyword">reset</span> [<span class="keyword">patch</span>] [<span class="keyword">path</span>/<span class="keyword">file</span>] <span class="comment">#通过指定patch改变当前Index</span></span><br></pre></td></tr></table></figure><p>3、压缩提交</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset <span class="params">--soft</span> [<span class="keyword">patch</span>] <span class="comment">#HEAD移动到压缩提交的前一个patch，Index和Work Directory不变</span></span><br><span class="line">git commit <span class="comment">#通过Index创建新的patch</span></span><br></pre></td></tr></table></figure><p>###git reset 和 git checkout<br>总结了两点重要的区别，</p><ul><li>操作patch时，chekcout只移动HEAD指针本身(不改变HEAD分支)</li><li>操作path/file时，checkout会改变工作目录(类似git reset --hard)</li></ul><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 重置揭密</a></li><li><a href="https://github.com/zlargon/git-tutorial/blob/master/branch/commit_tree.md" rel="external nofollow noopener noreferrer" target="_blank">多种表示patch的方式</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86&quot; rel=&quot;exter
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git revert</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-revert/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-revert/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:13.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>revert还原提交，撤销已经存在的commit的所有更改，原来的commit将保留，并用新commit来记录还原后的结果。<code>git help revert</code>命令查看具体描述。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD <span class="comment"># 撤销当前HEAD指向的patch上的更改</span></span><br><span class="line"></span><br><span class="line">git revert <span class="keyword">commit</span><span class="comment"># 撤销制定commitid表示的patch上的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge之后的revert</span></span><br><span class="line">git revert -m <span class="number">1</span> <span class="keyword">HEAD</span> <span class="comment"># HEAD指向的节点有两个父节点,-m 1保留父节点1，撤销父节点2带来的改变</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6" rel="external nofollow noopener noreferrer" target="_blank">工具 - 高级合并</a></li><li><a href="https://www.cnblogs.com/0616--ataozhijia/p/3709917.html" rel="external nofollow noopener noreferrer" target="_blank">git revert 用法</a></li><li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/2.6-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9" rel="external nofollow noopener noreferrer" target="_blank">回滚错误的修改</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;revert还原提交，撤销已经存在的commit的所有更改，原来的commit将保留，并用新commit来记录还原后的结果。&lt;code&gt;git help revert&lt;/code&gt;命令查看具体描述。&lt;/p&gt;
&lt;h3 id=&quot;使用准则&quot;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git stash、git clean</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/git-stash_git-clean/"/>
    <id>https://hinzer.github.io/wiki/技术开发/源码管理/git-stash_git-clean/</id>
    <published>2020-03-18T16:11:37.000Z</published>
    <updated>2020-03-21T01:47:29.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。或在清理(clean)文件。</p><h3 id="使用准则">使用准则</h3><p>无</p><h3 id="命令速查">命令速查</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git stash push <span class="comment"># stash跟踪文件的修改与暂存的改动</span></span><br><span class="line"><span class="variable">$</span> git stash push -<span class="literal">-keep</span><span class="literal">-index</span> <span class="comment"># --keep-index 选项使存储的同时保留索引。</span></span><br><span class="line"><span class="variable">$</span> git stash push -<span class="literal">-all</span><span class="comment"># -u 选项存储untracked文件，</span></span><br><span class="line"><span class="variable">$</span> git stash push <span class="literal">-u</span> <span class="comment"># stash全部文件(包括被忽略文件)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git stash list <span class="comment"># 列出当前的stash</span></span><br><span class="line"><span class="variable">$</span> git stash apply   <span class="comment"># 应用stash, 加上--index 选项可以让之前暂存的文件重新暂存</span></span><br><span class="line"><span class="variable">$</span> git stash drop stash<span class="selector-tag">@</span>&#123;<span class="number">0</span>&#125;<span class="comment"># 移除stash,</span></span><br><span class="line"><span class="variable">$</span> git stash pop <span class="comment"># 应用stash@&#123;0&#125;,并移除它</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git stash branch dev  <span class="comment"># 创建新分支dev，然后应用stash,然后drop stash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> git clean <span class="operator">-f</span> <span class="literal">-d</span> <span class="comment"># 移除工作目录中所有未追踪的文件以及空的子目录(不包括被忽略文件)</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-n</span> <span class="comment"># 演戏以下，加-n参数</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-n</span> <span class="literal">-x</span> <span class="comment"># -x选择清理忽略文件</span></span><br><span class="line"><span class="variable">$</span> git clean <span class="literal">-x</span> <span class="literal">-i</span> <span class="comment"># -i交互模式</span></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86" rel="external nofollow noopener noreferrer" target="_blank">Git 工具 - 贮藏与清理</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。或在清理(clean)文件。&lt;/p&gt;
&lt;h3 id=&quot;使用准则
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="https://hinzer.github.io/wiki/tags/Git/"/>
    
  </entry>
  
</feed>
