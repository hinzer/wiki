<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hinzer&#39;s Wiki</title>
  
  <subtitle>先打基础</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hinzer.github.io/"/>
  <updated>2020-03-19T16:19:55.023Z</updated>
  <id>https://hinzer.github.io/</id>
  
  <author>
    <name>hinzer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git merge失败</title>
    <link href="https://hinzer.github.io/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91-%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86-2020-03-20-bug-for-git/"/>
    <id>https://hinzer.github.io/技术开发-源码管理-2020-03-20-bug-for-git/</id>
    <published>2020-03-19T16:11:37.000Z</published>
    <updated>2020-03-19T16:19:55.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>git merge本地分支出现报错 fatal: refusing to merge unrelated histories<br><img src="http://ww1.sinaimg.cn/large/0063ewMaly1gczozf2n8ij30vn0fognf.jpg" alt="git-merge.jpg"></p><h2 id="第一反应">第一反应</h2><p>我现在都是在本地操作还没有远程，我得理解master分支merge到slave分支，应该直接fast forward过去才对。<br>如果把master分支干掉，直接在slave分支那个位置创建一个master分支应该也没什么影响。就是特别像知道为啥会出错这个merge。</p><h2 id="问题分析">问题分析</h2><p>merge命令之后报错<code>fatal: refusing to merge unrelated histories。</code>，表示当前分支和slave分支不相关。有<a href="https://yq.aliyun.com/articles/614459" rel="external nofollow noopener noreferrer" target="_blank">对应的解决方案</a><br>加上<code>--allow-unrelated-histories</code>参数，忽略这个问题。<br>然而又报错，根据进一步提示，<code>git status</code>发现当前工作目录确实存在冲突。解决完冲突commit之后，再次merge就可以了。</p><p>不记得当时具体做了什么操作了，又重新做了几遍还是没能把当时的情景复现出来(merge直接fast forward了)。后来分析应该是某种原因导致了文件冲突，进而影响之后的merge操作。</p><h2 id="解决方法">解决方法</h2><p>如果是<code>git pull</code>或者<code>git push</code>报<code>fatal: refusing to merge unrelated histories</code>,直接在merge后加上<code>--allow-unrelated-histories</code>参数就ok了<br>如果是依然无效，不妨先<code>git status</code>查看一下当前版本库的状态有无问题(我这边是冲突引起的)。</p><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://yq.aliyun.com/articles/614459" rel="external nofollow noopener noreferrer" target="_blank">解决Git中fatal: refusing to merge unrelated histories</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;git merge本地分支出现报错 fatal: refusing to merge unrelated histories&lt;br&gt;
&lt;img src=&quot;http://ww1.sinaimg.cn/large/0063ewMa
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="https://hinzer.github.io/tags/git/"/>
    
      <category term="bug" scheme="https://hinzer.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>小狗钱钱阅读笔记</title>
    <link href="https://hinzer.github.io/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/"/>
    <id>https://hinzer.github.io/生活学习-读书笔记-小狗钱钱/</id>
    <published>2020-03-16T23:42:42.000Z</published>
    <updated>2020-03-16T23:43:58.987Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这本书的重点内容：</strong></p><ol><li>怎么攒钱？开始储蓄，迈出财富积累的第一步</li><li>怎么挣钱？付出劳动，挣出第一桶金</li><li>怎么用钱生钱？学会投资，养一只会下金蛋的鹅<br><br></li></ol><h2 id="怎么攒钱？">怎么攒钱？</h2><blockquote><p>攒钱这件事要从哪开始呢？小狗钱钱说，首先要从你脑子里的想法开始。我们首先要正确地认识钱，金钱既不是万能的，也不是万恶之源，它本身没有好坏之分，只是商品流通的媒介。金钱就像一个放大镜，它只是充分展示了人性本来的样子。一个幸福的人有了钱，会更加快乐；一个悲观的人有了钱，会更加忧虑。像比尔·盖茨、扎克伯格这样的人，有了钱，会捐出巨资，帮助他人。而像伊斯兰国这样的恐怖组织，会用钱去购买武器，伤害无辜。<br>你是什么样的人？如果有了钱，你会去做什么？对我们大多数人来说，有了钱，可以提高生活质量，去实现更多的梦想。反之，越是缺钱，我们就越容易被它牵制。小狗钱钱说，吉娅的父母之所以不停地谈钱，就是因为他们的经济状况太糟糕了，好比一个人掉进水里，随时可能会被淹没。</p></blockquote><br><h3 id="梦想清单">梦想清单</h3><p>用笔写下10个你想变得富有的理由，越具体越好，然后从中挑出三个最重要的。在书里，吉娅挑出的3个理由包括，作为交换生去美国，买一台电脑，以及帮助爸妈还清债务。<br><br></p><h3 id="梦想相册">梦想相册</h3><p>那怎么制作梦想相册呢？比如，吉娅想去美国当交换生，她就在相册里贴上迪士尼乐园、自由女神像的照片。相册做完后，吉娅也没有束之高阁，而是每天都看几遍，想象自己在美国认识新的朋友，看到各种新鲜事物。这种方式让吉娅充满了攒钱的动力。<br><br></p><h3 id="梦想储蓄罐">梦想储蓄罐</h3><p>存钱可以让我们避免不必要的花费，做到量入为出。比如吉娅为了存钱，克制住了自己的欲望，没有直接用一个月的零花钱来买一张CD；而且存起来的钱，无论是放到银行还是买理财产品，都可以让你享受到复利、也就是利滚利的好处。这点非常关键。<br>在这本书里，小狗钱钱给吉娅的建议是 5-4-1原则，就是说，除了最必要的日常开销，剩余的收入分成10份，其中五份用来投资，四份放在梦想储蓄罐里，一份当作奖励自己的零花钱。哪怕你每个月日常开销以后只剩100块，也可以按照5-4-1原则来分配</p><blockquote><p>这就是让你开始攒钱的三个步骤，制作梦想清单、梦想相册和梦想储蓄罐。一旦开始储蓄，你就迈出了财富积累的第一步</p></blockquote><br><p><em><strong>PS</strong>:如果一个人出现资产负债的话，又谈何财富积累呢？</em></p><h3 id="走出负债">走出负债</h3><ol><li>停掉手中所有的信用卡</li><li>在允许范围内，尽量按照较低的分期付款数目标准来支付</li><li>边攒钱边还消费贷款</li><li>那就是每次在付款之前，都再问自己一句“这真的有必要吗？”</li></ol><p><strong>小结</strong>：以上我们着重讲了财富积累的第一步，储蓄。想要获得财富，首先我们必须牢牢树立攒钱的意识。本书为我们介绍了开始攒钱的三个步骤，制作梦想清单、梦想相册和梦想储蓄罐。同时，针对有债务困扰的人，小狗钱钱也给了我们四点忠告，分别是：停掉所有信用卡、按照较低分期付款标准支付贷款、攒钱还款两不误，以及每次花钱之前，问问自己“这真的有必要吗”。<br><br></p><h2 id="怎么挣钱？">怎么挣钱？</h2><blockquote><p>小狗钱钱先告诉吉娅要攒下零花钱，但是零花钱只有那么一点，为了实现去美国当交换生的梦想，吉娅还要攒更多的钱才行，于是她开始琢磨怎么挣钱。<br>一个12岁的小女孩能做什么呢？吉娅自己也非常茫然。这和我们大部分人的情况很像，我们都想赚钱，但怎么赚呢？</p></blockquote><h3 id="赚钱法则">赚钱法则</h3><ol><li>你得为别人解决一个难题；</li><li>你要把精力集中在你知道的、能做的和拥有的事情上。<br><em><strong>PS</strong>:做自己擅长和喜欢的事情，这件事情要给别人带来价值。</em><br><br></li></ol><h3 id="写成功日记">写成功日记</h3><p>每天花10分钟，写下你这一天的五个成果。千万别被“成功”这两个字误导了，你所记录的这些事情，不一定非得多重要，任何芝麻蒜皮的小事都可以写进去。比如，吉娅在第一次写成功日记时写道：今天我学习了挣钱的知识，攒了5马克钱，还制作了梦想相册。<br><br><br></p><h2 id="怎么理财？">怎么理财？</h2><blockquote><p>什么是“会下金蛋的鹅”呢？书里说，从前有个农夫，他养了一只鹅。有一天，他在笼子里发现了一只金蛋，于是他把这只金蛋卖了，得到了很多钱。第二天笼子里又有了一个金蛋。这样的好运持续了好几天。可是贪得无厌的农夫依然不知足，他认为这只鹅下金蛋的速度太慢了。于是，一怒之下，他把鹅劈成了两半。就这样，他的鹅死了，再也没法下金蛋了。<br>在这个故事里，“鹅”代表本金，它下的“金蛋”代表利息，用本金获取利息，也就是用钱生钱。在这个过程里，这个金蛋也被叫做是“被动收入”。就是说，你不用付出任何劳动，就能自动获得的收入，比如，银行存款的利息，出租房子的租金、出书的版税、股票的分红等等。</p></blockquote><p><em><strong>PS</strong>:&quot;被动收入&quot;是实现财务自由的关键因素</em><br><br></p><h3 id="股票与基金">股票与基金</h3><p><strong>股票</strong>:大家对股票更熟悉一点，你买了这家公司的股票，就成了它的股东，每年可以享受分红。而且，你可以在证券市场上买进或是卖出股票。当然，作者说的欧美股票市场，和我们国家的股市，在规范程度和投资回报上都有所不同，借鉴意义有限，所以我们点到为止。<br><strong>基金</strong>:基金就像一口大锅，投资者可以把自己的钱投进这口锅里，然后由基金经理人，帮大家投资买股票。你只需要付给经理人一定的佣金就行。因为基金这口锅里，有多种不同股票，里面某只股票的涨跌已经被分散稀释，所以风险比股票小，当然收益也相对比较少。但是从长期来看，找到稳定上涨的基金，投资5-10年，它就相当于是零风险，而且你的收益将会非常可观。<br><br></p><h3 id="如何挑选基金">如何挑选基金</h3><ul><li>有10年以上历史的基金更值得购买。既然它在过去长期保持丰厚的利润，那么未来也是可以预期的。</li><li>选择大型的跨国股票基金。这种基金在全球范围内选取股票，风险比较低。</li><li>对比过去10年间，各种基金年终利润的走势图，选出最好的来投。<br><br></li></ul><h3 id="计算收益-72法则">计算收益(72法则)</h3><ul><li><strong>如何知道你投资的钱多长时间能翻一倍呢？</strong>:用 72除以一项投资的年收益率，得出的数字就是这笔钱翻一倍，所用的时间。比如，你买了一款年收益为6%的理财产品，用72除以6等于12，就是说，12年之后这笔钱就翻了一倍。</li><li><strong>一笔钱多长时间会贬值二分之一</strong>:同理，用72除以通货膨胀率，得出的数字就是这笔钱贬值到只剩一半的时间。比如，通货膨胀率是6%，那么72除以6就等于12，也就是说12年后，你的100块钱就只能买现在50块钱的东西了。对理财新手来说，72法则是一个简单好用的工具。<br><br></li></ul><h3 id="规避风险">规避风险</h3><ul><li><strong>不要把鸡蛋都放在同一个篮子里</strong>:把你手头的资金分配在不同的投资方式，而且这些投资方式的回报率之间关联性越低越好<br><br><br></li></ul><h2 id="总结"><strong>总结</strong></h2><ol><li>要牢牢树立储蓄的意识，有的理财书籍建议每个月拿出收入的50%作为储蓄，对很多人来说，这个很难做到。那不妨从10%开始，每月发了工资，立马分出10%作为储蓄，如果能按月坚持，你就迈出了财富积累的第一步。不管你目前是否负债，储蓄这件事最好都要开始做、坚持做。</li><li>要开源节流，就是要增加收入、控制消费。想要挣钱，就要为别人解决一个难题，这件事最好是你擅长的、喜欢的。有了收入，还要控制消费。因为消费通常会随着收入，水涨船高，人们甚至会超前消费，为了消费而去负债，比如，花信用卡、申请消费贷款等等。作者建议，量入为出，一定要避免不必要的消费</li><li>有了一定的储蓄，就达到了投资的门槛。投资就是要养一只会下金蛋的鹅。《小狗钱钱》建议吉娅设立一个金鹅账户，就是会下金蛋的鹅，可以按照5-4-1的原则，把每个月可支配收入的50%存入金鹅账户，用来投资，用钱生钱<br><br><br></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这本书的重点内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么攒钱？开始储蓄，迈出财富积累的第一步&lt;/li&gt;
&lt;li&gt;怎么挣钱？付出劳动，挣出第一桶金&lt;/li&gt;
&lt;li&gt;怎么用钱生钱？学会投资，养一只会下金蛋的鹅&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
      <category term="生活学习" scheme="https://hinzer.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="读书笔记" scheme="https://hinzer.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://hinzer.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>ctags基本用法</title>
    <link href="https://hinzer.github.io/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-ctags/"/>
    <id>https://hinzer.github.io/技术开发-开发工具-ctags/</id>
    <published>2020-03-15T23:46:33.000Z</published>
    <updated>2020-03-17T17:10:50.248Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ctags是方便阅读源代码的工具。开发者在linux平台下和vim编辑器配合使用,这种策略经常被用于linux源码阅读。</p></blockquote><h2 id="开发环境">开发环境</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu18<span class="number">.04</span></span><br><span class="line"><span class="symbol">hinzer@</span>ubuntu:~$ uname -a</span><br><span class="line">Linux ubuntu <span class="number">5.3</span><span class="number">.0</span><span class="number">-40</span>-generic #<span class="number">32</span>~<span class="number">18.04</span><span class="number">.1</span>-Ubuntu SMP Mon Feb <span class="number">3</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">59</span> UTC <span class="number">2020</span> x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>关于2.6.11版本的kernel源码下载</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:source</span><span class="variable">$ </span>wget -O kernel <span class="symbol">https:</span>/<span class="regexp">/mirrors.edge.kernel.org/pub</span><span class="regexp">/linux/kernel</span><span class="regexp">/v2.6/linux</span><span class="number">-2.6</span>.<span class="number">11</span>.tar.gz</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:source</span><span class="variable">$ </span>tar -xzvf kernel.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装">安装</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install ctags -y</span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><ol><li>在当前目录下生成索引文件</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:source</span><span class="variable">$ </span>cd linux<span class="number">-2.6</span>.<span class="number">11</span>/</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:linux-</span><span class="number">2.6</span>.<span class="number">11</span><span class="variable">$ </span>ctags -R .<span class="comment">#生成索引tags</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>sudo vim /etc/vim/vimrc</code>配置vim</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>sudo vim ~<span class="regexp">/.vimrc #添加 set tags=/home</span><span class="regexp">/hinzer/source</span><span class="regexp">/linux-2.6.11/tags</span>;</span><br></pre></td></tr></table></figure><h2 id="使用演示">使用演示</h2><ol><li>命令行索引tag</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:linux-</span><span class="number">2.6</span>.<span class="number">11</span><span class="variable">$ </span>ctags -R .<span class="comment">#生成索引tags</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:linux-</span><span class="number">2.6</span>.<span class="number">11</span><span class="variable">$ </span>ll tags</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:linux-</span><span class="number">2.6</span>.<span class="number">11</span><span class="variable">$ </span>vim -t main  <span class="comment">#查找main函数</span></span><br></pre></td></tr></table></figure><ol start="2"><li>vim中使用ctags命令</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:ts</span>  <span class="comment">#tagslist,列出索引list</span></span><br><span class="line"><span class="symbol">:tp</span> <span class="comment">#tagspreview 上一个tag</span></span><br><span class="line"><span class="symbol">:tn</span> <span class="comment">#tagsnext 下一个tag</span></span><br><span class="line">Ctrl+ ] <span class="comment">#通过光标位置 跳转到定义处</span></span><br><span class="line">Ctrl+ T <span class="comment">#返回上一步的光标位置</span></span><br></pre></td></tr></table></figure><br><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://baike.baidu.com/item/ctags/3470337" rel="external nofollow noopener noreferrer" target="_blank">百度百科ctags</a></li><li><a href="www.kernel.org">linux kernel</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ctags是方便阅读源代码的工具。开发者在linux平台下和vim编辑器配合使用,这种策略经常被用于linux源码阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开发环境&quot;&gt;开发环境&lt;/h2&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="开发工具" scheme="https://hinzer.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ctags" scheme="https://hinzer.github.io/tags/ctags/"/>
    
  </entry>
  
  <entry>
    <title>Welcome hinzer&#39;s Wiki Site</title>
    <link href="https://hinzer.github.io/index/"/>
    <id>https://hinzer.github.io/index/</id>
    <published>2020-03-14T17:55:57.000Z</published>
    <updated>2020-03-16T16:07:08.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于wiki">关于wiki</h2><p>知识是自己构建的，不是搬运来的。建立个人wiki的目的是将此作为一个知识整理的平台，虽然<a href="https://zh.wikipedia.org/wiki/Wiki" rel="external nofollow noopener noreferrer" target="_blank">维基百科</a>已经足够好了，但终究不是自己的，希望能建立自己的知识库(也可以理解为对已有知识的二次整理)。</p><p>万丈高楼平地起，起步阶段咱也不需要写的多好，随着理解的慢慢深入，自然能写出高水准的wiki。</p><p>这是一个基于<a href="https://hexo.io/zh-cn/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>框架的Wiki系统，Hexo是开源框架同时也支持很多主题，这里就采用了Wikitten的主题样式。然而我不关心这个，当然也不擅长这个(大佬们做好的轮子，拿来用就好了)。</p><h2 id="组织结构">组织结构</h2><p>先将wiki列表简单分几个大类</p><ol><li><p>技术开发<br>非核心技术，仅要求了解即可，方便以后随时查询。涉及面应该广一些，包括但不仅限于: 工程规范、开发工具、源码管理、测试方法。</p></li><li><p>计算机基础<br>核心技术，需要长期学习和理解的领域，掌握程度高一些。并不奢求一次就能写的多好，要求有更深的理解了，回来补充和修正。至少包括: 开发平台、常用算法、数据结构。</p></li><li><p>生活学习<br>其他方向归于这个分类</p></li></ol><h2 id="部署指南">部署指南</h2><p><a href="https://hexo.io/zh-cn/docs/" rel="external nofollow noopener noreferrer" target="_blank">Hexo 官方文档</a><br><a href="https://github.com/zthxxx/Wiki-site" rel="external nofollow noopener noreferrer" target="_blank">zthxxx wiki源码</a><br><a href="https://wikitten.vizuina.com/" rel="external nofollow noopener noreferrer" target="_blank">Wikitten 主题地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于wiki&quot;&gt;关于wiki&lt;/h2&gt;
&lt;p&gt;知识是自己构建的，不是搬运来的。建立个人wiki的目的是将此作为一个知识整理的平台，虽然&lt;a href=&quot;https://zh.wikipedia.org/wiki/Wiki&quot; rel=&quot;external nofoll
      
    
    </summary>
    
    
      <category term="wiki" scheme="https://hinzer.github.io/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>年度总结</title>
    <link href="https://hinzer.github.io/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://hinzer.github.io/生活学习-随笔记录-年度总结/</id>
    <published>2019-12-31T15:59:19.000Z</published>
    <updated>2020-03-16T23:21:23.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019年又要到底了，有必要写一个总结，看看过去的一年时间了干了些什么。。另，不知怎么，发现最近变得有些懒散，希望能重拾写作这个习惯。不管怎样，这不是一篇对自我批判或者激励自我的文章，总结记录，仅此而已。</p></blockquote><p>今年跨年在看罗胖演讲时间的朋友，最多听到的是<code>网络</code>、<code>连接</code>、<code>点亮</code>这些字眼，无论是个人、行业、国家，都在积极地对外输出自己的价值(连接)，塑造自己的品牌影响力(网络)。今后是网络化的时代。<br>对于我而言，如何和别人建立好的<code>连接</code>，结出自己的<code>网络</code>，可能需要想搞清楚几个问题：</p><ul><li>我是谁？</li><li>我干啥？</li><li>我为谁干？</li><li>别人需要我么？</li><li>社会更好了么？<br>这些问题我想留给下年，下一个年终总结。</li></ul><h2 id="过去的2019">过去的2019</h2><p>过去一年里发生了很多&quot;第一次&quot;，第一次去了杭州合肥这些城市、第一次写年终总结、第一次找工作的过程，经历了社招和校招，也体验过电话面试、现场面试和网络面试，如今第一次实习。</p><p><strong>求职</strong><br>这一年，我最大的期望就是找一份好的工作。在这个过程中，我发现有很多优秀的人、优秀的平台，通过他们的故事和分享，收获了很多实用的建议。</p><ul><li>经过2018年，我已经把之前报的嵌入式的课程学的差不多了，随后又补习了Python，3月份左右去考试拿了一个二级证书。</li><li>有了找实习的意识，也经历过很多面试。最后有拿到几个实习offer，最后学校没给批，自己也没过于坚持，就没去成。</li><li>通过博客认识了几个有意思的小伙伴，有职场人，也有在校同学，收获了很多有用的建议</li><li>开始关注牛客网，后来认识了谱哥。这时大三也快结束了，后来找工作的打法也是从谱哥那里学习的。现在已签的offer也是在牛客上找的。</li><li>好朋友强哥参加比赛，晋级北京总决赛，团队人员替换，我跟着强哥去北京待了一周，确实是长见识了。</li><li>暑假留校学习，完善自己的技术栈。刷剑指offer、网上找内推、投简历，这样坚持一个月。可能感到这样闷头学习没有意思，想出去面试一下，想着以后也要在家乡发展，我订一张火车票就回安徽。在合肥、杭州这些地方转悠一圈，面了十多家公司，有大有小，大多给了offer。这是我今年最正确的决定，后来的面试也有了一定的底气。</li><li>开学回到学校，这时发现我是班中唯一一个拿到offer的人，心中一阵窃喜。。后来参加一次网络面试，也就是我现在这家。再后来秋招正式开始也都没怎么参加。</li><li>拿到满意offer后，报名了驾考，过了科目一和科目二。</li></ul><p><strong>生活</strong><br>其实在大多时间还是宅在屋里，时间久了，养成一个孤僻的性格，现在多多少少有些抵触与外界的接触。</p><ul><li>这一年记录了77篇博客，大多是技术相关的，生活记录有些少了。</li><li>办了一张半年的健身卡，坚持每周4天，30min左右活动时间。每次健身之后可以获得身心愉悦，确实不错。</li><li>寒假和暑假的时间挺长，真正在家里没过多久。感觉在家里闲不住，想着以后就没有寒暑假了，应该多陪陪家人。</li><li>大学里的同学，同一专业的还认识一些。高中同学现在还能常保持联系的也就两个。很多以前关系还不错的朋友，不怎么联络，关系也就慢慢疏远了。</li><li>来到东北之后也很少出去走走，对校园之外的世界接触太少。貌似从大三之后就比较宅了，现在实习了。</li></ul><h2 id="对现状的思考">对现状的思考</h2><p>大四学生，目前在北京实习，内容是android系统适配，实习还算轻松，但职场上不能很好的适应，仍感到些许压力。</p><p><strong>入职</strong><br>第一次走出校门，进入职场。那天正好是双11，有一个多月了。现在对工作上需要哪些技术，基本上有一个了解。当然还有诸多问题，对自己定位不清晰、目前还没有一个明确的职业规划、所在岗位注重哪些能力，如何针对性的培养等等</p><p><strong>性格</strong><br>或许是出于小时候的成长环境的原因，养成了一个内向的性格。后来，进入大学后，也或许是内向的性格让我选择了学习技术(也可能因为兴趣，但那是之后的事情了),渐渐不与人交流，越来越不善表达了。我始终觉得自己和那些在大学里整天待在宿舍打游戏为了逃避学业，或者整天考研为了逃避就业没什么两样，多少有点逃避的意思。<br>幸运的是我在学习技术的过程中，有段时间真的体验到了乐趣；不幸的是，社交与沟通能力成为了我最大的短板，比较头疼。<br>求职找工作那段时间，我感觉比较&quot;充实&quot;,因为当时体会到以前学过的那些知识、技能给我带来的价值。后来进入职场，暴露出自己的社交能力的短板，确实比较难受。</p><p><strong>反省</strong><br>人的本性是在成功时寻找内因，失败了寻找外因。特别是在没有什么可以值得炫耀的时候，总是拒绝面对现实，拒绝反省自己。<br>其实经历的每一件事都是一次成长的机会，通过总结记录的方式，反思和审视自己。<br>我是一个&quot;懒人&quot;，平时很少思考，更不愿意去主动总结。大概原因归纳如下：</p><ol><li>对事情的理解往往只流于表面，没有深入的理解，也常常感到没有什么值得去写的东西</li><li>每次写作的过程中，往往&quot;咬文爵字&quot;，浪费很长时间，会感觉投入产出不成正比</li><li>总想利用大块时间一次性写完，但往往没有这种时间，要么贪玩，或者去做别的事情了</li></ol><p>针对上面问题的反省，我需要：</p><ol><li>最重要的一点，不要搞错总结的目的。总结是给自己看的，每次总结都能提炼出一些有用的东西，这就是总结的价值。</li><li>相信持续写下去，文字表述能力自然会提高上去。</li><li>养成提问和记录的习惯之后，随时记录考虑的问题，形成主题列表。确定要写的主题，先立大纲，拆分每个部分到碎片时间去实现，利用周末时间拼接起来。</li></ol><h2 id="即将到来的2020">即将到来的2020</h2><p>期望未来自己，可以协调好学习、工作、生活三者，让生活更加充实。</p><p><strong>期望改掉的毛病</strong></p><ul><li>[ ] 熬夜</li><li>[ ] 懒</li><li>[ ] 不善于表达，通常显得冷静而无情</li></ul><p><strong>期望养成的习惯</strong></p><ul><li>[ ] 早睡早起</li><li>[ ] 多进行思考总结，主要方式是记录，经常写日志进行日常总结、写博客进行工作总结</li><li>[ ] 必须直接地表达出对他人的欣赏，而不是仅仅保留在内心</li><li>[ ] 主动去联系老朋友，至少一个月联系一次嘛</li></ul><p><strong>期望达成的目标</strong></p><ul><li>[ ] 作息时间 5:10(早)~11:30(晚)</li><li>[ ] 持续写博客 每周至少产出一篇</li><li>[ ] 开始接触金融学 投资、理财、保险…</li><li>[ ] 多读一些心理学的书，多了解自己</li><li>[ ] 坚持健身(久坐生病，需要适当运动)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2019年又要到底了，有必要写一个总结，看看过去的一年时间了干了些什么。。另，不知怎么，发现最近变得有些懒散，希望能重拾写作这个习惯。不管怎样，这不是一篇对自我批判或者激励自我的文章，总结记录，仅此而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="生活学习" scheme="https://hinzer.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="随笔记录" scheme="https://hinzer.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="2019" scheme="https://hinzer.github.io/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>github搜索开源项目</title>
    <link href="https://hinzer.github.io/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91-%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86-github%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hinzer.github.io/技术开发-源码管理-github搜索开源项目/</id>
    <published>2019-12-29T11:40:58.000Z</published>
    <updated>2020-03-20T13:59:14.808Z</updated>
    
    <content type="html"><![CDATA[<p>1、<strong>从名字中搜关键词</strong><br>in:name example</p><p>2、<strong>搜索readme文件</strong><br>in:readme example</p><p>3、<strong>描述中搜索关键词</strong><br>in:description example</p><p>4、<strong>追加限定条件</strong><br>stars:&gt;3000  # 限定在stars数量大于3000的项目<br>fork:&gt;50# fork 数量<br>pushed:&gt;2019-09-10# 最后一次push的时间<br>language:java   # 限定语言</p><br><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://help.github.com/cn/github/searching-for-information-on-github" rel="external nofollow noopener noreferrer" target="_blank">github官方文档-搜索</a></li><li><a href="https://www.bilibili.com/video/av75587104" rel="external nofollow noopener noreferrer" target="_blank">如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、&lt;strong&gt;从名字中搜关键词&lt;/strong&gt;&lt;br&gt;
in:name example&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;搜索readme文件&lt;/strong&gt;&lt;br&gt;
in:readme example&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;描述中搜索关键词&lt;/str
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="源码管理" scheme="https://hinzer.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="github" scheme="https://hinzer.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>「转」详谈typedef的用法</title>
    <link href="https://hinzer.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-typedef%E7%90%86%E8%A7%A3/"/>
    <id>https://hinzer.github.io/计算机基础知识-编程语言-typedef理解/</id>
    <published>2019-10-09T23:42:21.000Z</published>
    <updated>2020-03-17T15:13:32.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们都知道typedef是类型重定义，既然是重定义就不可能出现新的数据类型，只是将已有的数据类型进行换个名字而已，但是这有什么用呢？</p></blockquote><br><p>可能我们学的时候，给的例子都是：typedef int INT; 然后再用INT去定义一些变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT;</span><br><span class="line">INT a;</span><br></pre></td></tr></table></figure><p>这个就等于int a; 我们当时感觉不出来有什么用，当学到结构体的时候，可能觉得会减少数据类型的写法，像<code>struct student</code>这样一个结构体定义变量的时候如果不用typedef就只能<code>struct student</code>(当然这是在C语言中，在C++中可以省略掉struct直接写student)，这样感觉很麻烦，所以才想到用typedef，但是这是他的用法之一，却不是为唯一的用法。</p><p><br><br><br>typedef的用法主要我总结了一下三点：</p><h2 id="用法一">用法一</h2><p><code>可以减少代码的书写量</code>,就像我们经常能考虑到的，结构体这样“新的”数据类型，用typedef可以简化，而且不容易出错.例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们定义学生结构体的时候要这么定义<code>struct student s1,s2,s3; </code>如果想定义结构体指针，我们可以这么定义,<code>struct student *ps1, ps2; </code>显然ps2不是指针类型，但是好多初学者对指针不熟悉，所以容易出错，但是当我们用typedef的时候，就不会出现这样的错误了，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125;stu, *pstu;</span><br></pre></td></tr></table></figure><p>我们定义的时候可以这么定义<code>stu s1, s2, s3;</code> 定义结构体指针的时候，可以这么定义,<code>pstu ps1, ps2;</code> 这样ps1， ps2都是指针类型的变量 这是typedef的用法之一，也是比较常用的。<br><br></p><h2 id="用法二">用法二</h2><p><code>实现代码的复用性和可扩展性</code>,如果一段代码没有扩展性和复用性，那么这段代码就不能算得上是一段特别规范的代码，就像我们为了实现代码的复用性，提高程序可读性的时候，用函数一样，提高代码的复用性和可扩展性是作为软件开发者必备的本领。一段好的代码，如果在别的项目中引用的话，如果功能类似，基本上改不了几行，这就是规范性的重要性(这里先不谈规范性，但是这个typedef的用法也涉及规范性，嘿嘿，所以规范是避免不了的)。就这么来说吧，假如我们定义了一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们想把成绩改成double类型的，应为int的精度太低了，但是下面用到的地方可能都要改掉，但是，我们要是用typedef一下， 问题就变得简单多了，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> typeitem；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"></span><br><span class="line">　　typeitem score;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样直接改typedef就行了，其他的代码根本不用动，这就是<code>分层</code>的原因，我们只改变最底层的，上层的东西根本不用变（就像在链表中，我们可以把它分为三层，纯数据层、节点层、head指针层，也就是整条链)这样分层处理问题会变得简单得多。还有就是平台不同可以兼容，就像有的平台不支持long double类型，但是你如果定义了long double 直接不能用，但是如果这么  typedef long double typeitem； 直接改成可以支持的类型就行啦，根本不用那么麻烦改下面的代码，这也是比较重要的用途。</p><h2 id="用法三">用法三</h2><p><em><code>简化，提高可读性</code>。想必大家觉得，这个用途不是包含在上面的用途之中了吗，为什么还要再说一遍呢，其实我举个例子你也就明白了，<code>typedef int array[10];</code>，这个代表什么意思，这可不是平时那种array[10]是个int了吧，这个代表，array是个重定义的类型，<code>array a；</code>就代表a是一个含有10个int型元素的数组，这么定义可能觉得简化不了多少，还不如直接int a[10];<br>看着明白呢，好! 继续往下看,<code>typedef array Array[5];</code> 这个呢，如果我这么定义一个变量 <code>Array arr[2]; </code>这个又是什么意思呢？这个就是定义个Array类型数组，其中这个“一维”数组有两个元素，但是每个元素又都是Array 类型的，每个Array又是一个5行10列二维数组，所以arr就是一个三维数组，他就等于<code>int arr[2][5][10];</code> 是不是看的有点蒙了， 其实在C语言中根本不存在多维数组，全部都是一维数组，只是一维数组里面又含一维数组，所以才构成了所谓的“多维”数组， 如果这样理解的话，是不是觉得多维数组也就不那么“神奇”了，变得简单了，没有那么晕了，这样定义的好处就是可以讲一个多维的数组转化成我们比较熟悉的一维数组，这样操作起来就比较容易了，可读性自然也会增强。所以这就是他的“简化”的作用。<br>其实我们还可以在函数指针上体现，想定义个函数指针<code>int (*p)();</code> 我们可以定义为<code>typedef int (*POWER)();</code> 接下来可以直接定义<code>POWER p1, p2; </code>他就等价于<code>int (*p1)(), int (*p2)(); </code>这样也非常易懂。</em><br><br></p><h2 id="定义方法">定义方法</h2><p>下面来谈一下他的定义过程，说了这么多，还没讲到怎么定义，其实也就三步:</p><ul><li><strong>第一步:</strong> 按照定义变量的方法先写出定义体(想必这么都比较熟悉吧), 例如: int a;</li><li><strong>第二步:</strong> 将变量名换成想要重定义的名字 例如: int INT;</li><li><strong>第三步:</strong> 在最前面加上typedef 例如: typedef int INT;<br>整个步骤就完成了，下面就可以用重定义的类型定义变量了:例如: INT a; 就是这么简单，不要想那么复杂。<br><br></li></ul><h2 id="与宏定义">与宏定义</h2><p>还有就是与宏定义区分开来，宏定义是在编译预处理的时候直接进行的替换，而typedef却不是，宏定义特别是写那个表达式的时候新手容易出错就是不能真正理解宏替换，就像这么例子: #define mul(a, b) a * b ，如果这么写mul(2, 3)那么恭喜，你对了， 但是如果这么写， mul(2 + 1, 3 + 4); 你的出来的结果一定是错的，它只是简单地替换， 不会像函数那样会先计算出来2 + 1 等于 3 然后在进行计算， 它只能替换为2 + 1 * 3 + 4 所以结果当然错了……新手注意点就好了，这东西挺简单的。<br><br></p><p>大致就将这么多，如果那里写的不好，多多指教，多多补充！</p><br><p>转载于：<a href="https://www.cnblogs.com/Howe-Young/p/3931678.html" rel="external nofollow noopener noreferrer" target="_blank">Howe_Young</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们都知道typedef是类型重定义，既然是重定义就不可能出现新的数据类型，只是将已有的数据类型进行换个名字而已，但是这有什么用呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
&lt;p&gt;可能我们学的时候，给的例子都是：typedef int INT
      
    
    </summary>
    
      <category term="计算机基础知识" scheme="https://hinzer.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="编程语言" scheme="https://hinzer.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="typedef" scheme="https://hinzer.github.io/tags/typedef/"/>
    
      <category term="C" scheme="https://hinzer.github.io/tags/C/"/>
    
  </entry>
  
</feed>
