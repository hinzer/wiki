<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hinzer&#39;s Wiki</title>
  
  <subtitle>先打基础</subtitle>
  <link href="/wiki/atom.xml" rel="self"/>
  
  <link href="https://hinzer.github.io/wiki/"/>
  <updated>2020-04-18T22:22:26.388Z</updated>
  <id>https://hinzer.github.io/wiki/</id>
  
  <author>
    <name>hinzer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>11 进程用户栈和内核栈</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/11%20%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E6%A0%88%E5%92%8C%E5%86%85%E6%A0%B8%E6%A0%88/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/11 进程用户栈和内核栈/</id>
    <published>2020-04-18T22:21:14.654Z</published>
    <updated>2020-04-18T22:22:26.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍-目的">介绍&amp;目的</h3><p>1、 介绍<br>在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。无论是进程还是线程，对应到内核里面，我们统一都叫任务（Task），由一个统一的结构 task_struct 进行管理。<br>其中，内核栈是和进程运行有关系的。相关的成员变量有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>    <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="keyword">void</span>  *<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure><p>嗯，先上图<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzgyLzVjLzgyYmE2NjNhYWQ0ZjZiZDk0NmQ0ODQyNDE5NmU1MTVjLmpwZWc?x-oss-process=image/format,png" alt></p><p>2、 目的<br>以下整理的资料大致包括</p><ul><li>用户态函数栈，内核态函数栈栈的组成</li><li>进程从用户态到内核态的上下文切换</li><li>内核态中通过stask_struct管理内核栈</li></ul><h3 id="用户态函数栈">用户态函数栈</h3><p>在数据结构中学过的栈模型，是一种高度抽象的设计。函数调用和返回也是按照栈的思想来设计的，在虚拟内存空间中自上而下分配。具体在32系统和64系统的实现方式，略微不同<br><strong>1、 32位系统</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlL2FlLzJlL2FlYzg2NWFiY2NmMDMwODE1NWY0MTM4Y2M5MDU5NzJlLmpwZw?x-oss-process=image/format,png" alt></p><blockquote><p>我们先来看 32 位操作系统的情况。在 CPU 里，ESP（Extended Stack Pointer）是栈顶指针寄存器，入栈操作 Push 和出栈操作 Pop 指令，会自动调整 ESP 的值。另外有一个寄存器 EBP（Extended Base Pointer），是栈基地址指针寄存器，指向当前栈帧的最底部。<br>.<br>例如，A 调用 B，A 的栈里面包含 A 函数的局部变量，然后是调用 B 的时候要传给它的参数，然后返回 A 的地址，这个地址也应该入栈，这就形成了 A 的栈帧。接下来就是 B 的栈帧部分了，先保存的是 A 栈帧的栈底位置，也就是 EBP。因为在 B 函数里面获取 A 传进来的参数，就是通过这个指针获取的，接下来保存的是 B 的局部变量等等。<br>.<br>当 B 返回的时候，返回值会保存在 EAX 寄存器中，从栈中弹出返回地址，将指令跳转回去，参数也从栈中弹出，然后继续执行 A。</p></blockquote><p><strong>2、 64位系统</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzc3L2MwLzc3MGIwMDM2YThiMjY5NTQ2M2NkOTU4NjlmNWFkZWMwLmpwZw?x-oss-process=image/format,png" alt></p><blockquote><p>64 位操作系统的寄存器数目比较多。rax 用于保存函数调用的返回结果。栈顶指针寄存器变成了 rsp，指向栈顶位置。堆栈的 Pop 和 Push 操作会自动调整 rsp，栈基指针寄存器变成了 rbp，指向当前栈帧的起始位置。<br>.<br>改变比较多的是参数传递。rdi、rsi、rdx、rcx、r8、r9 这 6 个寄存器，用于传递存储函数调用时的 6 个参数。如果超过 6 的时候，还是需要放到栈里面。<br>.<br>然而，前 6 个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的。</p></blockquote><h3 id="内核态函数栈">内核态函数栈</h3><p><strong>0、 函数栈模型</strong><br>进程通过函数调用进入内核态，内核中也有函数调用，也有一个内核栈。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzMxLzJkLzMxZDE1YmNkMmEwNTMyMzViNTU5MDk3N2QxMmZmYTJkLmpwZWc?x-oss-process=image/format,png" alt></p><p><em>ps: 在<code>arch/x86/include/asm/page_32_types.h</code>或者<code>arch/x86/include/asm/page_64_types.h</code>定义了内核栈大小<code>THREAD_SIZE</code>。</em></p><ul><li>thread_info结构是对 task_struct 结构的补充，往往与体系结构有关的，都放在 thread_info 里面。</li><li>在内核代码里面有这样一个 union，将 thread_info 和 stack 放在一起，在<code>include/linux/sched.h</code>文件中就有。</li><li>pt_regs结构，在系统从用户态切换到内核态的时候，将用户态上下文信息保存到这里。在32系统和64系统中的定义不一样。</li></ul><p><strong>1、 通过 task_struct 找内核栈</strong></p><p><strong>2、 通过内核栈找 task_struct</strong></p><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/93014" rel="external nofollow noopener noreferrer" target="_blank">极客时间专栏 - 进程数据结构（下）：项目多了就需要项目管理系统</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍-目的&quot;&gt;介绍&amp;amp;目的&lt;/h3&gt;
&lt;p&gt;1、 介绍&lt;br&gt;
在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。无论是进程还是线程，对应到内核里面，我们统一都叫任务（Task），由一个统一的结构 task_struct 进行管理。&lt;br&gt;
其中
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>10 进程数据结构task_struct</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/10%20%E8%BF%9B%E7%A8%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84task_struct/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/10 进程数据结构task_struct/</id>
    <published>2020-04-18T22:19:49.150Z</published>
    <updated>2020-04-18T22:21:35.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念">基本概念</h3><p>在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构<code>task_struct</code>进行管理。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzc1LzJkLzc1YzRkMjhhOWQyZGFhNGFjYzExMDc4MzJiZTg0ZTJkLmpwZWc?x-oss-process=image/format,png" alt></p><h3 id="分析task-struct">分析<code>task_struct</code></h3><p>对源码检索<code>stask_struct</code>关键字，发现文件<code>include/linux/sched.h</code>有这个结构体定义,结构非常长。下面借用专栏中总结的框图<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzFjL2JjLzFjOTE5NTZiNTI1NzRiNjJhNDQxOGE3YzY5OTNkOGJjLmpwZWc?x-oss-process=image/format,png" alt></p><h3 id="补充知识">补充知识</h3><p><strong>1、 系统上查看进程信息</strong><br>可以通过<code>/proc/pid</code>下的文件查看进程的相关信息。或者直接通过一些<a href="https://garlicspace.com/2019/07/03/" rel="external nofollow noopener noreferrer" target="_blank">常用命令</a>,比如</p><ul><li><code>ps</code>查看进程</li><li><code>pstree</code>查看进程的依赖关系</li><li><code>lsof</code>命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。和<code>fuser</code>命令用于报告进程使用的文件和网络套接字。</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/91550" rel="external nofollow noopener noreferrer" target="_blank">极客时间专栏 - 进程数据结构（上）：项目多了就需要项目管理系统</a></li><li><a href="https://time.geekbang.org/column/article/92151" rel="external nofollow noopener noreferrer" target="_blank">极客时间专栏 - 进程数据结构（中）：项目多了就需要项目管理系统</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构&lt;code&gt;task_struct&lt;/code&gt;进行管理。&lt;br&gt;
&lt;img src=&quot;https://imgconvert.
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>09 了解与创建线程</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/09%20%E4%BA%86%E8%A7%A3%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/09 了解与创建线程/</id>
    <published>2020-04-18T22:19:05.420Z</published>
    <updated>2020-04-18T22:20:22.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍-目的">介绍&amp;目的</h3><p>之前了解了进程的创建过程，其实进程默认也有一个主线程(也可以包含其他线程)。线程是负责执行二进制指令的，它会根据项目执行计划书，一行一行执行下去。进程要比线程管的宽多了，除了执行指令之外，内存、文件系统等等都要它来管。<br>例如，此时有一个开发网站的项目。我们想把它拆解成多个网页任务，并行执行，最后做一个整合。类似的，在程序实现上，也可以将一个功能拆分成多个子任务。可以使用<code>多进程</code>的并行方案，但是有两个问题</p><ul><li>第一，创建进程占用资源太多；</li><li>第二，进程之间的通信需要数据在不同的内存空间传来传去，无法共享。</li></ul><p>使用<code>多线程</code>可以很好的解决这两个问题(多个线程是共享一个进程的资源)。那么，如何创建一个线程任务，线程间又如何对数据操作的呢？<br>下面整理的资料主要为解决这个问题。</p><h3 id="代码示例">代码示例</h3><p><strong>1、 编辑&amp;编译&amp;运行</strong><br># download.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//download.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_OF_TASKS 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">downloadfile</span><span class="params">(<span class="keyword">void</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"I am downloading the file %s!\n"</span>, (<span class="keyword">char</span> *)filename);</span><br><span class="line">   sleep(<span class="number">5</span>);</span><br><span class="line">   <span class="keyword">long</span> downloadtime = rand()%<span class="number">100</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"I finish downloading the file within %d minutes!\n"</span>, downloadtime);</span><br><span class="line">   pthread_exit((<span class="keyword">void</span> *)downloadtime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> files[NUM_OF_TASKS][<span class="number">20</span>]=&#123;<span class="string">"file1.avi"</span>,<span class="string">"file2.rmvb"</span>,<span class="string">"file3.mp4"</span>,<span class="string">"file4.wmv"</span>,<span class="string">"file5.flv"</span>&#125;;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_OF_TASKS]; <span class="comment">// 声明线程对象</span></span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">int</span> t;</span><br><span class="line">   <span class="keyword">int</span> downloadtime[NUM_OF_TASKS];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明线程属性</span></span><br><span class="line">   <span class="keyword">pthread_attr_t</span> thread_attr;</span><br><span class="line">   pthread_attr_init(&amp;thread_attr);</span><br><span class="line">   pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_OF_TASKS;t++)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"creating thread %d, please help me to download %s\n"</span>, t, files[t]);</span><br><span class="line">     rc = pthread_create(&amp;threads[t], &amp;thread_attr, downloadfile, (<span class="keyword">void</span> *)files[t]); <span class="comment">// 创建线程</span></span><br><span class="line">     <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pthread_attr_destroy(&amp;thread_attr);<span class="comment">// 销毁线程属性</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;NUM_OF_TASKS;t++)&#123;</span><br><span class="line">     pthread_join(threads[t],(<span class="keyword">void</span>**)&amp;downloadtime[t]); <span class="comment">//获取其他线程的返回值</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Thread %d downloads the file %s in %d minutes.\n"</span>,t,files[t],downloadtime[t]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 结束线程，返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p># 编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc download.c -lpthread</span><br></pre></td></tr></table></figure><p># 运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># ./a.out</span><br><span class="line">creating thread 0, please help me to download file1.avi</span><br><span class="line">creating thread 1, please help me to download file2.rmvb</span><br><span class="line">I am downloading the file file1.avi!</span><br><span class="line">creating thread 2, please help me to download file3.mp4</span><br><span class="line">I am downloading the file file2.rmvb!</span><br><span class="line">creating thread 3, please help me to download file4.wmv</span><br><span class="line">I am downloading the file file3.mp4!</span><br><span class="line">creating thread 4, please help me to download file5.flv</span><br><span class="line">I am downloading the file file4.wmv!</span><br><span class="line">I am downloading the file file5.flv!</span><br><span class="line">I finish downloading the file within 83 minutes!</span><br><span class="line">I finish downloading the file within 77 minutes!</span><br><span class="line">I finish downloading the file within 86 minutes!</span><br><span class="line">I finish downloading the file within 15 minutes!</span><br><span class="line">I finish downloading the file within 93 minutes!</span><br><span class="line">Thread 0 downloads the file file1.avi in 83 minutes.</span><br><span class="line">Thread 1 downloads the file file2.rmvb in 86 minutes.</span><br><span class="line">Thread 2 downloads the file file3.mp4 in 77 minutes.</span><br><span class="line">Thread 3 downloads the file file4.wmv in 93 minutes.</span><br><span class="line">Thread 4 downloads the file file5.flv in 15 minutes.</span><br></pre></td></tr></table></figure><p><strong>2、 总体流程</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlL2UzL2JkL2UzOGMyOGIwOTcyNTgxZDAwOWVmMTZmMWViZGVlMmJkLmpwZw?x-oss-process=image/format,png" alt></p><h3 id="线程数据">线程数据</h3><p><strong>1、 线程数据分类</strong></p><ul><li><code>线程栈上的本地数据</code>，相当于函数中的局部变量。通过<code>ulimit -a</code>命令查看线程栈的空间大小。</li><li><code>在整个进程里共享的全局数据</code>，相当于程序中的全部变量。多个线程同时对共享资源访问会造成冲突，所以需要额外的机制控制。</li><li><code>线程私有数据</code>，通过key-value形式存储。通过函数接口操作。多线程可以使用同一个key值，但是各自有不同的value；在线程退出自动析构释放value。</li></ul><p><strong>2、 总结框图</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlL2U3LzNmL2U3YjA2ZGNmNDMxZjM4ODE3MGFiMGE3OTY3N2VlNDNmLmpwZw?x-oss-process=image/format,png" alt></p><p><strong>3、 对共享数据的访问</strong><br>使用同步互斥机制<br>- 互斥锁(Mutex)<br>- 互斥锁(Mutex) + 条件变量<br>- 信号量</p><h3 id="补充知识">补充知识</h3><p><strong>1、 线程同步互斥机制</strong><br>待补充</p><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/91289" rel="external nofollow noopener noreferrer" target="_blank">极客专栏 - 线程：如何让复杂的项目并行执行？</a></li><li><a href="https://www.cnblogs.com/baizhanshi/p/6844356.html" rel="external nofollow noopener noreferrer" target="_blank">线程同步和互斥的区别</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍-目的&quot;&gt;介绍&amp;amp;目的&lt;/h3&gt;
&lt;p&gt;之前了解了进程的创建过程，其实进程默认也有一个主线程(也可以包含其他线程)。线程是负责执行二进制指令的，它会根据项目执行计划书，一行一行执行下去。进程要比线程管的宽多了，除了执行指令之外，内存、文件系统等等都要它来
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>08 进程的出生过程</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/08%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%87%BA%E7%94%9F%E8%BF%87%E7%A8%8B/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/08 进程的出生过程/</id>
    <published>2020-04-18T22:16:42.643Z</published>
    <updated>2020-04-18T22:18:31.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目的">目的</h3><p>对于进程，可以通过别人写好的程序(比如Linux命令)或者自己写的程序(编译后生成可执行文件)，加载到内存后执行就视为一个进程。<br>这些我已经了解，OK，那么在学习一下代码到二进制文件的过程是什么、系统如何识别二进制文件、如何加载到内存并运行成一个进程，另外如何从代码中创建一个新进程？</p><p>这次整理笔记的主要内容，也是本次学习的目的:</p><ul><li>了解代码编译成二进制文件，生成库文件或者可执行文件的过程</li><li>了解系统加载二进制文件的机制，如何产生一个进程</li><li>了解如何调用fork创建一个进程</li><li>相关知识补充(ELF文件格式、Linux系统进程树、查看文件格式工具)</li></ul><h3 id="代码示例">代码示例</h3><p>运行一个demo，主要功能是主进程通过系统调用fork一个新的进程，子进程功能是加载二进制文件，运行ls命令。<br><strong>1、 目录结构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_16_8_centos test]# tree .</span><br><span class="line">.</span><br><span class="line">|-- createprocess.c</span><br><span class="line">`-- process.c</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure><p><strong>2、 编辑&amp;编译&amp;运行</strong><br># process.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">create_process</span> <span class="params">(<span class="keyword">char</span>* program, <span class="keyword">char</span>** arg_list)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_process</span> <span class="params">(<span class="keyword">char</span>* program, <span class="keyword">char</span>** arg_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> child_pid;</span><br><span class="line">        child_pid = fork (); <span class="comment">// 1.创建子进程</span></span><br><span class="line">        <span class="keyword">if</span> (child_pid != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> child_pid;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                execvp (program, arg_list); <span class="comment">//2.子进程通过execvp去运行一个新的程序</span></span><br><span class="line">                <span class="built_in">abort</span> ();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p># createprocess.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createprocess.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">create_process</span> <span class="params">(<span class="keyword">char</span>* program, <span class="keyword">char</span>** arg_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* arg_list[] = &#123;</span><br><span class="line">        <span class="string">"ls"</span>,</span><br><span class="line">        <span class="string">"-l"</span>,</span><br><span class="line">        <span class="string">"/etc/yum.repos.d/"</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line">    create_process (<span class="string">"ls"</span>, arg_list);    <span class="comment">//让子进程执行ls命令</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p># 编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#### 第一种方式 ####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译成.o文件</span></span><br><span class="line">gcc -c -fPIC process.c</span><br><span class="line">gcc -c -fPIC createprocess.c</span><br><span class="line"><span class="comment"># 生成库文件</span></span><br><span class="line">ar cr libstaticprocess.a process.o <span class="comment"># process.o编译成静态库</span></span><br><span class="line"><span class="comment"># 链接为可执行文件</span></span><br><span class="line">gcc -o staticcreateprocess createprocess.o -L. -lstaticprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 第二种方式 ####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译成.o文件</span></span><br><span class="line">gcc -c -fPIC process.c</span><br><span class="line">gcc -c -fPIC createprocess.c</span><br><span class="line"><span class="comment"># 生成库文件</span></span><br><span class="line">gcc -shared -fPIC -o libdynamicprocess.so process.o  <span class="comment"># process.o编译成共享库</span></span><br><span class="line"><span class="comment"># 链接为可执行文件</span></span><br><span class="line">gcc -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess</span><br></pre></td></tr></table></figure><p># 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 第一种方式 ####</span></span><br><span class="line">$ ./staticcreateprocess</span><br><span class="line">$ total 40</span><br><span class="line">-rw-r--r--. 1 root root 1572 Oct 24 18:38 CentOS-Base.repo</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 第二种方式 ####</span></span><br><span class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=.</span><br><span class="line">$ ./dynamiccreateprocess</span><br><span class="line">$ total 40</span><br><span class="line">-rw-r--r--. 1 root root 1572 Oct 24 18:38 CentOS-Base.repo</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>3、 总体框图</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlL2RiL2E5L2RiZDg3ODVkYTZjM2NlM2ZlMWFiYjdiYjU5MzRiN2E5LmpwZWc?x-oss-process=image/format,png" alt><br>图右边的文件编译过程，生成 so 文件和可执行文件,后面对部分内容整理。<br>图左边对刚才的代码进行补充:用户态的进程 A 执行 fork，创建进程 B，在进程 B 的处理逻辑中，执行 exec 系列系统调用。这个系统调用会通过 load_elf_binary 方法，将刚才生成的可执行文件，加载到进程 B 的内存中执行。</p><h3 id="编译和链接">编译和链接</h3><p><strong>1、文本文件转换到二进制文件</strong><br>编译工具链将我们写好的代码转换成二进制文件，在Linux系统中识别的是elf格式的二进制文件。大致流程为<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzg1L2RlLzg1MzIwMjQ1Y2Q4MGNlNjFlNjljODM5MTk1ODI0MGRlLmpwZWc?x-oss-process=image/format,png" alt></p><p>elf格式有<code>可重定位文件</code>、<code>可执行文件</code>、<code>动态链接库</code>几种类型。</p><h3 id="运行程序为进程">运行程序为进程</h3><p>如何将elf格式的二进制程序加载到内存运行的呢？<br><strong>1、 内核源码</strong><br>内核中定义加载二进制文件的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line">        <span class="keyword">int</span> (*load_binary)(struct linux_binprm *);</span><br><span class="line">        <span class="keyword">int</span> (*load_shlib)(struct file *);</span><br><span class="line">        <span class="keyword">int</span> (*core_dump)(struct coredump_params *cprm);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> min_coredump;     <span class="comment">/* minimal dump size */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>对于 ELF 文件格式，有对应的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> = &#123;</span></span><br><span class="line">        .<span class="keyword">module</span>         = THIS_MODULE,</span><br><span class="line">        .load_binary    = load_elf_binary,</span><br><span class="line">        .load_shlib     = load_elf_library,</span><br><span class="line">        .core_dump      = elf_core_dump,</span><br><span class="line">        .min_coredump   = ELF_EXEC_PAGESIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于方法<code>load_elf_binary </code>，源码中有调用链: do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler。<br>而<code>do_execve </code>其实被一组exec的系统调用实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(execve,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, argv,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> do_execve(getname(filename), argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、 理解</strong><br>之前子进程代码中执行了方法<code>exec</code>，运行一个elf文件。其实通过命令行执行一个程序的时候，也有类似的实现。通过<code>strace</code>命令查看其中一个命令执行了哪些系统调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_16_8_centos demo]# strace ls</span><br><span class="line">execve(&quot;/usr/bin/ls&quot;, [&quot;ls&quot;], [/* 28 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0xb87000</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="fork-产生新进程">fork()产生新进程</h3><p>所有进程都是从父进程fork过来的，那总归有一个祖宗进程，这就是咱们系统启动的<code>init</code>进程。下面是linux进程树，也可以通过<code>ps -ef</code>命令查看<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzRkLzE2LzRkZTc0MGMxMDY3MGE5MmJiYWE1ODM0OGU2NmI3YjE2LmpwZWc?x-oss-process=image/format,png" alt="进程树"></p><h3 id="补充知识">补充知识</h3><p><strong>1、 了解ELF文件格式</strong><br>ELF格式有<code>可重定位文件</code>、<code>可执行文件</code>、<code>动态链接库</code>几种类型。</p><ul><li>第一种是<code>可重定位文件</code>，也就是代码编译后生成的.o文件，这类文件还没有被链接，所以相当于一个代码片段。</li><li>第二种是<code>可执行文件</code>，链接后的程序，可直接加载到虚拟内存上运行的一类文件。</li><li>第三种是<code>动态链接库</code>,生成的库文件，动态库能被多个程序共享。程序并没有将动态库的代码包含进去(静态库的方式)，相当于仅仅包括对动态链接库的引用。</li></ul><p>文件格式<br>(了解后在补充)</p><p><strong>2、 了解Linux系统中的进程，如查看进程</strong><br>命令<code>ps -ef</code>查看Linux系统中的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_16_8_centos demo]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Mar01 ?        00:05:19 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">root         2     0  0 Mar01 ?        00:00:00 [kthreadd]</span><br><span class="line">root         3     2  0 Mar01 ?        00:01:40 [ksoftirqd/0]</span><br><span class="line">root         5     2  0 Mar01 ?        00:00:00 [kworker/0:0H]</span><br><span class="line">root         7     2  0 Mar01 ?        00:00:00 [migration/0]</span><br><span class="line">root         8     2  0 Mar01 ?        00:00:00 [rcu_bh]</span><br><span class="line">root         9     2  0 Mar01 ?        00:04:46 [rcu_sched]</span><br><span class="line">root        10     2  0 Mar01 ?        00:00:00 [lru-add-drain]</span><br><span class="line">root        11     2  0 Mar01 ?        00:00:16 [watchdog/0]</span><br><span class="line">root        13     2  0 Mar01 ?        00:00:00 [kdevtmpfs]</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><strong>3、 几种查看文件格式的工具</strong></p><ul><li><code>readelf</code> 工具用于分析 ELF 的信息，</li><li><code>objdump</code> 工具用来显示二进制文件的信息，</li><li><code>hexdump</code> 工具用来查看文件的十六进制编码，</li><li><code>nm</code> 工具用来显示关于指定文件中符号的信息。</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/90855" rel="external nofollow noopener noreferrer" target="_blank">极客时间专栏 - 进程：公司接这么多项目，如何管？</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;目的&quot;&gt;目的&lt;/h3&gt;
&lt;p&gt;对于进程，可以通过别人写好的程序(比如Linux命令)或者自己写的程序(编译后生成可执行文件)，加载到内存后执行就视为一个进程。&lt;br&gt;
这些我已经了解，OK，那么在学习一下代码到二进制文件的过程是什么、系统如何识别二进制文件、如何加
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>08 Android-bp条件编译</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/08%20Android-bp%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/08 Android-bp条件编译/</id>
    <published>2020-04-11T00:29:58.036Z</published>
    <updated>2020-04-11T00:32:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念">基本概念</h3><p>1、 背景<br>条件编译为我们提供了一种<code>一套代码兼容多个版本</code>的解决方案，提高代码的复用率。<br>在Android7.0之前使用的是Makefle编译，makefile语法支持条件编译，配置到Android.mk文件。<br>在那以后，开始使用Ninja编译框架，只需要我们配置Android.bp文件，但是bp文件就是一个配置文件，不支持条件编译。<br>但条件编译又是强需求，所以 google 还是提供了一种条件编译的方法，下面我们就来学习一下。</p><p>2、 目的<br>把 platform sdk version 传给一个 Android.bp 模块的 cpp 代码。</p><p>3、 文件组织结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ tree ./device/mi/pure/hello</span><br><span class="line">./device/mi/pure/hello  # 我们要编译的hello模块</span><br><span class="line">├── Android.bp      # </span><br><span class="line">├── hello.cpp  # </span><br><span class="line">└── hello.go # </span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure><h3 id="关键步骤">关键步骤</h3><p>1、 模块编译规则（Android.bp）</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add start</span></span><br><span class="line"><span class="class">bootstrap_go_package </span>&#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">"soong-hello"</span>,</span><br><span class="line"><span class="symbol">    pkgPath:</span> <span class="string">"android/soong/hello"</span>,</span><br><span class="line"><span class="symbol">    deps:</span> [</span><br><span class="line">        <span class="string">"soong-android"</span>,</span><br><span class="line">        <span class="string">"soong-cc"</span>,</span><br><span class="line">    ],</span><br><span class="line"><span class="symbol">    srcs:</span> [</span><br><span class="line">          <span class="string">"hello.go"</span>,</span><br><span class="line">    ],</span><br><span class="line"><span class="symbol">    pluginFor:</span> [<span class="string">"soong_build"</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">cc_hello_binary </span>&#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">"hello_defaults"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class">cc_binary </span>&#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">"hello"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add start</span></span><br><span class="line"><span class="symbol">    defaults:</span> [<span class="string">"hello_defaults"</span>],</span><br><span class="line">    <span class="comment">// add end</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    srcs:</span> [<span class="string">"hello.cpp"</span>],</span><br><span class="line"><span class="symbol">    vendor:</span> true,</span><br><span class="line"><span class="symbol">    shared_libs:</span> [</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<a href="https://ci.android.com/builds/submitted/6373029/linux/latest/view/soong_build.html" rel="external nofollow noopener noreferrer" target="_blank">Android.bp中已知的模块类型</a>，其中</p><ul><li>类型为<code>bootstrap_go_package</code>的模块名soong-hello，指定了源文件<code>hello.go</code>。</li><li>类型<code>cc_hello_binary</code>是在<code>hello.go</code>里面进行定义，这里相当于编译条件。</li><li>类型<code>cc_binary</code>的模块名hello，通过hello_defaults模块合入配置，并编译源文件<code>hello.cpp</code>成二进制文件。</li></ul><p>2、 添加hook机制（hello.go）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"android/soong/android"</span></span><br><span class="line">        <span class="string">"android/soong/cc"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    android.RegisterModuleType(<span class="string">"cc_hello_binary"</span>, helloDefaultsFactory)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloDefaultsFactory</span><span class="params">()</span> <span class="params">(android.Module)</span></span> &#123;</span><br><span class="line">    module := cc.DefaultsFactory()</span><br><span class="line">    android.AddLoadHook(module, helloHook)</span><br><span class="line">    <span class="keyword">return</span> module</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHook</span><span class="params">(ctx android.LoadHookContext)</span></span> &#123;</span><br><span class="line">    <span class="comment">//AConfig() function is at build/soong/android/config.go</span></span><br><span class="line">    fmt.Println(<span class="string">"PlatformSdkVersion = "</span>, ctx.AConfig().PlatformSdkVersion())</span><br><span class="line">    fmt.Println(<span class="string">"DeviceName = "</span>, ctx.AConfig().DeviceName())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> props <span class="keyword">struct</span> &#123;</span><br><span class="line">        Cflags []<span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := &amp;props&#123;&#125;</span><br><span class="line">    p.Cflags = <span class="built_in">append</span>(p.Cflags, <span class="string">"-DPLATFORM_SDK_VERSION="</span> + ctx.AConfig().PlatformSdkVersion())</span><br><span class="line">    ctx.AppendProperties(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello.go文件中配置hook机制，首先定义模块类型<code>cc_hello_binary</code>，然后是hook处理函数<code>helloHook</code>。如果这个<code>cc_hello_binary</code>被定义，表示编译条件成立，触发hook处理函数</p><ul><li><code>init()</code>里面注册了一个新的模块类型 cc_hello_binary</li><li>对应的函数是<code>helloDefaultsFactory()</code>,需要注意的是其中<code>cc.DefaultsFactory</code>要根据模块类型的不同而不同,参考<code>build/soong/cc/xxx.go</code>中的定义</li><li>最后我们希望的条件编译内容可以在hook中定义，通过<code>ctx</code>来获取和添加配置信息，可添加的配置类型参考类型props的定义</li></ul><p>3、 使用传入的配置（hello.cpp）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PLATFORM_SDK_VERSION = %d\n"</span>, PLATFORM_SDK_VERSION);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、 将模块添加到Build系统（<a href="http://product.mk" rel="external nofollow noopener noreferrer" target="_blank">product.mk</a>）<br>将模块添加到product.mk文件中的PRODUCT_PACKAGES变量(模块会随着编译打包到android系统中)。</p><h3 id="编译验证">编译验证</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>mm hello</span><br><span class="line">...</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>emulator -wipe-data</span><br><span class="line">...</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell</span><br><span class="line">adb server version (<span class="number">41</span>) doesn<span class="string">'t match this client (39); killing...</span></span><br><span class="line"><span class="string">* daemon started successfully</span></span><br><span class="line"><span class="string">pure:/ # hello # 模块加载</span></span><br><span class="line"><span class="string">PLATFORM_SDK_VERSION = 29</span></span><br><span class="line"><span class="string">pure:/ # ^C</span></span><br><span class="line"><span class="string">130|pure:/ # exit</span></span><br></pre></td></tr></table></figure><h3 id="思考总结">思考总结</h3><p>Android.bp只是一个json格式的配置文件，不支持条件语句，不支持控制流程语句。所有复杂问题都由用Go编写的编译逻辑处理。<br>对于bp文件，了解json格式，其他的靠以后慢慢积累；对于go语言，也不用单独学习，以后多写几个demo，总结套路就好。</p><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/build" rel="external nofollow noopener noreferrer" target="_blank">官方文档 - Soong编译系统</a></li><li><a href="http://qiushao.net/2020/02/05/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/15-Anroid.bp%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/" rel="external nofollow noopener noreferrer" target="_blank">Android.bp 条件编译</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;1、 背景&lt;br&gt;
条件编译为我们提供了一种&lt;code&gt;一套代码兼容多个版本&lt;/code&gt;的解决方案，提高代码的复用率。&lt;br&gt;
在Android7.0之前使用的是Makefle编译，makefile语法支持条件编译，配置到A
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>07 深入系统调用</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/07%20%E6%B7%B1%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/07 深入系统调用/</id>
    <published>2020-04-11T00:23:09.155Z</published>
    <updated>2020-04-11T00:42:17.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目的">目的</h3><p>进程访问核心资源通过系统调用。站在<code>系统调用</code>的角度，层层深入下去，就能从某个系统调用的场景出发，了解内核中各个模块的实现机制。<br>但是在实际开发中不会直接使用系统调用，因为Linux 还提供了<code>glibc</code>这个中介。它更熟悉系统调用的细节，并且可以封装成更加友好的接口。</p><blockquote><p>glibc 的官网：<a href="http://www.gnu.org/software/libc/" rel="external nofollow noopener noreferrer" target="_blank">http://www.gnu.org/software/libc/</a><br>下载glibc源码: <code>git clone git://sourceware.org/git/glibc.git</code></p><p>linux kernel官网: <a href="https://www.kernel.org/" rel="external nofollow noopener noreferrer" target="_blank">https://www.kernel.org/</a><br>linux源码获取: <a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.14.175.tar.xz" rel="external nofollow noopener noreferrer" target="_blank">https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.14.175.tar.xz</a></p></blockquote><p>本文目标：从glibc提供的open函数出发，剖析如何从glibc的open调用到内核的open!!!</p><br><h3 id="glibc封装、系统实现">glibc封装、系统实现</h3><p><strong>1、 glibc封装</strong><br>我们用户进程调用的glibc库封装的open函数，在glibc的源代码中，有以下相关文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./sysdeps/unix/syscalls.list   # 列出所有glibc的函数对应的系统调用</span><br><span class="line">./sysdeps/unix/make-syscalls.sh # 根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件</span><br><span class="line">./sysdeps/unix/syscall-template.S  # 定义了这个系统调用的调用方式</span><br><span class="line">./sysdeps/hppa/sysdep.h   # 通过 `vim -t PSEUDO` 找到 PSEUDO 这个宏的定义。</span><br></pre></td></tr></table></figure><p>经过分析代码open函数的<a href="https://time.geekbang.org/column/article/90394" rel="external nofollow noopener noreferrer" target="_blank">代码逻辑</a>,得出结论: 对于任何的系统调用，会调用<code>DO_CALL</code>。这也是一个宏，这个宏 32 位和 64 位的定义是不一样的。</p><p><strong>2、 系统调用过程</strong><br># 32位系统平台<br>继续分析glibc源码，发现宏<code>DO_CALL</code>定义处<code>unix/sysv/linux/i386/sysdep.h </code>。这里做了几件事情</p><ol><li>请求参数放在寄存器里面</li><li>系统调用名转换成系统调用号，放在寄存器 eax 里面</li><li>执行 ENTER_KERNE，产生一个软中断</li></ol><p>然后中断处理<code>entry_INT80_32 </code>就被调用了</p><ol><li>这里会将用户态的上下文保存在pt_regs结构中</li><li>然后调用<code>do_syscall_32_irqs_on</code>,它会将系统调用号取出，查找系统调用表，找到内核的<code>系统调用</code>执行，并取出寄存器中保存的参数。</li><li>当系统调用结束的时候，这时中断返回，iret 指令将原来用户态保存的现场恢复回来。进程恢复用户态继续执行。<br><img src="https://static001.geekbang.org/resource/image/56/06/566299fe7411161bae25b62e7fe20506.jpg" alt></li></ol><p># 64位系统平台<br>DO_CALL定义在源码位置<code>unix/sysv/linux/x86_64/sysdep.h</code>,还是将系统调用名称转换为系统调用号，放到寄存器 rax。和32位不同的是，</p><ul><li>这里是真正进行调用，不是用中断了，而是改用 syscall 指令了。</li><li>而且传递参数的寄存器也变了</li></ul><p>syscall指令通过一个叫做MSR的<code>特殊模块寄存器</code>，拿出函数地址来调用，也就是<code>entry_SYSCALL_64</code>。其中</p><ol><li>保存了很多寄存器到 pt_regs 结构里面，例如用户态的代码段、数据段、保存参数的寄存器</li><li>调用链entry_SYSCALL64_slow_pat-&gt;do_syscall_64，其中拿到系统调用号，在系统调用表中找到对应的系统调用，取参数，执行(老方法)</li><li>系统调用结束，返回用户态的指令变成了 sysretq。将进程恢复为用户态<br><img src="https://static001.geekbang.org/resource/image/1f/d7/1fc62ab8406c218de6e0b8c7e01fdbd7.jpg" alt></li></ol><br><h3 id="总结">总结</h3><p>结合之前对用户态、内核态模式转换的学习<code>用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态</code>。64位系统中一个完整的系统调用,专栏中的总结图如下<br><img src="https://static001.geekbang.org/resource/image/86/a5/868db3f559ad08659ddc74db07a9a0a5.jpg" alt></p><br><h3 id="补充知识">补充知识</h3><p><strong>1、 系统调用表</strong><br># kernel源码位置:<br>数据结构定义在<code>arch/x86/entry/syscall_64.c</code>,系统调用列表输出在<code>arch/x86/entry/syscalls/syscall_64.tbl</code></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#系统调用号 abi类型 函数名                      系统调用名</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">common</span>  open                    sys_open</span><br></pre></td></tr></table></figure><p># 系统调用函数声明<br>声明在<code>include/linux/syscalls.h</code>,找到有sys_open 的声明</p><p># 系统调用函数实现<br>内核系统调用实现和声明一致，其中<code>fs/open.c</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p># 编译规则<br>接下来，在编译的过程中，需要根据 syscall_32.tbl 和 syscall_64.tbl 生成自己的 unistd_32.h 和 unistd_64.h。在文件<code>arch/x86/entry/syscalls/Makefile </code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/90394" rel="external nofollow noopener noreferrer" target="_blank">趣谈Linux系统专栏 - 09系统调用</a></li><li><a href="https://blog.csdn.net/Lucien_zhou/article/details/68568851" rel="external nofollow noopener noreferrer" target="_blank">如何下载查看glibc源代码</a></li><li><a href="https://zhuanlan.zhihu.com/p/31496865" rel="external nofollow noopener noreferrer" target="_blank">glibc源码分析（一）系统调用</a></li><li><a href="https://garlicspace.com/2019/06/02/linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="external nofollow noopener noreferrer" target="_blank">linux下实现一个系统调用</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;目的&quot;&gt;目的&lt;/h3&gt;
&lt;p&gt;进程访问核心资源通过系统调用。站在&lt;code&gt;系统调用&lt;/code&gt;的角度，层层深入下去，就能从某个系统调用的场景出发，了解内核中各个模块的实现机制。&lt;br&gt;
但是在实际开发中不会直接使用系统调用，因为Linux 还提供了&lt;code&gt;
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>06 kernel初始化</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/06%20kernel%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/06 kernel初始化/</id>
    <published>2020-04-11T00:23:02.000Z</published>
    <updated>2020-04-11T00:23:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初步了解">初步了解</h3><p><strong>1、 回顾</strong><br>经过了BootLoader阶段，此时cpu从实模式转换成保护模式，有了更强的寻址能力，kernel也已经加载到内存了。系统内核开始运行<br>在kernel源码<code>init/main.c</code>文件中，内核的启动从入口函数<code>start_kernel() </code>。其中进行一系列的初始化<code>XXXX_init</code></p><p><strong>2、目的</strong><br>结合源码，了解内核启动阶段开始都做了哪些初始化。</p><p><strong>3、总结</strong><br>一些关键的初始化函数，原文中已经有总结好的图片<br><img src="https://static001.geekbang.org/resource/image/cd/01/cdfc33db2fe1e07b6acf8faa3959cb01.jpeg" alt></p><p>还有细心的同学总结了比较详细的笔记</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 内核初始化, 运行 <span class="string">`start_kernel()`</span> 函数(位于 init/main.c), 初始化做三件事</span></span><br><span class="line"><span class="ruby">    - 创建样板进程, 及各个模块初始化</span></span><br><span class="line"><span class="ruby">    - 创建管理/创建用户态进程的进程</span></span><br><span class="line"><span class="ruby">    - 创建管理/创建内核态进程的进程</span></span><br><span class="line"><span class="ruby">---</span></span><br><span class="line"><span class="ruby">- 创建样板进程,及各个模块初始化</span></span><br><span class="line"><span class="ruby">    - 创建第一个进程, <span class="number">0</span>号进程. <span class="string">`set_task_stack_end_magic(&amp;init_task)`</span> <span class="keyword">and</span> <span class="string">`struct task_struct init_task = INIT_TASK(init_task)`</span></span></span><br><span class="line"><span class="ruby">    - 初始化中断, <span class="string">`trap_init()`</span>. 系统调用也是通过发送中断进行, 由 <span class="string">`set_system_intr_gate()`</span> 完成.</span></span><br><span class="line"><span class="ruby">    - 初始化内存管理模块, <span class="string">`mm_init()`</span></span></span><br><span class="line"><span class="ruby">    - 初始化进程调度模块, <span class="string">`sched_init()`</span></span></span><br><span class="line"><span class="ruby">    - 初始化基于内存的文件系统 rootfs, <span class="string">`vfs_caches_init()`</span></span></span><br><span class="line"><span class="ruby">        - VFS(虚拟文件系统)将各种文件系统抽象成统一接口</span></span><br><span class="line"><span class="ruby">    - 调用 <span class="string">`rest_init()`</span> 完成其他初始化工作</span></span><br><span class="line"><span class="ruby">---</span></span><br><span class="line"><span class="ruby">- 创建管理/创建用户态进程的进程, <span class="number">1</span>号进程</span></span><br><span class="line"><span class="ruby">    - <span class="string">`rest_init()`</span> 通过 <span class="string">`kernel_thread(kernel_init,...)`</span> 创建 <span class="number">1</span>号进程(工作在用户态).</span></span><br><span class="line"><span class="ruby">    - 权限管理</span></span><br><span class="line"><span class="ruby">        - x86 提供 <span class="number">4</span>个 Ring 分层权限</span></span><br><span class="line"><span class="ruby">        - 操作系统利用: Ring<span class="number">0</span>-内核态(访问核心资源); Ring3-用户态(普通程序)</span></span><br><span class="line"><span class="ruby">    - 用户态调用系统调用: 用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态</span></span><br><span class="line"><span class="ruby">    - 新进程执行 kernel_init 函数, 先运行 ramdisk 的 /init 程序(位于内存中)</span></span><br><span class="line"><span class="ruby">        - 首先加载 ELF 文件</span></span><br><span class="line"><span class="ruby">        - 设置用于保存用户态寄存器的结构体</span></span><br><span class="line"><span class="ruby">        - 返回进入用户态</span></span><br><span class="line"><span class="ruby">        - <span class="regexp">/init 加载存储设备的驱动</span></span></span><br><span class="line"><span class="ruby">     - kernel_init 函数启动存储设备文件系统上的 init</span></span><br><span class="line"><span class="ruby">---</span></span><br><span class="line"><span class="ruby">- 创建管理/创建内核态进程的进程, <span class="number">2</span>号进程</span></span><br><span class="line"><span class="ruby">    - <span class="string">`rest_init()`</span> 通过 <span class="string">`kernel_thread(kthreadd,...)`</span> 创建 <span class="number">2</span>号进程(工作在内核态).</span></span><br><span class="line"><span class="ruby">    - <span class="string">`kthreadd`</span> 负责所有内核态线程的调度和管理</span></span><br></pre></td></tr></table></figure><p>下面我会根据文章和这份笔记，结合代码捋一下流程。</p><blockquote><p>在线阅读linux内核源码: <a href="https://elixir.bootlin.com/linux/latest/source" rel="external nofollow noopener noreferrer" target="_blank">https://elixir.bootlin.com/linux/latest/source</a></p></blockquote><br><h3 id="各个模块的初始化">各个模块的初始化</h3><p><strong>1、 0号进程</strong><br>定位到入口函数<a href="https://elixir.bootlin.com/linux/latest/source/init/main.c#L785" rel="external nofollow noopener noreferrer" target="_blank">start_kernel(void)</a>，发现有一处调用<a href="https://elixir.bootlin.com/linux/latest/source/init/main.c#L790" rel="external nofollow noopener noreferrer" target="_blank">set_task_stack_end_magic(&amp;init_task);</a>。这里kernel刚启动创建的第一个进程，pid为0，唯一一个没有通过 fork 或者 kernel_thread 产生的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br></pre></td></tr></table></figure><p><strong>2、 各个模块初始化</strong><br>同样在<a href="https://elixir.bootlin.com/linux/latest/source/init/main.c#L785" rel="external nofollow noopener noreferrer" target="_blank">start_kernel(void)</a>可以定位到其他的初始化调用，其中有关键的几个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trap_init(); <span class="comment">//系统调用相关 设置中断门</span></span><br><span class="line"></span><br><span class="line">mm_init();<span class="comment">//内存管理</span></span><br><span class="line"></span><br><span class="line">sched_init();<span class="comment">//调度模块</span></span><br><span class="line"></span><br><span class="line">vfs_caches_init();<span class="comment">//rootfs文件系统</span></span><br><span class="line"></span><br><span class="line">rest_init(); <span class="comment">//其他方面的init</span></span><br></pre></td></tr></table></figure><br><h3 id="用户态祖先进程的创建">用户态祖先进程的创建</h3><p>在rest_init()函数中有一处<a href="https://elixir.bootlin.com/linux/latest/source/init/main.c#L626" rel="external nofollow noopener noreferrer" target="_blank">kernel_thread(kernel_init, NULL, CLONE_FS)</a>,创建了pid为1的进程，这是第一个用户进程，是所有其他用户进程的鼻祖进程。</p><p><strong>内核态到用户态</strong><br>这是一个用户进程，需要在用户态运行。一般用户程序是从<code>用户态--到内核态--返回用户态</code>的过程。当前执行 kernel_thread 这个函数的时候，就在内核态。如何直接从内核态到用户态呢？<br>在kernel_init()函数中有一处<code>kernel_init_freeable()</code>调用，查看<a href="https://elixir.bootlin.com/linux/latest/source/init/main.c#L1454" rel="external nofollow noopener noreferrer" target="_blank">定义处</a>有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ramdisk_execute_command)</span><br><span class="line">    ramdisk_execute_command = <span class="string">"/init"</span>;</span><br></pre></td></tr></table></figure><p>回到kernel_init()函数，有对应的执行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">    ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> (!try_to_run_init_process(<span class="string">"/sbin/init"</span>) ||</span><br><span class="line">      !try_to_run_init_process(<span class="string">"/etc/init"</span>) ||</span><br><span class="line">      !try_to_run_init_process(<span class="string">"/bin/init"</span>) ||</span><br><span class="line">      !try_to_run_init_process(<span class="string">"/bin/sh"</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果我们打开 run_init_process 函数，会发现它调用的是 do_execve。<br>do_execve是一个内核系统调用，它的作用是运行一个执行文件。其中调用链为<code>do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_binary_handler</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">fmt</span>;</span></span><br><span class="line">  ......</span><br><span class="line">  retval = fmt-&gt;load_binary(bprm);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，它会尝试运行ramdisk 的<code>/init</code>，或者普通文件系统上的<code>/sbin/init</code>、<code>/etc/init</code>、<code>/bin/init</code>、<code>/bin/sh</code>。加载ELF文件，只要有一个启动起来就可以了。</p><p>比较关心程序如何’恢复’到用户态的，其实最后内核空间中保存了用户态运行的上下文，最后只要切换上下文，恢复那些寄存器（CS、DS、IP、SP），然后下一条指令，就从用户态开始运行了。</p><br><h3 id="内核态祖先进程的创建">内核态祖先进程的创建</h3><p>继续在rest_init()中查看有一处调用<a href="https://elixir.bootlin.com/linux/latest/source/init/main.c#L638" rel="external nofollow noopener noreferrer" target="_blank">kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</a>，这里创建了第三个进程，pid为2，是内核态所有task的祖先，作用是将内核态所有的task进行统一的调度和管理。</p><br><h3 id="补充知识">补充知识</h3><p><strong>1、 用户态、内核态</strong><br># 基本概念<br>进入保护模式后，为避免多进程对资源访问的混乱。使用x86提供的权限访问机制，有Ring0…Ring3 4种权限。<br>用户进程一般放在Ring3，我们称为<code>用户态</code><br>核心驱动代码一般放在Ring0，称为<code>内核态</code></p><p># 系统调用<br>用户程序要访问核心资源，需要通过系统提供的系统调用接口，从用户态进入内核态。这个过程就是这样的：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行。<br><img src="https://static001.geekbang.org/resource/image/d2/14/d2fce8af88dd278670395ce1ca6d4d14.jpg" alt></p><p><strong>2、 ramdisk的作用</strong><br>kernel启动过程中，一开始到用户态的是ramdisk的init，后来会启动真正根文件系统上的init，成为所有用户态进程的祖先。<br>为什么没有直接从根文件系统上加载init，这是因为文件系统一定存在一个存储设备上。要对设备访问需要驱动程序，而对内存可以直接访问。所以想在内存上建立一个<code>假文件系统</code>，先运行要访问存储设备的驱动程序，有了驱动就能设置根文件系统，就能启动根文件系统上的init程序了。</p><br><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/90109" rel="external nofollow noopener noreferrer" target="_blank">极客时间- 内核初始化</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;初步了解&quot;&gt;初步了解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、 回顾&lt;/strong&gt;&lt;br&gt;
经过了BootLoader阶段，此时cpu从实模式转换成保护模式，有了更强的寻址能力，kernel也已经加载到内存了。系统内核开始运行&lt;br&gt;
在kernel源码&lt;code
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>05 BIOS到BootLoader</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/05%20BIOS%E5%88%B0BootLoader/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/05 BIOS到BootLoader/</id>
    <published>2020-04-11T00:22:02.000Z</published>
    <updated>2020-04-11T00:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初步了解">初步了解</h3><p><strong>1、 回顾</strong><br>之前理解了x86架构下的工作模式，计算机系统的核心是<strong>CPU、内存、总线</strong>来干活的。但是x86提供的是开放的硬件平台，需要配合对应的操作系统，才能发挥最大的作用。<br>另外随着计算机技术的衍变，32位系统之后的x86架构已经有<strong>实模式</strong>和<strong>保护模式</strong>两种模式。系统启动之前的BIOS阶段在实模式，之后工作在保护模式。</p><ul><li>实模式，兼容原来16位系统设计出的模式。只能寻址1M，每个段最多64K</li><li>保护模式，对于32位系统，能够寻址4G。</li></ul><p><strong>2、 目的</strong><br>学习目的: 操作系统不是在板子上电就直接运行的，中间一定有一个过程。学习了解linux系统启动之前cpu做了哪些准备，内核如何被加载到内存上运行。</p><p><strong>3、 总结</strong><br>板子上电，先读取ROM中的固件代码，做出一个基本输入输出系统。这一阶段为<code>BIOS时期</code>。<br>BIOS从启动盘（一般是硬盘第一个扇区）开始加载引导代码，进一步初始化硬件，实模式升级为保护模式。这一阶段为<code>BootLoader时期</code>。<br>BootLoader将一系列工作做完了，最重要的一步就是加载系统内核kernel到内存运行了。控制权移交给内核之后，BootLoader时期结束，然后开始内核的部分了。</p><br><h3 id="BIOS阶段">BIOS阶段</h3><blockquote><p>BIOS是固化在ROM上的一段程序，如果你自己安装过操作系统，刚启动的时候，按某个组合键，显示器会弹出一个蓝色的界面。能够调整启动顺序的系统，就是我说的 BIOS，然后我们就可以先执行它。</p></blockquote><p><strong>1、 内存地址空间</strong><br>cpu工作模式是实模式，这时只有1M的内存地址空间<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzVmL2ZjLzVmMzY0ZWY1YzlkMWEzYjFkOWJiNzE1M2JkMTY2YmZjLmpwZWc?x-oss-process=image/format,png" alt></p><ol><li>x86系统中，cpu将内存地址0xF0000 到 0xFFFFF 这 64K 映射给 ROM。</li><li>主板上电，cpu将CS寄存器置为0xffff，ip寄存器置0x0000，所以第一条指令指向的地址是0xfff0(实模式下，cs&lt;&lt;4 + ip)。这里有一个jmp指令，跳转到rom中做初始化的代码。</li></ol><p><strong>2、 程序流程</strong><br>主板上电，CPU先从ROM中加载BIOS程序，BIOS进行硬件相关的初始化工作。主要有2件事情</p><ol><li>检查硬件环境</li><li>是建立中断程序和中断向量表，同时把结果显示在显示器上</li></ol><br><h3 id="BootLoader阶段">BootLoader阶段</h3><blockquote><p>光有BIOS还不够，还要从硬盘上搞到操作系统。引导操作系统这一阶段就是BootLoader。</p></blockquote><p><strong>1、 引导管理器grub2</strong><br>Linux一般通过grub来做系统引导程序。<br>系统上提供了grub2工具，grub2用户配置文件<code>/etc/default/grub</code>，系统会根据用户配置自动生成<code>/boot/grub/grub.cfg</code>。常用命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新生成配置文件</span></span><br><span class="line">grub-mkconfig -o <span class="string">/boot/grub/grub.cfg</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将Grub 2安装到硬盘引导扇区</span></span><br><span class="line">grub-install <span class="params">--root-directory=/</span> <span class="string">/dev/sda</span></span><br></pre></td></tr></table></figure><p><strong>2、 相关文件</strong><br>使用 grub2-install /dev/sda，可以将启动程序安装到相应的位置。其中有<code>boot.img</code>、<code>core.img</code><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuZ2Vla2Jhbmcub3JnL3Jlc291cmNlL2ltYWdlLzJiLzZhLzJiODU3M2JiYmYzMWZjMGNiMDQyMGUzMmQwN2IxOTZhLmpwZWc?x-oss-process=image/format,png" alt><br>(1)boot.img</p><p>在BIOS平台下，boot.img是grub启动的第一个img文件，它被写入到MBR中或分区的boot sector中，因为boot sector的大小是512字节，所以该img文件的大小也是512字节。</p><p>boot.img唯一的作用是读取属于core.img的第一个扇区并跳转到它身上，将控制权交给该扇区的img。由于体积大小的限制，boot.img无法理解文件系统的结构，因此grub2-install将会把core.img的位置硬编码到boot.img中，这样就一定能找到core.img的位置。</p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/7094693.html#blog122" rel="external nofollow noopener noreferrer" target="_blank">此处参考</a></p><p>(2)core.img</p><p>core.img根据diskboot.img、kernel.img和一系列的模块被grub2-mkimage程序动态创建。core.img中嵌入了足够多的功能模块以保证grub能访问/boot/grub，并且可以加载相关的模块实现相关的功能，例如加载启动菜单、加载目标操作系统的信息等，由于grub2大量使用了动态功能模块，使得core.img体积变得足够小。</p><p>core.img中包含了多个img文件的内容，包括diskboot.img/kernel.img等。</p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/7094693.html#blog122" rel="external nofollow noopener noreferrer" target="_blank">此处参考</a></p><p><strong>3、 引导流程</strong><br>BIOS完成之后，先加载boot.img到内容中运行，boot.img 将控制权交给 diskboot.img 后，diskboot.img 的任务就是将 core.img 的其他部分加载进来，先是解压缩程序 lzma_decompress.img，再往下是 kernel.img，最后是各个模块 module 对应的映像。这里需要注意，它不是 Linux 的内核，而是 grub 的内核。<br>再kernel.img中选择加载真正的linux kernel(对应之前的grub用户配置文件)。</p><br><h3 id="补充知识">补充知识</h3><p><strong>1、 从实模式切换到保护模式</strong><br>在bootloader过程中，lzma_decompress.img 做了一个重要的决定，就是调用 real_to_prot，cpu从实模式切换到保护模式.切换到保护模式要干很多工作，大部分工作都与内存的访问方式有关。</p><ul><li>第一项是启用分段，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</li><li>第二项是启动分页。能够管理的内存变大了</li><li>打开第21根地址线 Gate A20，cpu从20位总线到32位总线访问内存</li></ul><p><strong>2、 硬件基础(主引导扇区、分区引导扇区、分区表)</strong><br>一个硬盘实际上由一个个扇区组成，它起始的一部分扇区为主引导扇区，包括MBR（主引导纪录）和DPT（分区表）<br>硬盘可以有多个分区，每个分区起始的一部分扇区，为分区引导扇区。分区引导扇区之后的部分，为文件系统的索引，不同的文件系统采用不同的索引，文件系统通过它定位文件在硬盘上的位置。<br>对硬盘的读写操作，通过文件系统来完成；引导扇区中的内容，我们不能够在文件系统中进行操作，而需要专用软件，比如引导管理器。</p><br><h3 id="参考资料">参考资料</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" rel="external nofollow noopener noreferrer" target="_blank">主引导记录 - 百科</a><br><a href="http://linux-wiki.cn/wiki/zh-hans/Grub2%E9%85%8D%E7%BD%AE" rel="external nofollow noopener noreferrer" target="_blank">Grub2配置</a><br><a href="https://www.cnblogs.com/f-ck-need-u/p/7094693.html" rel="external nofollow noopener noreferrer" target="_blank">grub2详解(翻译和整理官方手册)</a><br><a href="https://opensource.com/article/17/2/linux-boot-and-startup" rel="external nofollow noopener noreferrer" target="_blank">An introduction to the Linux boot and startup processes</a><br><a href="https://opensource.com/article/17/3/introduction-grub2-configuration-linux" rel="external nofollow noopener noreferrer" target="_blank">An introduction to GRUB2 configuration for your Linux machine</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;初步了解&quot;&gt;初步了解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、 回顾&lt;/strong&gt;&lt;br&gt;
之前理解了x86架构下的工作模式，计算机系统的核心是&lt;strong&gt;CPU、内存、总线&lt;/strong&gt;来干活的。但是x86提供的是开放的硬件平台，需要配合对应的操作系统，
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>07 编译android kernel</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/07%20%E7%BC%96%E8%AF%91android%20goldfish%E5%86%85%E6%A0%B8(x86_64)/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/07 编译android goldfish内核(x86_64)/</id>
    <published>2020-04-05T00:35:10.000Z</published>
    <updated>2020-04-05T00:35:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android-linux内核">Android linux内核</h3><p>Android并没有使用标准的Linux内核，而是做了很多的修改。AOSP网站提供了适应各种芯片或设备的linux内核源码的仓，只有少部分google设备支持的内核源码可以通过<a href="https://source.android.google.cn/setup/build/building-kernels?hl=zh-cn#downloading" rel="external nofollow noopener noreferrer" target="_blank">repo构建</a>,其他的需要做一些编译配置。</p><h3 id="手动编译内核">手动编译内核</h3><p>这里选择emulator模拟器跑Android内核，所以选择goldfish版本作为我的的Linux Kernel，下面通过编译goldfish内核来介绍这个过程。<br>按照<a href="https://source.android.com/setup/build/building-kernels-deprecated" rel="external nofollow noopener noreferrer" target="_blank">官方的教程</a>没有找到<code>xxx_defconfig</code>编译配置文件，之后在网上找到一篇相似的<a href="https://my.oschina.net/wuqingyi/blog/903421" rel="external nofollow noopener noreferrer" target="_blank">博客</a>，以下步骤基本上是按照那个教程来的。<br>1、下载源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:kernel$ git <span class="built_in">clone</span> https://android.googlesource.com/kernel/goldfish</span><br></pre></td></tr></table></figure><p>2、查看当前Android系统对应的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ emulator   <span class="comment"># 虚拟机运行起来，点Setting -&gt; Android version 查看内核版本信息</span></span><br></pre></td></tr></table></figure><p>3、检出对应分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:kernel$ <span class="built_in">cd</span> goldfish/</span><br><span class="line">git branch -a</span><br><span class="line"><span class="comment">#....</span></span><br><span class="line"><span class="comment">#....</span></span><br><span class="line">git checkout -b dev remotes/origin/android-goldfish-4.14-dev.20190417  <span class="comment"># 对应的内核版本为4.14</span></span><br><span class="line"><span class="comment">#....</span></span><br></pre></td></tr></table></figure><p>4、进行编译配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/hinzer/<span class="built_in">source</span>/android-10/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9/bin</span><br><span class="line"><span class="built_in">export</span> ARCH=x86_64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=x86_64-linux-android-</span><br><span class="line"><span class="built_in">export</span> REAL_CROSS_COMPILE=x86_64-linux-android-</span><br></pre></td></tr></table></figure><p>5、编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/hinzer/<span class="built_in">source</span>/android-10/prebuilts/qemu-kernel/build-kernel.sh  --arch=x86_64    <span class="comment"># 需要在kernel的源码的根目录下执行</span></span><br></pre></td></tr></table></figure><p>但是出现error，没有发现&quot;x86_64_emu_defconfig&quot;这个文件。于是我将<code>x86_64_defconfig</code>改为<code>x86_64_emu_defconfig</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp -a /home/hinzer/<span class="built_in">source</span>/android-10/kernel/goldfish/arch/x86/configs/x86_64_defconfig /home/hinzer/<span class="built_in">source</span>/android-10/kernel/goldfish/arch/x86/configs/x86_64_emu_defconfig</span><br><span class="line">/home/hinzer/<span class="built_in">source</span>/android-10/prebuilts/qemu-kernel/build-kernel.sh  --arch=x86_64    <span class="comment"># 继续编译</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Kernel: arch/x86/boot/bzImage is ready  (<span class="comment">#1)</span></span><br><span class="line">Kernel x86_64_emu prebuilt images (kernel-qemu and vmlinux-qemu) copied to /tmp/kernel-qemu/x86_64-4.14.88 successfully !</span><br></pre></td></tr></table></figure><p>6、加载内核并运行系统<br>emulator启动相关的参数，可参考<a href="https://developer.android.google.cn/studio/run/emulator-commandline#startup-options" rel="external nofollow noopener noreferrer" target="_blank">官方手册 - 命令行启动选项</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译生成的内核放在/tmp/kernel-qemu/x86_64-3.10.0/kernel-qemu</span></span><br><span class="line">hinzer@ubuntu:android-10$ emulator -kernel /tmp/kernel-qemu/x86_64-4.14.88/kernel-qemu  <span class="comment"># 配置参数</span></span><br></pre></td></tr></table></figure><p>7、再次查看当前Android系统对应的内核版本</p><h3 id="补充">补充</h3><p>将编译出的<code>kernel-qemu</code>加载到emulator上发现界面直接卡死，adb devices命令也连接不上。初步怀疑是编译的linux内核版本不对，导致无法正常启动。(这个问题暂时还没有解决，目前单独编译不影响)<br>另外，进一步研究了kernel源码下的<code>README</code>文件，发现<code>make ${PLATFORM}_defconfig</code>说明。想到之前按照官方的步骤可能出了一点差错，修改为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd goldfish</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ARCH</span>=x86     # cpu架构</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CROSS_COMPILE</span>=x86_64-linux-android-</span><br><span class="line">make x86_64_defconfig    # 将arch/<span class="variable">$ARCH</span>/configs/xxx_defconfig写入.config文件，编译阶段build系统会检索</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>success!!此时编译出的映像文件输出<code>arch/x86/boot/bzImage</code>,</p><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/build/building-kernels-deprecated" rel="external nofollow noopener noreferrer" target="_blank">手动编译内核</a></li><li><a href="https://my.oschina.net/wuqingyi/blog/903421" rel="external nofollow noopener noreferrer" target="_blank">编译x86_64 android 7.1及goldfish内核</a></li><li><a href="https://blog.51cto.com/ticktick/1654759" rel="external nofollow noopener noreferrer" target="_blank">Android内核开发：源码的版本与分支详解</a></li><li><a href="https://source.android.google.cn/devices/architecture/kernel/android-common?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">Android 通用内核</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android-linux内核&quot;&gt;Android linux内核&lt;/h3&gt;
&lt;p&gt;Android并没有使用标准的Linux内核，而是做了很多的修改。AOSP网站提供了适应各种芯片或设备的linux内核源码的仓，只有少部分google设备支持的内核源码可以通过&lt;a 
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>04 x86架构</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/04%20x86%E6%9E%B6%E6%9E%84/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/04 x86架构/</id>
    <published>2020-04-05T00:32:02.000Z</published>
    <updated>2020-04-05T01:20:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先了解计算机底层最基本的工作原理，以便于以后能理解Linux系统的运作模式!!</p></blockquote><h3 id="总体概要">总体概要</h3><p>原文中对于x86架构的总结图片，重点牢记这些寄存器的作用，以及段的工作模式<br><img src="https://static001.geekbang.org/resource/image/e2/76/e2e92f2239fe9b4c024d300046536d76.jpeg" alt="总结概要"></p><h3 id="计算机的工作模式-了解一下">计算机的工作模式(了解一下)</h3><p><strong>1、 CPU、总线、内存</strong><br><img src="https://static001.geekbang.org/resource/image/fa/9b/fa6c2b6166d02ac37637d7da4e4b579b.jpeg" alt="计算机的工作模式"><br>对于一个计算机来讲，所有功能看似是<code>输入输出设备</code>的功劳，实际干活的还是<code>CPU</code>。同时CPU通过内存不断的保存和取出中间数据，然后基于中间结果进行进一步的计算。<code>总线</code>是CPU和其他设备的高速通道。</p><ul><li><code>CPU</code>是这台计算机的大脑，所有的设备都围绕它展开。</li><li><code>总线</code>其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。</li><li>最重要的是<code>内存</code>。因为单靠 CPU 是没办法完成计算任务的，很多复杂的计算任务都需要将中间结果保存下来，然后基于中间结果进行进一步的计算。</li></ul><p><strong>2、相互配合工作</strong><br><img src="https://static001.geekbang.org/resource/image/3a/23/3afda18fc38e7e53604e9ebf9cb42023.jpeg" alt="CPU 和内存"><br>首先要了解几个概念的关系，其中</p><ul><li>CPU包括三个部分，<code>运算单元</code>、<code>数据单元</code>和<code>控制单元</code></li><li>进程在内存上有独立的内存空间，相互隔离(但不连续)，每个进程简单的区分<code>代码段</code>和<code>数据段</code></li><li>总线上主要有两类，<code>地址总线</code>操作地址数据，<code>数据总线</code>操作真正的数据</li></ul><blockquote><p>那 CPU 怎么执行这些程序，操作这些数据，产生一些结果，并写入回内存呢?</p></blockquote><ol><li>CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。</li><li>数据单元根据数据的地址，从数据段里读到数据寄存器里，就可以参与运算了。<code>指令 = 操作码(运算单元) + 操作数(数据单元)</code></li><li>运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。</li><li>最终，会有指令将数据写回内存中的数据段。</li></ol><h3 id="x86平台特性-了解一下">x86平台特性(了解一下)</h3><p>x86架构起源于IBM,开端于8086。由于<code>开放、统一、兼容</code>的特性逐渐成为标准，后来Intel的cpu也都基于这个架构<br><img src="https://static001.geekbang.org/resource/image/54/8a/548dfd163066d061d1e882c73e7c2b8a.jpg" alt="x86架构cpu"></p><h3 id="8086的原理-了解一下">8086的原理(了解一下)</h3><p><img src="https://static001.geekbang.org/resource/image/2d/1c/2dc8237e996e699a0361a6b5ffd4871c.jpeg" alt="8086原理"><br><strong>1、 数据单元</strong><br>8086处理器内部有 8 个 16 位的通用寄存器，有些寄存器还能掰开2个8位寄存器来使用。</p><p><strong>2、 控制单元</strong><br><code>IP寄存器</code>指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。<br>每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS代码段寄存器、DS数据段寄存器、SS栈寄存器、ES。</p><p><strong>3、 访问地址模式</strong><br>这个时候内存是分段管理，CPU要访问内存地址通过<code>段启始地址 + 偏移量</code>的方式访问。其中，</p><ul><li>代码段的起始地址在CS寄存器，偏移量在 IP 寄存器中</li><li>数据段的起始地址在DS寄存器，偏移量在通用寄存器中<br>由于是20位地址总线，而寄存器都是16位的。所以8086采用了<code>基地址 &lt;&lt; 4 + 偏移量</code>的方式，其中</li><li>地址访问范围: 2^20 = 1M , 表示一个进程的最大访问空间</li><li>偏移量大小: 2^16=64k ， 表示一个段的最大空间</li></ul><h3 id="32位处理器-重点理解">32位处理器(重点理解)</h3><p>随着计算机的发展，32位总线已经足够应对4G内存。为了x86体系<code>开放、统一、兼容</code>的特性，要兼容原来的模式<br><img src="https://static001.geekbang.org/resource/image/e3/84/e3f4f64e6dfe5591b7d8ef346e8e8884.jpeg" alt="32位处理器"></p><ul><li>对于通用寄存器和IP寄存器有原来的16位扩展到32位，兼容原来的模式。</li><li>而改动比较大，有点不兼容的就是段寄存器(因为之前的20位总线设计太独特了)。其中有<ul><li>段的起始地址从原来放在寄存器中，改为放在内存的某个地方，当然为了快速拿到段起始地址，段寄存器会从内存中拿到 CPU 的描述符高速缓存器中。</li><li>cpu访问内存分位<code>实模式</code>和<code>保护模式</code>。其中<code>实模式</code>是对原来兼容的模式。</li></ul></li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://time.geekbang.org/column/article/89417" rel="external nofollow noopener noreferrer" target="_blank">极客时间 - x86架构</a></li><li><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html" rel="external nofollow noopener noreferrer" target="_blank">x86 Assembly Guide</a></li><li><a href="https://www.cnblogs.com/bindot/p/linux6.html" rel="external nofollow noopener noreferrer" target="_blank">Linux学习笔记《六》</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;先了解计算机底层最基本的工作原理，以便于以后能理解Linux系统的运作模式!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;总体概要&quot;&gt;总体概要&lt;/h3&gt;
&lt;p&gt;原文中对于x86架构的总结图片，重点牢记这些寄存器的作用，以及段的工作模式&lt;b
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>06 添加java层系统服务</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/06%20%E6%B7%BB%E5%8A%A0java%E5%B1%82%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/06 添加java层系统服务/</id>
    <published>2020-04-05T00:28:10.000Z</published>
    <updated>2020-04-05T00:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入概念">引入概念</h3><p>目前对android系统体系了解比较少，主要区分一下<code>服务</code>、<code>系统服务</code>这两个概念</p><ul><li><a href="https://developer.android.com/guide/components/services" rel="external nofollow noopener noreferrer" target="_blank">Android服务</a>是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。在android开发中作为一个<code>应用组件</code>,通过继承类<code>extern Service</code>来使用。</li><li><a href="https://blog.csdn.net/u010753159/article/details/52193061" rel="external nofollow noopener noreferrer" target="_blank">Android系统服务</a>。理解为随着andorid系统启动运行的service，分为<code>本地守护进程</code>、<code>Native系统服务</code>和<code>Java系统服务</code>。</li></ul><p>有相同点更有不同点，但请不要把两个概念弄混淆了!!!<br>然后下面记录一下<code>添加自定义一个java系统服务</code>的步骤，参考于<a href="http://qiushao.net/2019/12/20/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/7-%E6%B7%BB%E5%8A%A0java%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/" rel="external nofollow noopener noreferrer" target="_blank">qiushao</a>大神的blog。基于<code>android-10</code>版本的AOSP源码，</p><h3 id="添加服务">添加服务</h3><p><strong>1、 定义服务接口</strong><br>首先我们得定义我们的服务名是什么，提供什么样的接口。在<code>frameworks/base/core/java/android</code>目录下添加pure文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree frameworks/base/core/java/android/pure</span><br><span class="line">frameworks/base/core/java/android/pure</span><br><span class="line">└── IHelloService.aidl     # 使用 aidl 定义服务接口</span><br><span class="line"></span><br><span class="line">0 directories, 1 file</span><br></pre></td></tr></table></figure><p>定义接口文件<code>IHelloService.aidl</code>，模块名<code>IHelloService</code>,接口<code>hello</code>将实现播放指定路径的音频文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package android.pure;</span><br><span class="line">interface IHelloService &#123;</span><br><span class="line">    void hello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>frameworks/base/Android.bp</code>文件中找到模块名<code>framework-defaults</code>，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;core/java/android/pure/IHelloService.aidl&quot;,</span><br></pre></td></tr></table></figure><p><em>此时，进入 <code>framework/base</code> 目录执行 <code>mm -j</code> 命令编译 <code>framework.jar</code> 模块。<br>编译成功后，会在 <code>out/soong/.intermediates/frameworks/base/framework/android_common/gen/aidl/frameworks/base/core/java/android/pure</code> 目录生成 <code>IHelloService.java</code> 这个文件</em></p><p><strong>2、 实现接口</strong><br>然后在<code>frameworks/base/services/core/java/com/android/server</code>下创建<code>HelloService.java</code>文件(接口实现) 内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.android.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.pure.IHelloService;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">IHelloService</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"HelloService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"create hello service"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"hello "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、 将服务添加到 ServiceManager</strong><br>修改 <code>frameworks/base/services/java/com/android/server/SystemServer.java</code> 文件，在<code>startOtherServices</code>方法里面增加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// add hello service</span><br><span class="line">traceBeginAndSlog(&quot;HelloService&quot;);</span><br><span class="line">ServiceManager.addService(&quot;HelloService&quot;, new HelloService());</span><br><span class="line">traceEnd();</span><br></pre></td></tr></table></figure><p><strong>4、 编译验证 &amp; 系统无法启动</strong><br>现在已经实现的<code>HelloService</code>接口模块，并添加到<code>ServiceManager</code>。开始尝试整编下android源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ./build/envsetup.sh   <span class="comment"># 导出环境变量(之前执行过了)</span></span><br><span class="line">$ lunch product01-eng          <span class="comment"># 选择Product</span></span><br><span class="line">$ make api-stubs-docs-update-current-api -j4            <span class="comment"># 更新api接口</span></span><br><span class="line">$ make -j4            <span class="comment"># 编译</span></span><br></pre></td></tr></table></figure><p>然后启动<code>emulator</code>虚拟机，发现一直停留在logo界面，说明系统没起来。。这时候可以adb调试，我们查看一下log记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ emulator      <span class="comment"># 发现android系统界面没起来</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">$ adb shell logcat -b all &gt; logSystem.txt    <span class="comment"># 抓取android层的 log</span></span><br><span class="line">...</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>日志中检索我们想要的关键字<code>HelloService</code>,发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">04-02 01:24:25.871  2224  2224 I SystemServer: HelloService</span><br><span class="line">04-02 01:24:25.871  1528  1528 I auditd  : avc:  denied  &#123; add &#125; for service=HelloService pid=2224 uid=1000 scontext=u:r:system_server:s0 tcontext=u:object_r:default_android_service:s0 tclass=service_manager permissive=0</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  : ******************************************</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  : ************ Failure starting system services</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  : java.lang.SecurityException</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.BinderProxy.transactNative(Native Method)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.BinderProxy.transact(BinderProxy.java:510)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.ServiceManagerProxy.addService(ServiceManagerNative.java:156)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.ServiceManager.addService(ServiceManager.java:192)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at android.os.ServiceManager.addService(ServiceManager.java:161)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.server.SystemServer.startOtherServices(SystemServer.java:920)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.server.SystemServer.run(SystemServer.java:512)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.server.SystemServer.main(SystemServer.java:349)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)</span><br><span class="line">04-02 01:24:25.871  2224  2224 E System  :  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:908)</span><br><span class="line">04-02 01:24:25.871  2224  2224 D SystemServerTiming: HelloService took to complete: 1ms</span><br><span class="line">04-02 01:24:25.871  2224  2224 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main</span><br></pre></td></tr></table></figure><p>然后定位到这一句<code>04-02 01:24:25.871  1528  1528 I auditd  : avc:  denied  { add } for service=HelloService pid=2224 uid=1000 scontext=u:r:system_server:s0 tcontext=u:object_r:default_android_service:s0 tclass=service_manager permissive=0</code>,不理解没关系，google一下。发现是selinux方面的原因。</p><p>为了进一步验证猜想，将系统中的<code>selinux</code>关掉试试。通过<code>setenforce 0</code>命令，重启系统发现正常了，印证了之前的猜想，确实selinux配置的原因。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell setenforce 0   <span class="comment"># 禁用selinux</span></span><br><span class="line"></span><br><span class="line">$ emulator -wipe-data      <span class="comment"># 擦掉data区，重启系统</span></span><br></pre></td></tr></table></figure><p><strong>5、 设置selinux规则</strong><br>然后我们只需要添加这个自定义服务<code>HelloService</code>相关的 SELinux 规则。为了方便之后验证，打开selinux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell setenforce 1   <span class="comment"># 打开selinux</span></span><br></pre></td></tr></table></figure><p>Android 10 的 selinux 规则是放在 <code>system/sepolicy</code> 目录下的。不怎么了解SELinux规则，可以参考现有的系统服务的规则去添加，这里参考的是 <code>network_time_update_service</code> 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> system/sepolicy    <span class="comment"># selinux规则在这个目录</span></span><br><span class="line">$ grep -nr network_time_update_service   <span class="comment"># 查找network_time_update_service服务相关的selinux配置</span></span><br></pre></td></tr></table></figure><p>涉及到的文件很多，有部分文件是不需要修改的，我们先把找到的所有 service.te 和 service_contexts 都参考 network_time_update_service 加上 HelloService 的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ find -name service.te</span><br><span class="line">./prebuilts/api/27.0/public/service.te   # 需要</span><br><span class="line">./prebuilts/api/28.0/public/service.te   # 需要</span><br><span class="line">./prebuilts/api/28.0/private/service.te</span><br><span class="line">./prebuilts/api/29.0/public/service.te    # 需要</span><br><span class="line">./prebuilts/api/29.0/private/service.te</span><br><span class="line">./prebuilts/api/26.0/public/service.te   # 需要</span><br><span class="line">./public/service.te                 # 需要</span><br><span class="line">./private/service.te</span><br><span class="line">$ find -name service_contexts</span><br><span class="line">./reqd_mask/service_contexts</span><br><span class="line">./prebuilts/api/27.0/private/service_contexts   # 需要</span><br><span class="line">./prebuilts/api/28.0/private/service_contexts   # 需要</span><br><span class="line">./prebuilts/api/29.0/private/service_contexts       # 需要</span><br><span class="line">./prebuilts/api/26.0/private/service_contexts   # 需要</span><br><span class="line">./private/service_contexts         # 需要</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>service_contexts</code>上添加<code>HelloService                              u:object_r:HelloService:s0</code>;</li><li><code>service.te</code>上添加<code>type HelloService, system_server_service, service_manager_type;</code>。</li></ul><p>6、 编译验证<br>最后再次编译一遍，启动届满没有什么问题了。adb进入系统查看一下有没有这个服务</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ source ./build/envsetup.sh   # 导出环境变量(之前执行过了)</span><br><span class="line">$ lunch product01-eng          # 选择Product</span><br><span class="line">$ make api-stubs-docs-update-current-api -j4            # 更新api接口</span><br><span class="line">$ make -j4            # 编译</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">$ adb shell</span><br><span class="line">pure:/ #<span class="built_in"> service </span>list | grep HelloService                                                                                                                                                               </span><br><span class="line">16      HelloService: [android.pure.IHelloService]</span><br><span class="line">pure:/ #</span><br></pre></td></tr></table></figure><h3 id="错误记录">错误记录</h3><p><strong>1、 添加服务后,<code>make -j4</code>编译系统报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error: Added package android.pure [AddedPackage]</span><br><span class="line">Aborting: Found compatibility problems checking the public API against the API in /home/mi/source/android-10/frameworks/base/api/current.txt</span><br><span class="line">-e </span><br><span class="line">******************************</span><br><span class="line">You have tried to change the API from what has been previously approved.</span><br><span class="line"></span><br><span class="line">To make these errors go away, you have two choices:</span><br><span class="line">   1. You can add &apos;@hide&apos; javadoc comments to the methods, etc. listed in the</span><br><span class="line">      errors above.</span><br><span class="line"></span><br><span class="line">   2. You can update current.txt by executing the following command:</span><br><span class="line">         make api-stubs-docs-update-current-api</span><br><span class="line"></span><br><span class="line">      To submit the revised current.txt to the main Android repository,</span><br><span class="line">      you will need approval.</span><br><span class="line">******************************</span><br><span class="line"></span><br><span class="line">09:05:24 ninja failed with: exit status 1</span><br><span class="line"></span><br><span class="line">#### failed to build some targets (06:37 (mm:ss)) ####</span><br></pre></td></tr></table></figure><p>解决思路: 没有更新服务接口，编译前执行<code>make api-stubs-docs-update-current-api -j4</code></p><p><strong>2、添加selinux后,编译报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELinux: The following public types were found added to the policy without an entry into the compatibility mapping file(s) found in private/compat/V.v/V.v[.ignore].cil, where V.v is the latest API level.</span><br><span class="line">HelloService</span><br><span class="line"></span><br><span class="line">See examples of how to fix this:</span><br><span class="line">https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/781036</span><br><span class="line">https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/852612</span><br><span class="line"></span><br><span class="line">[ 20% 5/24] build out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0</span><br><span class="line">FAILED: out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0</span><br><span class="line">/bin/bash -c &quot;(out/host/linux-x86/bin/treble_sepolicy_tests -l    out/host/linux-x86/lib64/libsepolwrap.so  -f out/target/product/pure/obj/ETC/plat_file_contexts_intermediates/plat_file_contexts  -f out/target/product/pure/obj/ETC/vendor_file_contexts_intermediates/vendor_file_contexts    -b out/target/product/pure/obj/ETC/built_plat_sepolicy_intermediates/built_plat_sepolicy -m out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/28.0_mapping.combined.cil    -o out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/built_28.0_plat_sepolicy -p out/target/product/pure/obj/ETC/sepolicy_intermediates/sepolicy     -u out/target/product/pure/obj/ETC/built_plat_sepolicy_intermediates/base_plat_pub_policy.cil     --fake-treble ) &amp;&amp; (touch out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0 )&quot;</span><br><span class="line">SELinux: The following public types were found added to the policy without an entry into the compatibility mapping file(s) found in private/compat/V.v/V.v[.ignore].cil, where V.v is the latest API level.</span><br><span class="line">HelloService</span><br><span class="line"></span><br><span class="line">See examples of how to fix this:</span><br><span class="line">https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/781036</span><br><span class="line">https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/852612</span><br><span class="line"></span><br><span class="line">21:45:48 ninja failed with: exit status 1</span><br><span class="line"></span><br><span class="line">#### failed to build some targets (16 seconds) ####</span><br></pre></td></tr></table></figure><p>解决思路: selinux没配置好，没有将配置覆盖所有需要的te文件。检查本地配置，按照上面的方法，在配置一下。</p><p><strong>3、启动emulator之后，系统没起来，同时log报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ emulator -wipe-data</span><br><span class="line">emulator: WARNING: Couldn&apos;t find crash service executable /home/hinzer/source/android-10/prebuilts/android-emulator/linux-x86_64/emulator64-crash-service</span><br><span class="line"></span><br><span class="line">emulator: WARNING: system partition size adjusted to match image file (3083 MB &gt; 800 MB)</span><br><span class="line"></span><br><span class="line">qemu_ram_alloc_user_backed: call</span><br><span class="line">context mismatch in svga_surface_destroy   # 这个错误</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>解决方法: 通过网络查询到<a href="https://unix.stackexchange.com/questions/422993/syslogs-getting-spammed-with-context-mismatch-in-svga-sampler-view-destroy" rel="external nofollow noopener noreferrer" target="_blank">解决方法</a>,由于我这边是VM上运行Ubuntu虚拟机，然后在跑emulator。我需要把VM设置中的显示器中的图形渲染关闭，这一操作需要关闭虚拟机，重启后在运行emulator 验证就没有问题了。</p><h3 id="小结">小结</h3><ul><li>查看日志 使用<code>logcat -b all</code>，不清楚不要过滤处理，查看全部log</li><li>不确定的情况下，可以系统上直接启动/禁止<code>selinux</code>验证猜想，然后进一步调试</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="http://qiushao.net/2019/12/20/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/7-%E6%B7%BB%E5%8A%A0java%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-7.添加java层系统服务</a></li><li><a href="https://developer.android.com/guide/components/services" rel="external nofollow noopener noreferrer" target="_blank">官方文档 - 服务概览</a></li><li><a href="https://source.android.com/security/selinux" rel="external nofollow noopener noreferrer" target="_blank">官方文档- SELinux</a></li><li><a href="https://blog.csdn.net/u010753159/article/details/52193061" rel="external nofollow noopener noreferrer" target="_blank">Android 系统服务</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引入概念&quot;&gt;引入概念&lt;/h3&gt;
&lt;p&gt;目前对android系统体系了解比较少，主要区分一下&lt;code&gt;服务&lt;/code&gt;、&lt;code&gt;系统服务&lt;/code&gt;这两个概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.android.
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>04 添加预定义模块</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/04%20%E6%B7%BB%E5%8A%A0%E9%A2%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/04 添加预编译模块/</id>
    <published>2020-04-05T00:05:10.000Z</published>
    <updated>2020-04-05T00:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>在实际的系统开发过程中，有很多文件都是预先编译好的，比如第三方APK，so库, jar包， bin 文件，配置文件等。我们需要在系统编译时能把这些文件打包编译到系统镜像里面。</p><h3 id="操作准则">操作准则</h3><p>我们有两种方法可以达到我们的目的： PRODUCT_COPY_FILES 和 定义 prebuilt 模块。</p><ul><li>如果这个文件只需要预置到指定目录就可以了，那我们就可以简单的将其加入 PRODUCT_COPY_FILES 变量就行， 比如一些 bin 文件， 配置文件。</li><li>如果这个文件有其他模块编译依赖，或者这个文件需要系统签名，那我们就得定义一个预编译模块，比如一些 so 库，APK 文件， jar 包等。</li></ul><h3 id="添加预编译模块">添加预编译模块</h3><p>这里先记录一下添加预编译模块到<code>PRODUCT_COPY_FILES</code>的过程，另外如何定义prebuilt，方法请查看原文<br><a href="http://qiushao.net/2019/12/10/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/5-%E6%B7%BB%E5%8A%A0%E9%A2%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-5.添加预编译模块</a></p><p>1、 定义目录结构<br>为了维护方便，我们一般把 PRODUCT_COPY_FILES 的设置提取到一个单独的文件。在 $<a href="http://product.mk" rel="external nofollow noopener noreferrer" target="_blank">product.mk</a> 里面 include 就行。这里在pure目录下创建一个<code>prebuilt</code>目录如下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android<span class="number">-10</span>$ tree .<span class="regexp">/device/mi</span>/pure/prebuilt/</span><br><span class="line">.<span class="regexp">/device/mi</span>/pure/prebuilt/</span><br><span class="line">├── apk      <span class="comment"># 预置 apk 模块</span></span><br><span class="line">├── libs       <span class="comment"># 预置库模块，so 库， jar 包等</span></span><br><span class="line">└── vendor    <span class="comment"># PRODUCT_COPY_FILES 类型预置，按实际输出路径组织</span></span><br><span class="line">    └── bin</span><br><span class="line">        └── busybox-i686</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> directories, <span class="number">1</span> file</span><br></pre></td></tr></table></figure><p>2、下载bin文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>cd ./device/mi/pure/prebuilt/vendor/bin</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:bin</span><span class="variable">$ </span>wget <span class="symbol">https:</span>/<span class="regexp">/busybox.net/downloads</span><span class="regexp">/binaries/</span><span class="number">1.21</span>.<span class="number">1</span>/busybox-i686</span><br><span class="line">....</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:bin</span><span class="variable">$ </span>file busybox-i686</span><br><span class="line">busybox-<span class="symbol">i686:</span> ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), statically linked, stripped</span><br></pre></td></tr></table></figure><p>3、添加product_copy_files.mk</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:pure</span><span class="variable">$ </span>vim product_copy_files.mk</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:pure</span><span class="variable">$ </span>cat product_copy_files.mk</span><br><span class="line"><span class="comment"># product copy files</span></span><br><span class="line"></span><br><span class="line">LOCAL_PREBUILD_DIR <span class="symbol">:</span>= device/mi/pure/prebuilt</span><br><span class="line"></span><br><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line">    <span class="variable">$(</span>LOCAL_PREBUILD_DIR)/vendor/bin/busybox-<span class="symbol">i686:</span>vendor/bin/busybox</span><br></pre></td></tr></table></figure><p>4、在 $<a href="http://product.mk" rel="external nofollow noopener noreferrer" target="_blank">product.mk</a> 文件中 include</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:pure</span><span class="variable">$ </span>echo <span class="string">"include device/mi/pure/product_copy_files.mk"</span> &gt;&gt; product01.mk</span><br></pre></td></tr></table></figure><h3 id="编译验证">编译验证</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>source ./build/envsetup.sh</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>lunch product01-eng</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>make -j4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动emulator虚拟机</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>emulator</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># adb shell验证</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator<span class="number">-5554</span>device</span><br><span class="line"></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>adb shell busybox          <span class="comment"># 运行可执行文件</span></span><br><span class="line">BusyBox v1.<span class="number">21.1</span> (<span class="number">2013-07</span>-08 <span class="number">10:44</span><span class="symbol">:</span><span class="number">30</span> CDT) multi-call binary.</span><br><span class="line">BusyBox is copyrighted by many authors between <span class="number">1998-2012</span>.</span><br><span class="line">Licensed under GPLv2. See source distribution <span class="keyword">for</span> detailed</span><br><span class="line">copyright notices.</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://developer.android.com/ndk/guides/prebuilts?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">使用预编译库</a></li><li><a href="http://qiushao.net/2019/12/10/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/5-%E6%B7%BB%E5%8A%A0%E9%A2%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-5.添加预编译模块</a></li><li><a href="https://blog.csdn.net/kc58236582/article/details/51451202" rel="external nofollow noopener noreferrer" target="_blank">Android.mk编译目标(编译包、二进制文件、预编译）</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;在实际的系统开发过程中，有很多文件都是预先编译好的，比如第三方APK，so库, jar包， bin 文件，配置文件等。我们需要在系统编译时能把这些文件打包编译到系统镜像里面。&lt;/p&gt;
&lt;h3 id=&quot;操作准则&quot;&gt;操作准则&lt;/h3&gt;
&lt;
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>05 删除android内置apk</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/05%20%E5%88%A0%E9%99%A4Android%E5%8E%9F%E7%94%9F%E5%86%85%E7%BD%AEAPK/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/05 删除Android原生内置APK/</id>
    <published>2020-04-05T00:05:10.000Z</published>
    <updated>2020-04-05T00:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两种方法">两种方法</h3><p>为了在编译阶段将内置apk给异常，下面提供2中方法。</p><ul><li>直接找到添加这个apk的mk文件，从 PRODUCT_PACKAGES 中删除</li><li>通过添加模块，<code>LOCAL_OVERRIDES_PACKAGES</code>定义要覆盖的apk</li></ul><h3 id="目录结构">目录结构</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-<span class="number">10</span>$ tree ./device/mi/pure/</span><br><span class="line">./device/mi/pure/</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Android</span>.</span></span>mk</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">AndroidProducts</span>.</span></span>mk</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">BoardConfig</span>.</span></span>mk</span><br><span class="line">├── product01.mk</span><br></pre></td></tr></table></figure><h3 id="操作过程">操作过程</h3><p><strong>1、 直接从 PRODUCT_PACKAGES 中删除</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step1 找到apk添加到 PRODUCT_PACKAGES 的那个mk文件</span></span><br><span class="line">$ mgrep Contacts</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 从改mk文件中移除配置项</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 清理system目录，重新编译</span></span><br><span class="line">$ rm -rf out/target/product/pure/system</span><br><span class="line"></span><br><span class="line"><span class="comment"># step4 验证</span></span><br><span class="line">make -j4 &amp;&amp; emulator</span><br></pre></td></tr></table></figure><p><strong>2、 通过 LOCAL_OVERRIDES_PACKAGES 删除</strong></p><ol><li>在Product下添加一个模块<code>remove_unused_module</code></li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ vim Android.mk</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := remove_unused_module</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE_CLASS := FAKE     <span class="comment"># 指定编译输出的目录为 $(PRODUCT_OUT)/fake_packages</span></span><br><span class="line">LOCAL_MODULE_SUFFIX := <span class="variable">$(COMMON_ANDROID_PACKAGE_SUFFIX)</span></span><br><span class="line"></span><br><span class="line">LOCAL_OVERRIDES_PACKAGES += \</span><br><span class="line">   Contacts \</span><br><span class="line">   Email  <span class="comment">#这里添加要覆盖的apk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/base_rules.mk</span><br><span class="line"></span><br><span class="line"><span class="variable">$(LOCAL_BUILT_MODULE)</span>:</span><br><span class="line"><span class="variable">$(hide)</span> echo <span class="string">"Fake: <span class="variable">$@</span>"</span></span><br><span class="line"><span class="variable">$(hide)</span> mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line"><span class="variable">$(hide)</span> touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">PACKAGES.<span class="variable">$(LOCAL_MODULE)</span>.OVERRIDES := <span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(LOCAL_OVERRIDES_PACKAGES)</span>)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将<code>remove_unused_module</code>添加到对应product文件的PRODUCT_PACKAGES配置</li></ol><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PRODUCT_PACKAGES +</span>=<span class="string"> remove_unused_module</span></span><br></pre></td></tr></table></figure><ol start="3"><li>清理<code>out/target/product/pure/system</code>目录，验证</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf out/target/product/pure/system</span><br><span class="line">$ make -j4 &amp;&amp; emulator</span><br></pre></td></tr></table></figure><h3 id="原理补充-PRODUCT-PACKAGES">原理补充(PRODUCT_PACKAGES)</h3><p>对于第一种方法，通过<code>mgrep</code>命令能够搜索到这个mk文件定义了PRODUCT_PACKAGES，直接移除就ok。对于第二种方法，在 <a href="http://main.mk" rel="external nofollow noopener noreferrer" target="_blank">main.mk</a> 里面有对 <code>OVERRIDES_PACKAGES</code> 进行处理（在<a href="https://cs.android.com/android/platform/superproject/+/master:build/make/core/main.mk?q=_pif_overrides&amp;ss=android%2Fplatform%2Fsuperproject#1064" rel="external nofollow noopener noreferrer" target="_blank">android-10源码</a>中对这个关键词进行检索）</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># Lists most of the files a particular product installs, including:</span><br><span class="line"># - PRODUCT_PACKAGES, and their LOCAL_REQUIRED_MODULES</span><br><span class="line"># - PRODUCT_COPY_FILES</span><br><span class="line"># The base list of modules to build <span class="keyword">for</span> this product is specified</span><br><span class="line"># by the appropriate product definition <span class="keyword">file</span>, which was included</span><br><span class="line"># by product_config.mk.</span><br><span class="line"># Name resolution <span class="keyword">for</span> PRODUCT_PACKAGES:</span><br><span class="line">#   foo:<span class="number">32</span> resolves to foo_32;</span><br><span class="line">#   foo:<span class="number">64</span> resolves to foo;</span><br><span class="line">#   foo resolves to both foo and foo_32 (<span class="keyword">if</span> foo_32 is defined).</span><br><span class="line">#</span><br><span class="line"># Name resolution <span class="keyword">for</span> LOCAL_REQUIRED_MODULES:</span><br><span class="line">#   If a module is built <span class="keyword">for</span> <span class="number">2</span>nd arch, its required module resolves to</span><br><span class="line">#   <span class="number">32</span>-bit variant, <span class="keyword">if</span> it exits. See the <span class="keyword">select</span>-bitness-of-required-modules definition.</span><br><span class="line"># $(<span class="number">1</span>): product makefile</span><br><span class="line">define product-installed-files</span><br><span class="line">  $(<span class="keyword">eval</span> _mk := $(<span class="keyword">strip</span> $(<span class="number">1</span>))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules := \</span><br><span class="line">    $(PRODUCTS.$(_mk).PRODUCT_PACKAGES) \</span><br><span class="line">    $(<span class="keyword">if</span> $(<span class="keyword">filter</span> eng,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_ENG)) \</span><br><span class="line">    $(<span class="keyword">if</span> $(<span class="keyword">filter</span> debug,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_DEBUG)) \</span><br><span class="line">    $(<span class="keyword">if</span> $(<span class="keyword">filter</span> tests,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_TESTS)) \</span><br><span class="line">    $(<span class="keyword">if</span> $(<span class="keyword">filter</span> asan,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_DEBUG_ASAN)) \</span><br><span class="line">    $(call auto-included-modules) \</span><br><span class="line">  ) \</span><br><span class="line">  $(<span class="keyword">eval</span> ### Filter out the overridden packages and executables before doing expansion) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_overrides := $(call module-overrides,$(_pif_modules))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules := $(<span class="keyword">filter</span>-out $(_pif_overrides), $(_pif_modules))) \</span><br><span class="line">  $(<span class="keyword">eval</span> ### Resolve the :<span class="number">32</span> :<span class="number">64</span> module name) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules_32 := $(patsubst %:<span class="number">32</span>,%,$(<span class="keyword">filter</span> %:<span class="number">32</span>, $(_pif_modules)))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules_64 := $(patsubst %:<span class="number">64</span>,%,$(<span class="keyword">filter</span> %:<span class="number">64</span>, $(_pif_modules)))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules_rest := $(<span class="keyword">filter</span>-out %:<span class="number">32</span> %:<span class="number">64</span>,$(_pif_modules))) \</span><br><span class="line">  $(<span class="keyword">eval</span> ### Note <span class="keyword">for</span> <span class="number">32</span>-bit product, <span class="number">32</span> and <span class="number">64</span> will be added as their original module names.) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules := $(call get<span class="number">-32</span>-bit-modules-<span class="keyword">if</span>-we-can, $(_pif_modules_32))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules += $(_pif_modules_64)) \</span><br><span class="line">  $(<span class="keyword">eval</span> ### For the rest we add both) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules += $(call get<span class="number">-32</span>-bit-modules, $(_pif_modules_rest))) \</span><br><span class="line">  $(<span class="keyword">eval</span> _pif_modules += $(_pif_modules_rest)) \</span><br><span class="line">  $(call expand-required-modules,_pif_modules,$(_pif_modules),$(_pif_overrides)) \</span><br><span class="line">  $(<span class="keyword">filter</span>-out $(HOST_OUT_ROOT)/%,$(call module-installed-files, $(_pif_modules))) \</span><br><span class="line">  $(call resolve-product-relative-paths,\</span><br><span class="line">    $(foreach cf,$(PRODUCTS.$(_mk).PRODUCT_COPY_FILES),$(call word-colon,<span class="number">2</span>,$(cf))))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure><p>有定义<br><code>$(eval _pif_modules := $(filter-out $(_pif_overrides), $(_pif_modules)))</code><br><a href="https://seisman.github.io/how-to-write-makefile/functions.html#filter-out" rel="external nofollow noopener noreferrer" target="_blank">filter-out</a>是Makefile语法支持的函数，从<code>$(_pif_modules)</code>中 反选过滤出<code>$(_pif_overrides)</code>之外的所有modules。</p><blockquote><p>涉及到android build系统，我现在也还没搞清楚逻辑链，有待补充。</p></blockquote><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="http://qiushao.net/2019/12/12/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/6-%E5%88%A0%E9%99%A4%E5%8E%9F%E7%94%9F%E5%86%85%E7%BD%AEAPK/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-6.删除Android原生内置APK</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;两种方法&quot;&gt;两种方法&lt;/h3&gt;
&lt;p&gt;为了在编译阶段将内置apk给异常，下面提供2中方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接找到添加这个apk的mk文件，从 PRODUCT_PACKAGES 中删除&lt;/li&gt;
&lt;li&gt;通过添加模块，&lt;code&gt;LOCAL_OVERR
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>03 添加自定义模块</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/03%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/03 添加自定义模块/</id>
    <published>2020-04-05T00:04:10.000Z</published>
    <updated>2020-04-05T00:24:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景介绍">背景介绍</h3><p>早期的Android系统都是采用Android.mk的配置来编译源码，从Android 7.0开始引入Android.bp。<a href="http://xn--Android-y42nw38bzna.xn--bpAndroid-hp6ne0ab71ako7aqbvzqa225adod146f8hl.mk" rel="external nofollow noopener noreferrer" target="_blank">很明显Android.bp的出现就是为了替换掉Android.mk</a>。</p><ul><li>Android 7.0引入ninja和kati</li><li>Android <a href="http://8.xn--0Android-iu2m5322a.xn--bpAndroid-ww0s413a78a.mk" rel="external nofollow noopener noreferrer" target="_blank">8.0使用Android.bp来替换Android.mk</a>，引入Soong</li><li>Android 9.0强制使用Android.bp</li></ul><h3 id="添加模块">添加模块</h3><p>然后开始介绍如何通过Android.bp来引入一个<code>hello world</code>模块。<br>1、目录结构</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./device/mi/pure/hello/</span><br><span class="line">├── Android.bp</span><br><span class="line">└── hello.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>2.<code>hello.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"qiushao"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG ,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG ,__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello qiushao\n"</span>);</span><br><span class="line">    LOGD(<span class="string">"hello qiushao"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>Android.bp</code>文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_binary &#123;              <span class="comment">//模块类型为可执行文件</span></span><br><span class="line">    name: <span class="string">"hello"</span>,       <span class="comment">//模块名hello</span></span><br><span class="line">    srcs: [<span class="string">"hello.cpp"</span>], <span class="comment">//源文件列表</span></span><br><span class="line">    vendor: <span class="literal">true</span>,        <span class="comment">//编译出来放在/vendor目录下(默认是放在/system目录下)</span></span><br><span class="line">    shared_libs: [       <span class="comment">//编译依赖的动态库</span></span><br><span class="line">        <span class="string">"liblog"</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、编译hello模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:hello$ mma</span><br></pre></td></tr></table></figure><p>5、添加product配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:pure$ <span class="built_in">pwd</span></span><br><span class="line">/home/hinzer/<span class="built_in">source</span>/android-10/device/mi/pure</span><br><span class="line">hinzer@ubuntu:pure$ <span class="built_in">echo</span> <span class="string">"PRODUCT_PACKAGES += hello"</span> &gt;&gt; product01.mk</span><br></pre></td></tr></table></figure><p>6、整编android系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ <span class="built_in">source</span> ./build/envsetup.sh</span><br><span class="line">hinzer@ubuntu:android-10$ lunch product01-eng</span><br><span class="line">hinzer@ubuntu:android-10$ make -j4</span><br></pre></td></tr></table></figure><p>这是其中一个常见的模块实例，需要定义其他类型的模块时，可以参考以下<a href="http://119.29.209.28/Android/soong/soong_build.html" rel="external nofollow noopener noreferrer" target="_blank">文档soong</a>。或者参考系统已有的 Android.bp 模块。</p><h3 id="验证">验证</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>emulator</span><br><span class="line">...</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator<span class="number">-5554</span>device</span><br><span class="line"></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="variable">$ </span>adb shell hello          <span class="comment"># 运行可执行文件hello                                                                                                              </span></span><br><span class="line">hello qiushao</span><br></pre></td></tr></table></figure><h3 id="理论补充">理论补充</h3><p>1、模块编译输出分区</p><ul><li>system :主要包含 Android 框架， google 官方实现<ul><li><a href="http://Android.mk" rel="external nofollow noopener noreferrer" target="_blank">Android.mk</a> 默认就是输出到 system 分区，不用指定</li><li>Android.bp 默认就是输出到 system 分区，不用指定</li></ul></li><li>vendor :SoC芯片商分区(系统级核心厂商，如高通), 为他们提供一些核心功能和服务，由 soc 实现<ul><li><a href="http://Android.mk" rel="external nofollow noopener noreferrer" target="_blank">Android.mk</a> LOCAL_VENDOR_MODULE := true</li><li>Android.bp vendor: true</li></ul></li><li>odm :设备制造商分区（如华为、小米），为他们的传感器或外围设备提供一些核心功能和服务<ul><li><a href="http://Android.mk" rel="external nofollow noopener noreferrer" target="_blank">Android.mk</a> LOCAL_ODM_MODULE := true</li><li>Android.bp device_specific: true</li></ul></li><li>product :产品机型分区<ul><li><a href="http://Android.mk" rel="external nofollow noopener noreferrer" target="_blank">Android.mk</a> LOCAL_PRODUCT_MODULE := true</li><li>Android.bp product_specific</li></ul></li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/build" rel="external nofollow noopener noreferrer" target="_blank">Soong 编译系统</a></li><li><a href="http://qiushao.net/2019/11/22/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/4-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-4.添加自定义模块</a></li><li><a href="http://gityuan.com/2018/06/02/android-bp/" rel="external nofollow noopener noreferrer" target="_blank">理解Android.bp</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h3&gt;
&lt;p&gt;早期的Android系统都是采用Android.mk的配置来编译源码，从Android 7.0开始引入Android.bp。&lt;a href=&quot;http://xn--Android-y42nw38bzna.xn--bpAndro
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>01 添加Product</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/01%20%E6%B7%BB%E5%8A%A0Product/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/01 添加Product/</id>
    <published>2020-04-05T00:03:10.000Z</published>
    <updated>2020-04-05T00:23:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解概念">理解概念</h3><p>1、Product<br>在android源码正式编译之前选择Product，使用<code>lunch product-xxx</code>，这一步操作理解为预先对要编译的源码进行一系列的配置。在android-10的源码中，将一个Product配置分成三个部分:</p><ul><li><a href="http://BoardConfig.mk" rel="external nofollow noopener noreferrer" target="_blank">BoardConfig.mk</a>: 芯片硬件相关配置，分区设置等</li><li><a href="http://product.mk" rel="external nofollow noopener noreferrer" target="_blank">product.mk</a>: 一个产品的软件相关的配置，比如内置哪些软件模块，<a href="http://xn--AndroidProducts-ig40b.mk" rel="external nofollow noopener noreferrer" target="_blank">由AndroidProducts.mk</a> 中的PRODUCT_MAKEFILES指定</li><li><a href="http://AndroidProducts.mk" rel="external nofollow noopener noreferrer" target="_blank">AndroidProducts.mk</a>: 指定 product 配置,并把 product 添加到 lunch 选择项中</li></ul><p>2、组织结构<br>Google为AOSP源码内置了Product配置，位于源码的<code>build/target</code>目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:target$ pwd</span><br><span class="line">/home/hinzer/source/android-10/build/target</span><br><span class="line">hinzer@ubuntu:target$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── board</span><br><span class="line">├── OWNERS</span><br><span class="line">└── product</span><br><span class="line"></span><br><span class="line">2 directories, 1 file</span><br></pre></td></tr></table></figure><p>同时也允许第三方定制Product配置，在源码<code>device</code>目录下。待会自定义Product在这个目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:device$ tree mi </span><br><span class="line">mi # 公司名</span><br><span class="line">└── pure # device名(写为Product,与product区分),一个device可对应多个product</span><br><span class="line">    ├── AndroidProducts.mk  # 指定product配置，添加lunch选项</span><br><span class="line">    ├── BoardConfig.mk # 硬件配置 boardconfig</span><br><span class="line">    └── product01.mk # 软件配置 product</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><h3 id="自定义product">自定义product</h3><p>模仿aosp源码的Product配置,就引用了<code>build/target/board/generic_x86_64/BoardConfig.mk</code>和<code>build/target/board/generic_x86_64/BoardConfig.mk</code>的配置。然后进行自定义</p><p>1、创建<code>device/[company]/[device]</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ mkdir -p ./device/mi/pure</span><br></pre></td></tr></table></figure><p>2、分别添加<code>AndroidProducts.mk</code>、<code>product.mk</code>、<code>BoardConfig.mk</code>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:pure$ ls</span><br><span class="line">AndroidProducts.mk  BoardConfig.mk  product01.mk</span><br><span class="line"></span><br><span class="line"># 1.添加 AndroidProducts.mk</span><br><span class="line">hinzer@ubuntu:pure$ cat AndroidProducts.mk </span><br><span class="line">PRODUCT_MAKEFILES := \</span><br><span class="line">    $(LOCAL_DIR)/product01.mk   # 指定 product</span><br><span class="line"></span><br><span class="line">COMMON_LUNCH_CHOICES := \</span><br><span class="line">    product01-eng # 添加lunch选项</span><br><span class="line"></span><br><span class="line"># 2.添加 BoardConfig.mk </span><br><span class="line">hinzer@ubuntu:pure$ cat BoardConfig.mk </span><br><span class="line">include $(SRC_TARGET_DIR)/board/generic_x86_64/BoardConfig.mk  # 这里直接饮用</span><br><span class="line"></span><br><span class="line"># 3.添加 product01.mk </span><br><span class="line">hinzer@ubuntu:pure$ cat product01.mk </span><br><span class="line">$(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_x86_64.mk)</span><br><span class="line"></span><br><span class="line">PRODUCT_NAME   := product01 # product名(与文件保持一致)</span><br><span class="line">PRODUCT_DEVICE := pure      # device名，BoardConfig.mk相关</span><br></pre></td></tr></table></figure><p>3、lunch刚才创建的product，编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ <span class="built_in">source</span> ./build/envsetup.sh</span><br><span class="line">hinzer@ubuntu:android-10$ lunch product01-eng</span><br><span class="line">hinzer@ubuntu:android-10$ make -j4</span><br></pre></td></tr></table></figure><p>4、验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行虚拟机</span></span><br><span class="line">hinzer@ubuntu:android-10$ emulator   <span class="comment"># 查看Android version信息，编译时间、产品名是否对应</span></span><br></pre></td></tr></table></figure><h3 id="理论补充">理论补充</h3><p>1、<code>build variants</code><br>aosp为build系统提供三种Product配置，文档里叫做<a href="https://source.android.com/setup/develop/new-device#build-variants" rel="external nofollow noopener noreferrer" target="_blank"><code>build variants</code></a>,分别是:</p><ul><li>eng : 对应到工程版。编译打包所有模块。表示adbd处于ROOT状态，所有调试开关打开</li><li>userdebug : 对应到用户调试版。打开调试开关，但并没有放开ROOT权限</li><li>user : 对应到用户版。关闭调试开关，关闭ROOT权限。最终发布到用户手上的版本，通常都是user版。</li></ul><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/develop/new-device" rel="external nofollow noopener noreferrer" target="_blank">AOSP开发文档 - 添加新设备</a></li><li><a href="http://qiushao.net/2019/11/19/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/2-%E6%B7%BB%E5%8A%A0product/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-2.添加product</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解概念&quot;&gt;理解概念&lt;/h3&gt;
&lt;p&gt;1、Product&lt;br&gt;
在android源码正式编译之前选择Product，使用&lt;code&gt;lunch product-xxx&lt;/code&gt;，这一步操作理解为预先对要编译的源码进行一系列的配置。在android-10的源码
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>02 添加系统属性</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/02%20%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/02 添加系统属性/</id>
    <published>2020-04-05T00:03:10.000Z</published>
    <updated>2020-04-05T00:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解概念">理解概念</h3><p>1、基本描述<br>系统属性可以简单的理解为系统层级的全局变量，以<code>key-value</code>的形式保存， <code>key-value</code> 都是字符串。这些属性可能是有些资源的使用状态，进程的执行状态，系统的特有属性等。</p><p>2、命名规则<br>几种特殊前缀的属性</p><ul><li>ro ：只读属性，不能修改。</li><li>persist ：修改属性后，重启依然有效。数据会保存到 /data/property 目录。其他前缀的属性被设置后，只是保存在内在中而已，并没有保存到磁盘，所以重启后就恢复默认值了。</li><li>ctrl ：用来启动和停止服务。每一项服务必须在 init.rc 中定义。init 一旦收到设置 ctrl.start 属性的请求，属性服务将使用该属性值作为服务名找到该服务，启动该服务。这项服务的启动结果将会放入 init.svc.&lt;服务名&gt; 属性中。</li></ul><p>3、读写方法<br>在 Android 系统中有一个 Property Service 服务， 这个服务对外提供了两个接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SystemProperties.get(String key, String def) <span class="comment"># 读取系统属性</span></span><br><span class="line">SystemProperties.set(String key, String val) <span class="comment"># 设置系统属性</span></span><br></pre></td></tr></table></figure><p>有两个命令行对这两个接口进行了封装，我们可以直接在adb shell 中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getprop key <span class="comment"># 读取系统属性</span></span><br><span class="line">setprop key val <span class="comment"># 设置系统属性</span></span><br></pre></td></tr></table></figure><p>4、组织结构<br>系统启动的时候会从几个配置文件中加载属性的默认值，大概有以下几个文件， 在不同<code>Android版本系统</code>上可能不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/default.prop 或者是 /prop.default，</span><br><span class="line">/vendor/default.prop</span><br><span class="line">/system/build.prop</span><br><span class="line">/vendor/build.prop</span><br><span class="line">/data/local.prop</span><br><span class="line">/data/property/*</span><br></pre></td></tr></table></figure><p>系统会按先后顺序依次加载以上文件，后加载的属性将覆盖原先的值。<br>default.prop 的值是通过 build/tools 目录下的 <a href="http://buildinfo.sh" rel="external nofollow noopener noreferrer" target="_blank">buildinfo.sh</a> 和 vendor_buildinfo.sh 生成的。</p><h3 id="源码中添加系统属性定义">源码中添加系统属性定义</h3><p>在我们之前配置的product中添加自定义属性,在源码根目录<code>device/mi/pure</code>下,对应Build规则在<code>build/make/core/Makefile</code>,编译后输出到<code>out/target/product/pure</code>下，最终随系统启动加载对应的文件。<br>下面记录了添加属性过程<br>1、添加到<code>/system/build.prop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:pure$ pwd</span><br><span class="line">/home/hinzer/source/android-10/device/mi/pure</span><br><span class="line">hinzer@ubuntu:pure$ cat system.prop</span><br><span class="line">ro.pure.version=1.0 # 定义属性</span><br><span class="line">hinzer@ubuntu:pure$ cat BoardConfig.mk</span><br><span class="line">include $(SRC_TARGET_DIR)/board/generic_x86_64/BoardConfig.mk</span><br><span class="line"></span><br><span class="line">TARGET_SYSTEM_PROP += device/mi/pure/system.prop   # 添加到 TARGET_SYSTEM_PROP 变量</span><br></pre></td></tr></table></figure><p>2、添加到<code>/vendor/build.prop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:pure$ pwd</span><br><span class="line">/home/hinzer/source/android-10/device/mi/pure</span><br><span class="line">hinzer@ubuntu:pure$ cat product01.mk</span><br><span class="line">$(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_x86_64.mk)</span><br><span class="line"></span><br><span class="line">PRODUCT_NAME   := product01 # product名(与文件保持一致)</span><br><span class="line">PRODUCT_DEVICE := pure      # device名，BoardConfig.mk相关</span><br><span class="line"></span><br><span class="line"># 配置属性</span><br><span class="line">PRODUCT_PROPERTY_OVERRIDES += \</span><br><span class="line">    ro.vendor.pure.name=qiushao \</span><br><span class="line">    persist.vendor.pure.name=qiushao \</span><br><span class="line">    vendor.pure.name=qiushao</span><br></pre></td></tr></table></figure><h3 id="编译">编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:android-10$ <span class="built_in">source</span> ./build/envsetup.sh</span><br><span class="line">hinzer@ubuntu:android-10$ lunch product01-eng</span><br><span class="line">hinzer@ubuntu:android-10$ make -j4</span><br></pre></td></tr></table></figure><h3 id="验证">验证</h3><p>1、查看<code>out/target</code>目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 验证 `/system/build.prop`</span><br><span class="line">hinzer@ubuntu:android-10$ cat out/target/product/pure/system/build.prop  | grep ro.pure</span><br><span class="line">ro.pure.version=1.0</span><br><span class="line"></span><br><span class="line"># 验证 `/vendor/build.prop`</span><br><span class="line">hinzer@ubuntu:android-10$ cat out/target/product/pure/vendor/build.prop | grep pure.name</span><br><span class="line">ro.vendor.pure.name=qiushao</span><br><span class="line">persist.vendor.pure.name=qiushao</span><br><span class="line">vendor.pure.name=qiushao</span><br></pre></td></tr></table></figure><p>2、启动虚拟机系统查看属性</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>emulator</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator<span class="number">-5554</span>device</span><br><span class="line"></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb reboot  <span class="comment"># 重启一下，重置系统属性</span></span><br><span class="line"></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop ro.pure.version</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop ro.vendor.pure.name</span><br><span class="line">qiushao</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop persist.vendor.pure.name </span><br><span class="line">qiushao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只读属性不可改</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop ro.vendor.pure.name</span><br><span class="line">qiushao</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell setprop ro.vendor.pure.name hinzer</span><br><span class="line"><span class="symbol">setprop:</span> failed to set property <span class="string">'ro.vendor.pure.name'</span> to <span class="string">'hinzer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改属性，重启后恢复原属性值</span></span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell setprop persist.vendor.pure.name hinzer</span><br><span class="line">hinzer<span class="variable">@ubuntu</span><span class="symbol">:android-</span><span class="number">10</span><span class="variable">$ </span>adb shell getprop persist.vendor.pure.name </span><br><span class="line">hinzer</span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="http://qiushao.net/2019/11/20/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/3-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-3.添加系统属性</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解概念&quot;&gt;理解概念&lt;/h3&gt;
&lt;p&gt;1、基本描述&lt;br&gt;
系统属性可以简单的理解为系统层级的全局变量，以&lt;code&gt;key-value&lt;/code&gt;的形式保存， &lt;code&gt;key-value&lt;/code&gt; 都是字符串。这些属性可能是有些资源的使用状态，进程的执
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>00 配置开发环境</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/00%20%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Android系统开发/00 配置开发环境/</id>
    <published>2020-03-29T01:03:10.000Z</published>
    <updated>2020-03-29T13:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ubuntu系统环境">ubuntu系统环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:~$ uname -a</span><br><span class="line">Linux ubuntu 5.3.0-42-generic <span class="comment">#34~18.04.1-Ubuntu SMP Fri Feb 28 13:42:26 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><h3 id="配置android开发环境">配置android开发环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译所需的工具和相关库</span></span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line">sudo apt-get install -y git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libssl-dev libssl-dev openssl autoconf m4 libxml2-utils bc  libxml-simple-perl</span><br><span class="line"></span><br><span class="line"><span class="comment"># git和repo工具管理android源码</span></span><br><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:<span class="variable">$PATH</span></span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:~/bin'</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置git账信息</span></span><br><span class="line">git config --global user.name <span class="string">"xxx"</span></span><br><span class="line">git config --global user.email <span class="string">"xxxx@aaa.bb"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷写和调试工具</span></span><br><span class="line">sudo apt-get install adb -y</span><br><span class="line">sudo apt-get install fastboot -y</span><br><span class="line">sudo apt-get install android-tools-adb</span><br><span class="line">sudo apt-get install android-tools-fastboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置规则，解决无usb权限问题</span></span><br><span class="line">sudo touch /etc/udev/rules.d/70-android.rules</span><br><span class="line">sudo vim /etc/udev/rules.d/70-android.rules <span class="comment">#添加：SUBSYSTEM=="usb", MODE="0666" </span></span><br><span class="line">sudo chmod a+rx /etc/udev/rules.d/70-android.rules</span><br><span class="line">sudo service udev restart</span><br></pre></td></tr></table></figure><h3 id="下载android源码"><a href="https://source.android.com/setup/build/downloading" rel="external nofollow noopener noreferrer" target="_blank">下载android源码</a></h3><p>由于国内访问google镜像受限，推荐使用<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" rel="external nofollow noopener noreferrer" target="_blank">清华大学开源镜像站</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/<span class="built_in">source</span>/android-10</span><br><span class="line"><span class="built_in">cd</span> ~/<span class="built_in">source</span>/android-10</span><br><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r8   <span class="comment"># 拉取repo长裤，-u指定远程repo仓库url，-b指定获取特定分支branch</span></span><br><span class="line">repo sync <span class="comment"># 同步代码</span></span><br></pre></td></tr></table></figure><p>要要查看分支列表，请参<a href="https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds" rel="external nofollow noopener noreferrer" target="_blank">阅源代码标记和细分版本</a></p><h3 id="编译调试"><a href="https://source.android.com/setup/build/building#run-it" rel="external nofollow noopener noreferrer" target="_blank">编译调试</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整编源码</span></span><br><span class="line"><span class="built_in">source</span> ./build/envsetup.sh <span class="comment"># 导出所需环境变量</span></span><br><span class="line">lunch &lt;product_name&gt; <span class="comment"># 选择要编译的product</span></span><br><span class="line">make -j4 <span class="comment"># 开始编译，-j4表示使用4个线程编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行虚拟机</span></span><br><span class="line">emulator   <span class="comment"># 查看系统信息确认是我们刚刚编译的系统</span></span><br></pre></td></tr></table></figure><h3 id="参考资料">参考资料</h3><blockquote><ul><li><a href="https://source.android.com/setup/build/downloading#getting-the-files" rel="external nofollow noopener noreferrer" target="_blank">android源码公开文档 - 下载源代码</a></li><li><a href="https://source.android.com/setup/build/building" rel="external nofollow noopener noreferrer" target="_blank">android源码公开文档 - 编译系统</a></li><li><a href="http://qiushao.net/2019/11/15/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/0-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-0.开发环境准备</a></li><li><a href="http://qiushao.net/2019/11/16/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/1-Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/" rel="external nofollow noopener noreferrer" target="_blank">Android系统开发入门-1.Android系统源码下载编译</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ubuntu系统环境&quot;&gt;ubuntu系统环境&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Android系统开发" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="record" scheme="https://hinzer.github.io/wiki/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>03 系统调用</title>
    <link href="https://hinzer.github.io/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/03%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://hinzer.github.io/wiki/计算机基础/开发平台/Linux系统学习/03 系统调用/</id>
    <published>2020-03-28T09:31:02.000Z</published>
    <updated>2020-04-05T01:21:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关概念">相关概念</h3><p>1、程序vs进程vs命令<br>Linux系统上所有的操作由<code>进程</code>完成，<code>进程</code>的运行是动态的，在此之前是一个静态的<code>程序</code>。用户用一个程序来启动一个进程，这个程序可以是别人写好的(最终被编译成可执行文件)，比如<code>ls</code>、<code>pwd</code>、<code>cat</code>，也可以是我们自己写的。</p><p>2、系统调用<br>无论如何，程序最后运行起来都是进程，并且一个程序想要在系统上跑，要用到<code>系统调用</code>,这是系统给用户提供的API接口。</p><p>3、strace命令<br>Linux有个命令strace，常用来跟踪进程执行时系统调用和所接收的信号。通过<code>manstrace</code>查看具体描述。</p><p>4、Glibc<br>作为一个开发者，也许平时并没有直接使用系统调用，而是Glibc库。Glibc是Linux下使用的开源的标准C库它是GNU发布的libc库。<code>Glibc</code>即系统调用的封装。</p><h3 id="介绍系统调用">介绍系统调用</h3><p>然后本文开始介绍这些系统调用，先上图<br><img src="https://static001.geekbang.org/resource/image/ff/f0/ffb6847b94cb0fd086095ac263ac4ff0.jpg" alt="系统调用"></p><p>1、进程管理<br>linux操作系统使用叫<code>fork</code>的系统调用来创建进程，进程运行过程:</p><blockquote><p>当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。按理说，如果不进行特殊的处理，父进程和子进程都按相同的程序代码进行下去，这样就没有意义了。<br>所以，我们往往会这样处理：对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过if-else语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用execve来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支（fork）了。</p></blockquote><p>其他进程都是父进程fork出来的，对于操作系统而言，系统启动的时候先创建一个所有用户进程的“祖宗进程”。</p><p>2、内存管理<br>在操作系统中，每个进程都有自己的<code>进程内存空间</code>。其中布局就有<code>代码段</code>、<code>数据段</code>、<code>堆</code>。<br>一个进程的内存空间是很大的，32位的是4G，64位的就更大了。物理空间是有限的，所以进程的空间不能事先分配好的，一定是需要的时候再分配。<br><code>brk</code>和<code>mmap</code>是官员堆分配内存的系统调用，分配内存数量比较小的时候，使用<code>brk</code>会和原来的堆的数据连在一起。当分配的内存数量比较大的时候，使用mmap，会重新划分一块区域。</p><p>3、文件管理<br>文件系统相当于公司的资料库，用于保存一些永久性质的数据。能做到长期保存，文件之所以能做到这一点，一方面是因为<code>介质</code>，另一方面是因为<code>格式</code>。<br>对于文件的操作，无非是<code>创建</code>、<code>打开</code>、<code>读</code>、<code>写</code>等等,对应的系统调用常有:</p><blockquote><p>对于已经有的文件，可以使用open打开这个文件，close关闭这个文件；<br>对于没有的文件，可以使用creat创建文件；<br>打开文件以后，可以使用lseek跳到文件的某个位置；<br>可以对文件的内容进行读写，读的系统调用是read，写是write。</p></blockquote><p><a href="https://static001.geekbang.org/resource/image/e4/df/e49b5c2a78ac09903d697126bfe6c5df.jpeg" rel="external nofollow noopener noreferrer" target="_blank">Linux中一切皆文件</a>,就包括<code>二进制文件</code>、<code>文本文件</code>、<code>stdout文件</code>、<code>Socket文件</code>、<code>设备文件</code>、<code>目录文件</code>，包括进程运行起来在<code>/proc</code>下生成的进程号也是文件。<br>对于每一个文件，Linux分配了<code>文件描述符</code>，这是一个整数。</p><p>4、信号处理<br>信号是异步处理机制，用于紧急突发情况。常见信号有</p><blockquote><p>在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；<br>如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西；<br>硬件故障，设备出了问题，当然要通知项目组；<br>用户进程通过kill函数，将一个用户信号发送给另一个进程。<br>每一种信号都有默认动作，当然用户也能编写信号处理函数，通过<code>sigaction</code>系统调用进行处理。</p></blockquote><p>5、进程间通信<br>本地进程之间实现数据的互通，比较常见的处理机制有<code>消息队列</code>和<code>共享内存</code>。</p><ul><li>通过<code>msgget</code>创建一个新的队列，<code>msgsnd</code>将消息发送到消息队列，而消息接收方可以使用<code>msgrcv</code>从队列中取消息</li><li>我们可以通过<code>shmget</code>创建一个共享内存块，通过<code>shmat</code>将共享内存映射到自己的内存空间，然后就可以读写了。</li></ul><p>6、网络通信<br>内核中有TCP/IP网络协议栈的实现，可以通过socket来实现跨系统的进程间通信。</p><h3 id="查看源码中的系统调用">查看源码中的系统调用</h3><p><a href="https://www.kernel.org/" rel="external nofollow noopener noreferrer" target="_blank">下载内核源码</a>，找到<code>./include/asm-x86_64/unistd.h</code>文件，里面对于系统调用的定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hinzer@ubuntu:linux-2.6.11$ head ./include/asm-x86_64/unistd.h</span><br><span class="line"><span class="comment">#ifndef _ASM_X86_64_UNISTD_H_</span></span><br><span class="line"><span class="comment">#define _ASM_X86_64_UNISTD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef __SYSCALL</span></span><br><span class="line"><span class="comment">#define __SYSCALL(a,b) </span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This file contains the system call numbers.</span><br><span class="line"> *</span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><p><a href="https://time.geekbang.org/column/article/89251" rel="external nofollow noopener noreferrer" target="_blank">趣谈Linux操作系统 - 刘超</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;相关概念&quot;&gt;相关概念&lt;/h3&gt;
&lt;p&gt;1、程序vs进程vs命令&lt;br&gt;
Linux系统上所有的操作由&lt;code&gt;进程&lt;/code&gt;完成，&lt;code&gt;进程&lt;/code&gt;的运行是动态的，在此之前是一个静态的&lt;code&gt;程序&lt;/code&gt;。用户用一个程序来启动一个进程，
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="开发平台" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="Linux系统学习" scheme="https://hinzer.github.io/wiki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="note" scheme="https://hinzer.github.io/wiki/tags/note/"/>
    
      <category term="Linux" scheme="https://hinzer.github.io/wiki/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>bugreport</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/bugreport/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/bugreport/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-29T03:37:01.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>原生android系统支持<code>adb bugreport</code>命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误</p><p>1、目录结构</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">mi@</span>ubuntu:bugreport$ tree -L <span class="number">1</span></span><br><span class="line">.</span><br><span class="line">├── bugreport-dipper_ru-QKQ1<span class="number">.190828</span><span class="number">.002</span><span class="number">-2020</span><span class="number">-03</span><span class="number">-26</span><span class="number">-16</span><span class="number">-15</span><span class="number">-04.</span>txt  #最重要的文件</span><br><span class="line">├── dumpstate_board.txt</span><br><span class="line">├── dumpstate_log.txt</span><br><span class="line">├── FS</span><br><span class="line">├── lshal-debug</span><br><span class="line">├── main_entry.txt</span><br><span class="line">├── outfile.log</span><br><span class="line">├── proto</span><br><span class="line">└── version.txt</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">6</span> files</span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><p>1、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#anrs-deadlocks" rel="external nofollow noopener noreferrer" target="_blank">ANR和死锁</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 找出无响应的应用(系统会终止该进程并将堆栈转储到 /data/anr)</span><br><span class="line">grep &quot;am_anr&quot; bugreport-2015-10-01-18-13-48.txt  # 为二进制事件日志中的 am_anr 执行 grep 命令</span><br><span class="line">grep &quot;ANR in&quot; bugreport-2015-10-01-18-13-48.txt  # 为 logcat 日志（其中包含关于发生 ANR 时是什么在占用 CPU 的更多信息）中的 ANR in 执行 grep 命令</span><br><span class="line"></span><br><span class="line"># 查找堆栈跟踪( ANR 对应的堆栈跟踪 --&gt; 进程主线程)</span><br><span class="line">------ VM TRACES AT LAST ANR</span><br><span class="line">------ TRACES JUST NOW 和 </span><br><span class="line"></span><br><span class="line"># 查找死锁(系统服务器发生死锁，监控程序最终会将其终止)</span><br><span class="line">WATCHDOG KILLING SYSTEM PROCESS</span><br></pre></td></tr></table></figure><p>2、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#activities" rel="external nofollow noopener noreferrer" target="_blank">Activity</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看聚焦状态的activity(崩溃期间处于聚焦状态的 Activity 表示当前用户操作)</span><br><span class="line">grep &quot;am_focused_activity&quot; bugreport-2015-10-01-18-13-48.txt</span><br><span class="line"></span><br><span class="line"># 查看进程启动事件</span><br><span class="line">grep &quot;Start proc&quot; bugreport-2015-10-01-18-13-48.txt</span><br><span class="line"></span><br><span class="line"># 设备是否发生系统颠簸</span><br><span class="line">grep -e &quot;am_proc_died&quot; -e &quot;am_proc_start&quot; bugreport-2015-10-01-18-13-48.txt</span><br></pre></td></tr></table></figure><p>3、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#memory" rel="external nofollow noopener noreferrer" target="_blank">内存</a><br>4、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#broadcasts" rel="external nofollow noopener noreferrer" target="_blank">广播</a><br>5、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#monitor%20contention" rel="external nofollow noopener noreferrer" target="_blank">显示器争用</a><br>6、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#background-compilation" rel="external nofollow noopener noreferrer" target="_blank">后台编译</a><br>7、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#narrative" rel="external nofollow noopener noreferrer" target="_blank">叙述</a><br>8、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#power" rel="external nofollow noopener noreferrer" target="_blank">电源</a><br>9、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#packages" rel="external nofollow noopener noreferrer" target="_blank">程序包</a><br>10、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#processes" rel="external nofollow noopener noreferrer" target="_blank">进程</a><br>11、<a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn#scans" rel="external nofollow noopener noreferrer" target="_blank">扫描</a></p><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://developer.android.com/studio/debug/bug-report" rel="external nofollow noopener noreferrer" target="_blank">获取并阅读错误报告</a></li><li><a href="https://source.android.com/source/read-bug-reports.html?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">阅读错误报告</a></li><li><a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=181967386" rel="external nofollow noopener noreferrer" target="_blank">Android Log机制、Logcat及MIUI 284日志介绍</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;原生android系统支持&lt;code&gt;adb bugreport&lt;/code&gt;命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误&lt;/p&gt;
&lt;p&gt;1、目录结构&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Log" scheme="https://hinzer.github.io/wiki/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>bugreport</title>
    <link href="https://hinzer.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/logcat/"/>
    <id>https://hinzer.github.io/wiki/技术开发/测试方法/logcat/</id>
    <published>2020-03-28T00:28:37.000Z</published>
    <updated>2020-03-29T03:38:51.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解">理解</h3><p>logcat是抓log的工具，从android logging系统抓取日志。</p><p>1、logcat相关目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码位置：`/system/core/logcat/`</span><br><span class="line">编译生成的可执行文件位于：`out/target/product/umi/system/bin/logcat`(umi是产品名)</span><br><span class="line">对应到设备端的可执行文件：`/system/bin/logcat`</span><br></pre></td></tr></table></figure><p>2、日志缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">radio：查看包含无线装置/电话相关消息的缓冲区。</span><br><span class="line">events：查看已经过解译的二进制系统事件缓冲区消息。</span><br><span class="line">main：查看主日志缓冲区（默认），不包含系统和崩溃日志消息。</span><br><span class="line">system：查看系统日志缓冲区（默认）。</span><br><span class="line">crash：查看崩溃日志缓冲区（默认）。</span><br><span class="line">all：查看所有缓冲区。</span><br><span class="line">default：报告 main、system 和 crash 缓冲区。</span><br></pre></td></tr></table></figure><h3 id="使用规范">使用规范</h3><p>1、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#filteringOutput" rel="external nofollow noopener noreferrer" target="_blank">过滤日志输出</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag:priority  标记:优先级</span></span><br><span class="line">$ adb shell logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure><p>2、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#outputFormat" rel="external nofollow noopener noreferrer" target="_blank">控制日志输出格式</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -v &lt;format&gt;</span></span><br><span class="line">$ adb shell logcat -v thread</span><br></pre></td></tr></table></figure><p>3、<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn#alternativeBuffers" rel="external nofollow noopener noreferrer" target="_blank">查看备用日志缓冲区</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -b &lt;buffer&gt;</span></span><br><span class="line">$ adb shell logcat -b radio</span><br></pre></td></tr></table></figure><h3 id="命令速查">命令速查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取help</span></span><br><span class="line">$ adb shell logcat --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查log</span></span><br><span class="line">$ adb shell logcat -b system &gt; logSystem.txt  <span class="comment">#查询此时system的日志，并且保存在logSystem.txt的文件中</span></span><br><span class="line">^C</span><br></pre></td></tr></table></figure><h3 id="参考链接">参考链接</h3><blockquote><ul><li><a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">Logcat 命令行工具</a></li><li><a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=181967386" rel="external nofollow noopener noreferrer" target="_blank">Android Log机制、Logcat及MIUI 284日志介绍</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解&quot;&gt;理解&lt;/h3&gt;
&lt;p&gt;logcat是抓log的工具，从android logging系统抓取日志。&lt;/p&gt;
&lt;p&gt;1、logcat相关目录&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="技术开发" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="测试方法" scheme="https://hinzer.github.io/wiki/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="https://hinzer.github.io/wiki/tags/Android/"/>
    
      <category term="Log" scheme="https://hinzer.github.io/wiki/tags/Log/"/>
    
  </entry>
  
</feed>
