---
title: 04 x86架构
toc: false
date: 2020-04-05 8:32:02
tags: [Linux, note]
---



> 先了解计算机底层最基本的工作原理，以便于以后能理解Linux系统的运作模式!!

### 总体概要
原文中对于x86架构的总结图片，重点牢记这些寄存器的作用，以及段的工作模式
![总结概要](https://static001.geekbang.org/resource/image/e2/76/e2e92f2239fe9b4c024d300046536d76.jpeg)

### 计算机的工作模式(了解一下)
**1、 CPU、总线、内存**
![计算机的工作模式](https://static001.geekbang.org/resource/image/fa/9b/fa6c2b6166d02ac37637d7da4e4b579b.jpeg)
对于一个计算机来讲，所有功能看似是`输入输出设备`的功劳，实际干活的还是`CPU`。同时CPU通过内存不断的保存和取出中间数据，然后基于中间结果进行进一步的计算。`总线`是CPU和其他设备的高速通道。
- `CPU`是这台计算机的大脑，所有的设备都围绕它展开。
- `总线`其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。
- 最重要的是`内存`。因为单靠 CPU 是没办法完成计算任务的，很多复杂的计算任务都需要将中间结果保存下来，然后基于中间结果进行进一步的计算。

**2、相互配合工作**
![CPU 和内存](https://static001.geekbang.org/resource/image/3a/23/3afda18fc38e7e53604e9ebf9cb42023.jpeg)
首先要了解几个概念的关系，其中
- CPU包括三个部分，`运算单元`、`数据单元`和`控制单元`
- 进程在内存上有独立的内存空间，相互隔离(但不连续)，每个进程简单的区分`代码段`和`数据段`
- 总线上主要有两类，`地址总线`操作地址数据，`数据总线`操作真正的数据

> 那 CPU 怎么执行这些程序，操作这些数据，产生一些结果，并写入回内存呢?
1. CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。
2. 数据单元根据数据的地址，从数据段里读到数据寄存器里，就可以参与运算了。`指令 = 操作码(运算单元) + 操作数(数据单元)`
3. 运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。
4. 最终，会有指令将数据写回内存中的数据段。

### x86平台特性(了解一下)
x86架构起源于IBM,开端于8086。由于`开放、统一、兼容`的特性逐渐成为标准，后来Intel的cpu也都基于这个架构
![x86架构cpu](https://static001.geekbang.org/resource/image/54/8a/548dfd163066d061d1e882c73e7c2b8a.jpg)

### 8086的原理(了解一下)
![8086原理](https://static001.geekbang.org/resource/image/2d/1c/2dc8237e996e699a0361a6b5ffd4871c.jpeg)
**1、 数据单元**
8086处理器内部有 8 个 16 位的通用寄存器，有些寄存器还能掰开2个8位寄存器来使用。

**2、 控制单元**
`IP寄存器`指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。
每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS代码段寄存器、DS数据段寄存器、SS栈寄存器、ES。

**3、 访问地址模式**
这个时候内存是分段管理，CPU要访问内存地址通过`段启始地址 + 偏移量`的方式访问。其中，
- 代码段的起始地址在CS寄存器，偏移量在 IP 寄存器中
- 数据段的起始地址在DS寄存器，偏移量在通用寄存器中
由于是20位地址总线，而寄存器都是16位的。所以8086采用了`基地址 << 4 + 偏移量`的方式，其中
- 地址访问范围: 2^20 = 1M , 表示一个进程的最大访问空间
- 偏移量大小: 2^16=64k ， 表示一个段的最大空间


### 32位处理器(重点理解)
随着计算机的发展，32位总线已经足够应对4G内存。为了x86体系`开放、统一、兼容`的特性，要兼容原来的模式
![32位处理器](https://static001.geekbang.org/resource/image/e3/84/e3f4f64e6dfe5591b7d8ef346e8e8884.jpeg)
- 对于通用寄存器和IP寄存器有原来的16位扩展到32位，兼容原来的模式。
- 而改动比较大，有点不兼容的就是段寄存器(因为之前的20位总线设计太独特了)。其中有
	- 段的起始地址从原来放在寄存器中，改为放在内存的某个地方，当然为了快速拿到段起始地址，段寄存器会从内存中拿到 CPU 的描述符高速缓存器中。
	- cpu访问内存分位`实模式`和`保护模式`。其中`实模式`是对原来兼容的模式。


### 参考资料
> - [极客时间 - x86架构](https://time.geekbang.org/column/article/89417)
> - [x86 Assembly Guide](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html)
> - [Linux学习笔记《六》](https://www.cnblogs.com/bindot/p/linux6.html)