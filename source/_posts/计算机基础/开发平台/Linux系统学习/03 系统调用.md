---
title: 03 系统调用
toc: false
date: 2020-03-28 17:31:02
tags: [Linux, note]
---


### 相关概念
1、程序vs进程vs命令
Linux系统上所有的操作由`进程`完成，`进程`的运行是动态的，在此之前是一个静态的`程序`。用户用一个程序来启动一个进程，这个程序可以是别人写好的(最终被编译成可执行文件)，比如`ls`、`pwd`、`cat`，也可以是我们自己写的。

2、系统调用
无论如何，程序最后运行起来都是进程，并且一个程序想要在系统上跑，要用到`系统调用`,这是系统给用户提供的API接口。

3、strace命令
Linux有个命令strace，常用来跟踪进程执行时系统调用和所接收的信号。通过`manstrace`查看具体描述。

4、Glibc
作为一个开发者，也许平时并没有直接使用系统调用，而是Glibc库。Glibc是Linux下使用的开源的标准C库它是GNU发布的libc库。`Glibc`即系统调用的封装。


### 介绍系统调用
然后本文开始介绍这些系统调用，先上图
![系统调用](https://static001.geekbang.org/resource/image/ff/f0/ffb6847b94cb0fd086095ac263ac4ff0.jpg)

1、进程管理
linux操作系统使用叫`fork`的系统调用来创建进程，进程运行过程:

>当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。按理说，如果不进行特殊的处理，父进程和子进程都按相同的程序代码进行下去，这样就没有意义了。
>所以，我们往往会这样处理：对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过if-else语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用execve来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支（fork）了。

其他进程都是父进程fork出来的，对于操作系统而言，系统启动的时候先创建一个所有用户进程的“祖宗进程”。

2、内存管理
在操作系统中，每个进程都有自己的`进程内存空间`。其中布局就有`代码段`、`数据段`、`堆`。
一个进程的内存空间是很大的，32位的是4G，64位的就更大了。物理空间是有限的，所以进程的空间不能事先分配好的，一定是需要的时候再分配。
`brk`和`mmap`是官员堆分配内存的系统调用，分配内存数量比较小的时候，使用`brk`会和原来的堆的数据连在一起。当分配的内存数量比较大的时候，使用mmap，会重新划分一块区域。

3、文件管理
文件系统相当于公司的资料库，用于保存一些永久性质的数据。能做到长期保存，文件之所以能做到这一点，一方面是因为`介质`，另一方面是因为`格式`。
对于文件的操作，无非是`创建`、`打开`、`读`、`写`等等,对应的系统调用常有:
>对于已经有的文件，可以使用open打开这个文件，close关闭这个文件；
>对于没有的文件，可以使用creat创建文件；
>打开文件以后，可以使用lseek跳到文件的某个位置；
>可以对文件的内容进行读写，读的系统调用是read，写是write。

[Linux中一切皆文件](https://static001.geekbang.org/resource/image/e4/df/e49b5c2a78ac09903d697126bfe6c5df.jpeg),就包括`二进制文件`、`文本文件`、`stdout文件`、`Socket文件`、`设备文件`、`目录文件`，包括进程运行起来在`/proc`下生成的进程号也是文件。
对于每一个文件，Linux分配了`文件描述符`，这是一个整数。

4、信号处理
信号是异步处理机制，用于紧急突发情况。常见信号有
>在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；
>如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西；
>硬件故障，设备出了问题，当然要通知项目组；
>用户进程通过kill函数，将一个用户信号发送给另一个进程。
每一种信号都有默认动作，当然用户也能编写信号处理函数，通过`sigaction`系统调用进行处理。

5、进程间通信
本地进程之间实现数据的互通，比较常见的处理机制有`消息队列`和`共享内存`。
- 通过`msgget`创建一个新的队列，`msgsnd`将消息发送到消息队列，而消息接收方可以使用`msgrcv`从队列中取消息
- 我们可以通过`shmget`创建一个共享内存块，通过`shmat`将共享内存映射到自己的内存空间，然后就可以读写了。

6、网络通信
内核中有TCP/IP网络协议栈的实现，可以通过socket来实现跨系统的进程间通信。


### 查看源码中的系统调用
[下载内核源码](https://www.kernel.org/)，找到`./include/asm-x86_64/unistd.h`文件，里面对于系统调用的定义
```bash
hinzer@ubuntu:linux-2.6.11$ head ./include/asm-x86_64/unistd.h
#ifndef _ASM_X86_64_UNISTD_H_
#define _ASM_X86_64_UNISTD_H_

#ifndef __SYSCALL
#define __SYSCALL(a,b) 
#endif

/*
 * This file contains the system call numbers.
 *
```

### 参考
[趣谈Linux操作系统 - 刘超](https://time.geekbang.org/column/article/89251)
