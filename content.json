{"pages":[{"title":"关于我","date":"2019-09-04T06:42:42.000Z","path":"about/index.html","text":"姓名：王建峰 家乡：蚌埠 居住：北京 现状：在职 爱好：读书、健身、编程、看电影。 口号：永远相信美好的事情即将发生。 技能：能够熟练掌握一门技术，了解多门编程语言,能快速实现一个功能，成为一名合格的工程师 博客：通过读一些优秀的博客，感到佩服，也希望能够写出高质量的博客(能将内容阐述清晰，有自己的思想) 阅读：多读一些优秀的作品和书籍，有机会能交流一下也是不错的 CSDN WIKI Blog"},{"title":"Categories","date":"2020-03-15T04:45:57.676Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-03-15T04:45:57.676Z","path":"tags/index.html","text":""}],"posts":[{"title":"11 进程用户栈和内核栈","date":"2020-04-18T22:21:14.654Z","path":"计算机基础/开发平台/Linux系统学习/11 进程用户栈和内核栈/","text":"介绍&amp;目的 1、 介绍 在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。无论是进程还是线程，对应到内核里面，我们统一都叫任务（Task），由一个统一的结构 task_struct 进行管理。 其中，内核栈是和进程运行有关系的。相关的成员变量有 12struct thread_info thread_info;void *stack; 嗯，先上图 2、 目的 以下整理的资料大致包括 用户态函数栈，内核态函数栈栈的组成 进程从用户态到内核态的上下文切换 内核态中通过stask_struct管理内核栈 用户态函数栈 在数据结构中学过的栈模型，是一种高度抽象的设计。函数调用和返回也是按照栈的思想来设计的，在虚拟内存空间中自上而下分配。具体在32系统和64系统的实现方式，略微不同 1、 32位系统 我们先来看 32 位操作系统的情况。在 CPU 里，ESP（Extended Stack Pointer）是栈顶指针寄存器，入栈操作 Push 和出栈操作 Pop 指令，会自动调整 ESP 的值。另外有一个寄存器 EBP（Extended Base Pointer），是栈基地址指针寄存器，指向当前栈帧的最底部。 . 例如，A 调用 B，A 的栈里面包含 A 函数的局部变量，然后是调用 B 的时候要传给它的参数，然后返回 A 的地址，这个地址也应该入栈，这就形成了 A 的栈帧。接下来就是 B 的栈帧部分了，先保存的是 A 栈帧的栈底位置，也就是 EBP。因为在 B 函数里面获取 A 传进来的参数，就是通过这个指针获取的，接下来保存的是 B 的局部变量等等。 . 当 B 返回的时候，返回值会保存在 EAX 寄存器中，从栈中弹出返回地址，将指令跳转回去，参数也从栈中弹出，然后继续执行 A。 2、 64位系统 64 位操作系统的寄存器数目比较多。rax 用于保存函数调用的返回结果。栈顶指针寄存器变成了 rsp，指向栈顶位置。堆栈的 Pop 和 Push 操作会自动调整 rsp，栈基指针寄存器变成了 rbp，指向当前栈帧的起始位置。 . 改变比较多的是参数传递。rdi、rsi、rdx、rcx、r8、r9 这 6 个寄存器，用于传递存储函数调用时的 6 个参数。如果超过 6 的时候，还是需要放到栈里面。 . 然而，前 6 个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的。 内核态函数栈 0、 函数栈模型 进程通过函数调用进入内核态，内核中也有函数调用，也有一个内核栈。 ps: 在arch/x86/include/asm/page_32_types.h或者arch/x86/include/asm/page_64_types.h定义了内核栈大小THREAD_SIZE。 thread_info结构是对 task_struct 结构的补充，往往与体系结构有关的，都放在 thread_info 里面。 在内核代码里面有这样一个 union，将 thread_info 和 stack 放在一起，在include/linux/sched.h文件中就有。 pt_regs结构，在系统从用户态切换到内核态的时候，将用户态上下文信息保存到这里。在32系统和64系统中的定义不一样。 1、 通过 task_struct 找内核栈 2、 通过内核栈找 task_struct 参考资料 极客时间专栏 - 进程数据结构（下）：项目多了就需要项目管理系统","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"10 进程数据结构task_struct","date":"2020-04-18T22:19:49.150Z","path":"计算机基础/开发平台/Linux系统学习/10 进程数据结构task_struct/","text":"基本概念 在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构task_struct进行管理。 分析task_struct 对源码检索stask_struct关键字，发现文件include/linux/sched.h有这个结构体定义,结构非常长。下面借用专栏中总结的框图 补充知识 1、 系统上查看进程信息 可以通过/proc/pid下的文件查看进程的相关信息。或者直接通过一些常用命令,比如 ps查看进程 pstree查看进程的依赖关系 lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。和fuser命令用于报告进程使用的文件和网络套接字。 参考资料 极客时间专栏 - 进程数据结构（上）：项目多了就需要项目管理系统 极客时间专栏 - 进程数据结构（中）：项目多了就需要项目管理系统","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"09 了解与创建线程","date":"2020-04-18T22:19:05.420Z","path":"计算机基础/开发平台/Linux系统学习/09 了解与创建线程/","text":"介绍&amp;目的 之前了解了进程的创建过程，其实进程默认也有一个主线程(也可以包含其他线程)。线程是负责执行二进制指令的，它会根据项目执行计划书，一行一行执行下去。进程要比线程管的宽多了，除了执行指令之外，内存、文件系统等等都要它来管。 例如，此时有一个开发网站的项目。我们想把它拆解成多个网页任务，并行执行，最后做一个整合。类似的，在程序实现上，也可以将一个功能拆分成多个子任务。可以使用多进程的并行方案，但是有两个问题 第一，创建进程占用资源太多； 第二，进程之间的通信需要数据在不同的内存空间传来传去，无法共享。 使用多线程可以很好的解决这两个问题(多个线程是共享一个进程的资源)。那么，如何创建一个线程任务，线程间又如何对数据操作的呢？ 下面整理的资料主要为解决这个问题。 代码示例 1、 编辑&amp;编译&amp;运行 # download.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//download.c#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#define NUM_OF_TASKS 5void *downloadfile(void *filename)&#123; printf(\"I am downloading the file %s!\\n\", (char *)filename); sleep(5); long downloadtime = rand()%100; printf(\"I finish downloading the file within %d minutes!\\n\", downloadtime); pthread_exit((void *)downloadtime);&#125;int main(int argc, char *argv[])&#123; char files[NUM_OF_TASKS][20]=&#123;\"file1.avi\",\"file2.rmvb\",\"file3.mp4\",\"file4.wmv\",\"file5.flv\"&#125;; pthread_t threads[NUM_OF_TASKS]; // 声明线程对象 int rc; int t; int downloadtime[NUM_OF_TASKS]; // 声明线程属性 pthread_attr_t thread_attr; pthread_attr_init(&amp;thread_attr); pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_JOINABLE); for(t=0;t&lt;NUM_OF_TASKS;t++)&#123; printf(\"creating thread %d, please help me to download %s\\n\", t, files[t]); rc = pthread_create(&amp;threads[t], &amp;thread_attr, downloadfile, (void *)files[t]); // 创建线程 if (rc)&#123; printf(\"ERROR; return code from pthread_create() is %d\\n\", rc); exit(-1); &#125; &#125; pthread_attr_destroy(&amp;thread_attr); // 销毁线程属性 for(t=0;t&lt;NUM_OF_TASKS;t++)&#123; pthread_join(threads[t],(void**)&amp;downloadtime[t]); //获取其他线程的返回值 printf(\"Thread %d downloads the file %s in %d minutes.\\n\",t,files[t],downloadtime[t]); &#125; pthread_exit(NULL); // 结束线程，返回NULL&#125; # 编译 1gcc download.c -lpthread # 运行 123456789101112131415161718192021# ./a.outcreating thread 0, please help me to download file1.avicreating thread 1, please help me to download file2.rmvbI am downloading the file file1.avi!creating thread 2, please help me to download file3.mp4I am downloading the file file2.rmvb!creating thread 3, please help me to download file4.wmvI am downloading the file file3.mp4!creating thread 4, please help me to download file5.flvI am downloading the file file4.wmv!I am downloading the file file5.flv!I finish downloading the file within 83 minutes!I finish downloading the file within 77 minutes!I finish downloading the file within 86 minutes!I finish downloading the file within 15 minutes!I finish downloading the file within 93 minutes!Thread 0 downloads the file file1.avi in 83 minutes.Thread 1 downloads the file file2.rmvb in 86 minutes.Thread 2 downloads the file file3.mp4 in 77 minutes.Thread 3 downloads the file file4.wmv in 93 minutes.Thread 4 downloads the file file5.flv in 15 minutes. 2、 总体流程 线程数据 1、 线程数据分类 线程栈上的本地数据，相当于函数中的局部变量。通过ulimit -a命令查看线程栈的空间大小。 在整个进程里共享的全局数据，相当于程序中的全部变量。多个线程同时对共享资源访问会造成冲突，所以需要额外的机制控制。 线程私有数据，通过key-value形式存储。通过函数接口操作。多线程可以使用同一个key值，但是各自有不同的value；在线程退出自动析构释放value。 2、 总结框图 3、 对共享数据的访问 使用同步互斥机制 - 互斥锁(Mutex) - 互斥锁(Mutex) + 条件变量 - 信号量 补充知识 1、 线程同步互斥机制 待补充 参考资料 极客专栏 - 线程：如何让复杂的项目并行执行？ 线程同步和互斥的区别","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"08 进程的出生过程","date":"2020-04-18T22:16:42.643Z","path":"计算机基础/开发平台/Linux系统学习/08 进程的出生过程/","text":"目的 对于进程，可以通过别人写好的程序(比如Linux命令)或者自己写的程序(编译后生成可执行文件)，加载到内存后执行就视为一个进程。 这些我已经了解，OK，那么在学习一下代码到二进制文件的过程是什么、系统如何识别二进制文件、如何加载到内存并运行成一个进程，另外如何从代码中创建一个新进程？ 这次整理笔记的主要内容，也是本次学习的目的: 了解代码编译成二进制文件，生成库文件或者可执行文件的过程 了解系统加载二进制文件的机制，如何产生一个进程 了解如何调用fork创建一个进程 相关知识补充(ELF文件格式、Linux系统进程树、查看文件格式工具) 代码示例 运行一个demo，主要功能是主进程通过系统调用fork一个新的进程，子进程功能是加载二进制文件，运行ls命令。 1、 目录结构 123456[root@VM_16_8_centos test]# tree ..|-- createprocess.c`-- process.c0 directories, 2 files 2、 编辑&amp;编译&amp;运行 # process.c 123456789101112131415161718192021// process.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;extern int create_process (char* program, char** arg_list);int create_process (char* program, char** arg_list)&#123; pid_t child_pid; child_pid = fork (); // 1.创建子进程 if (child_pid != 0) return child_pid; else &#123; execvp (program, arg_list); //2.子进程通过execvp去运行一个新的程序 abort (); &#125;&#125; # createprocess.c 1234567891011121314151617181920// createprocess.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;extern int create_process (char* program, char** arg_list);int main ()&#123; char* arg_list[] = &#123; \"ls\", \"-l\", \"/etc/yum.repos.d/\", NULL &#125;; create_process (\"ls\", arg_list); //让子进程执行ls命令 return 0;&#125; # 编译 123456789101112131415161718192021#### 第一种方式 ##### 编译成.o文件gcc -c -fPIC process.cgcc -c -fPIC createprocess.c# 生成库文件ar cr libstaticprocess.a process.o # process.o编译成静态库# 链接为可执行文件gcc -o staticcreateprocess createprocess.o -L. -lstaticprocess#### 第二种方式 ##### 编译成.o文件gcc -c -fPIC process.cgcc -c -fPIC createprocess.c# 生成库文件gcc -shared -fPIC -o libdynamicprocess.so process.o # process.o编译成共享库# 链接为可执行文件gcc -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess # 运行 123456789101112#### 第一种方式 ####$ ./staticcreateprocess$ total 40-rw-r--r--. 1 root root 1572 Oct 24 18:38 CentOS-Base.repo......#### 第二种方式 ####$ export LD_LIBRARY_PATH=.$ ./dynamiccreateprocess$ total 40-rw-r--r--. 1 root root 1572 Oct 24 18:38 CentOS-Base.repo...... 3、 总体框图 图右边的文件编译过程，生成 so 文件和可执行文件,后面对部分内容整理。 图左边对刚才的代码进行补充:用户态的进程 A 执行 fork，创建进程 B，在进程 B 的处理逻辑中，执行 exec 系列系统调用。这个系统调用会通过 load_elf_binary 方法，将刚才生成的可执行文件，加载到进程 B 的内存中执行。 编译和链接 1、文本文件转换到二进制文件 编译工具链将我们写好的代码转换成二进制文件，在Linux系统中识别的是elf格式的二进制文件。大致流程为 elf格式有可重定位文件、可执行文件、动态链接库几种类型。 运行程序为进程 如何将elf格式的二进制程序加载到内存运行的呢？ 1、 内核源码 内核中定义加载二进制文件的方法 12345678struct linux_binfmt &#123; struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump; /* minimal dump size */&#125; __randomize_layout; 对于 ELF 文件格式，有对应的实现 1234567static struct linux_binfmt elf_format = &#123; .module = THIS_MODULE, .load_binary = load_elf_binary, .load_shlib = load_elf_library, .core_dump = elf_core_dump, .min_coredump = ELF_EXEC_PAGESIZE,&#125;; 对于方法load_elf_binary ，源码中有调用链: do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler。 而do_execve 其实被一组exec的系统调用实现 1234567SYSCALL_DEFINE3(execve, const char __user *, filename, const char __user *const __user *, argv, const char __user *const __user *, envp)&#123; return do_execve(getname(filename), argv, envp);&#125; 2、 理解 之前子进程代码中执行了方法exec，运行一个elf文件。其实通过命令行执行一个程序的时候，也有类似的实现。通过strace命令查看其中一个命令执行了哪些系统调用 1234[root@VM_16_8_centos demo]# strace lsexecve(&quot;/usr/bin/ls&quot;, [&quot;ls&quot;], [/* 28 vars */]) = 0brk(NULL) = 0xb87000.... fork()产生新进程 所有进程都是从父进程fork过来的，那总归有一个祖宗进程，这就是咱们系统启动的init进程。下面是linux进程树，也可以通过ps -ef命令查看 补充知识 1、 了解ELF文件格式 ELF格式有可重定位文件、可执行文件、动态链接库几种类型。 第一种是可重定位文件，也就是代码编译后生成的.o文件，这类文件还没有被链接，所以相当于一个代码片段。 第二种是可执行文件，链接后的程序，可直接加载到虚拟内存上运行的一类文件。 第三种是动态链接库,生成的库文件，动态库能被多个程序共享。程序并没有将动态库的代码包含进去(静态库的方式)，相当于仅仅包括对动态链接库的引用。 文件格式 (了解后在补充) 2、 了解Linux系统中的进程，如查看进程 命令ps -ef查看Linux系统中的进程 12345678910111213[root@VM_16_8_centos demo]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Mar01 ? 00:05:19 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root 2 0 0 Mar01 ? 00:00:00 [kthreadd]root 3 2 0 Mar01 ? 00:01:40 [ksoftirqd/0]root 5 2 0 Mar01 ? 00:00:00 [kworker/0:0H]root 7 2 0 Mar01 ? 00:00:00 [migration/0]root 8 2 0 Mar01 ? 00:00:00 [rcu_bh]root 9 2 0 Mar01 ? 00:04:46 [rcu_sched]root 10 2 0 Mar01 ? 00:00:00 [lru-add-drain]root 11 2 0 Mar01 ? 00:00:16 [watchdog/0]root 13 2 0 Mar01 ? 00:00:00 [kdevtmpfs].... 3、 几种查看文件格式的工具 readelf 工具用于分析 ELF 的信息， objdump 工具用来显示二进制文件的信息， hexdump 工具用来查看文件的十六进制编码， nm 工具用来显示关于指定文件中符号的信息。 参考资料 极客时间专栏 - 进程：公司接这么多项目，如何管？","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"08 Android-bp条件编译","date":"2020-04-11T00:29:58.036Z","path":"计算机基础/开发平台/Android系统开发/08 Android-bp条件编译/","text":"基本概念 1、 背景 条件编译为我们提供了一种一套代码兼容多个版本的解决方案，提高代码的复用率。 在Android7.0之前使用的是Makefle编译，makefile语法支持条件编译，配置到Android.mk文件。 在那以后，开始使用Ninja编译框架，只需要我们配置Android.bp文件，但是bp文件就是一个配置文件，不支持条件编译。 但条件编译又是强需求，所以 google 还是提供了一种条件编译的方法，下面我们就来学习一下。 2、 目的 把 platform sdk version 传给一个 Android.bp 模块的 cpp 代码。 3、 文件组织结构 1234567hinzer@ubuntu:android-10$ tree ./device/mi/pure/hello./device/mi/pure/hello # 我们要编译的hello模块├── Android.bp # ├── hello.cpp # └── hello.go # 0 directories, 3 files 关键步骤 1、 模块编译规则（Android.bp） 123456789101112131415161718192021222324252627282930313233// add startbootstrap_go_package &#123; name: \"soong-hello\", pkgPath: \"android/soong/hello\", deps: [ \"soong-android\", \"soong-cc\", ], srcs: [ \"hello.go\", ], pluginFor: [\"soong_build\"],&#125;cc_hello_binary &#123; name: \"hello_defaults\",&#125;// add endcc_binary &#123; name: \"hello\", // add start defaults: [\"hello_defaults\"], // add end srcs: [\"hello.cpp\"], vendor: true, shared_libs: [ ],&#125; 查看Android.bp中已知的模块类型，其中 类型为bootstrap_go_package的模块名soong-hello，指定了源文件hello.go。 类型cc_hello_binary是在hello.go里面进行定义，这里相当于编译条件。 类型cc_binary的模块名hello，通过hello_defaults模块合入配置，并编译源文件hello.cpp成二进制文件。 2、 添加hook机制（hello.go） 123456789101112131415161718192021222324252627282930package helloimport ( \"android/soong/android\" \"android/soong/cc\" \"fmt\")func init() &#123; android.RegisterModuleType(\"cc_hello_binary\", helloDefaultsFactory)&#125;func helloDefaultsFactory() (android.Module) &#123; module := cc.DefaultsFactory() android.AddLoadHook(module, helloHook) return module&#125;func helloHook(ctx android.LoadHookContext) &#123; //AConfig() function is at build/soong/android/config.go fmt.Println(\"PlatformSdkVersion = \", ctx.AConfig().PlatformSdkVersion()) fmt.Println(\"DeviceName = \", ctx.AConfig().DeviceName()) type props struct &#123; Cflags []string &#125; p := &amp;props&#123;&#125; p.Cflags = append(p.Cflags, \"-DPLATFORM_SDK_VERSION=\" + ctx.AConfig().PlatformSdkVersion()) ctx.AppendProperties(p)&#125; hello.go文件中配置hook机制，首先定义模块类型cc_hello_binary，然后是hook处理函数helloHook。如果这个cc_hello_binary被定义，表示编译条件成立，触发hook处理函数 init()里面注册了一个新的模块类型 cc_hello_binary 对应的函数是helloDefaultsFactory(),需要注意的是其中cc.DefaultsFactory要根据模块类型的不同而不同,参考build/soong/cc/xxx.go中的定义 最后我们希望的条件编译内容可以在hook中定义，通过ctx来获取和添加配置信息，可添加的配置类型参考类型props的定义 3、 使用传入的配置（hello.cpp） 123456#include &lt;cstdio&gt;int main() &#123; printf(\"PLATFORM_SDK_VERSION = %d\\n\", PLATFORM_SDK_VERSION); return 0;&#125; 4、 将模块添加到Build系统（product.mk） 将模块添加到product.mk文件中的PRODUCT_PACKAGES变量(模块会随着编译打包到android系统中)。 编译验证 1234567891011hinzer@ubuntu:android-10$ mm hello...hinzer@ubuntu:android-10$ emulator -wipe-data...hinzer@ubuntu:android-10$ adb shelladb server version (41) doesn't match this client (39); killing...* daemon started successfullypure:/ # hello # 模块加载PLATFORM_SDK_VERSION = 29pure:/ # ^C130|pure:/ # exit 思考总结 Android.bp只是一个json格式的配置文件，不支持条件语句，不支持控制流程语句。所有复杂问题都由用Go编写的编译逻辑处理。 对于bp文件，了解json格式，其他的靠以后慢慢积累；对于go语言，也不用单独学习，以后多写几个demo，总结套路就好。 参考资料 官方文档 - Soong编译系统 Android.bp 条件编译","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"07 深入系统调用","date":"2020-04-11T00:23:09.155Z","path":"计算机基础/开发平台/Linux系统学习/07 深入系统调用/","text":"目的 进程访问核心资源通过系统调用。站在系统调用的角度，层层深入下去，就能从某个系统调用的场景出发，了解内核中各个模块的实现机制。 但是在实际开发中不会直接使用系统调用，因为Linux 还提供了glibc这个中介。它更熟悉系统调用的细节，并且可以封装成更加友好的接口。 glibc 的官网：http://www.gnu.org/software/libc/ 下载glibc源码: git clone git://sourceware.org/git/glibc.git linux kernel官网: https://www.kernel.org/ linux源码获取: https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.14.175.tar.xz 本文目标：从glibc提供的open函数出发，剖析如何从glibc的open调用到内核的open!!! glibc封装、系统实现 1、 glibc封装 我们用户进程调用的glibc库封装的open函数，在glibc的源代码中，有以下相关文件 1234./sysdeps/unix/syscalls.list # 列出所有glibc的函数对应的系统调用./sysdeps/unix/make-syscalls.sh # 根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件./sysdeps/unix/syscall-template.S # 定义了这个系统调用的调用方式./sysdeps/hppa/sysdep.h # 通过 `vim -t PSEUDO` 找到 PSEUDO 这个宏的定义。 经过分析代码open函数的代码逻辑,得出结论: 对于任何的系统调用，会调用DO_CALL。这也是一个宏，这个宏 32 位和 64 位的定义是不一样的。 2、 系统调用过程 # 32位系统平台 继续分析glibc源码，发现宏DO_CALL定义处unix/sysv/linux/i386/sysdep.h 。这里做了几件事情 请求参数放在寄存器里面 系统调用名转换成系统调用号，放在寄存器 eax 里面 执行 ENTER_KERNE，产生一个软中断 然后中断处理entry_INT80_32 就被调用了 这里会将用户态的上下文保存在pt_regs结构中 然后调用do_syscall_32_irqs_on,它会将系统调用号取出，查找系统调用表，找到内核的系统调用执行，并取出寄存器中保存的参数。 当系统调用结束的时候，这时中断返回，iret 指令将原来用户态保存的现场恢复回来。进程恢复用户态继续执行。 # 64位系统平台 DO_CALL定义在源码位置unix/sysv/linux/x86_64/sysdep.h,还是将系统调用名称转换为系统调用号，放到寄存器 rax。和32位不同的是， 这里是真正进行调用，不是用中断了，而是改用 syscall 指令了。 而且传递参数的寄存器也变了 syscall指令通过一个叫做MSR的特殊模块寄存器，拿出函数地址来调用，也就是entry_SYSCALL_64。其中 保存了很多寄存器到 pt_regs 结构里面，例如用户态的代码段、数据段、保存参数的寄存器 调用链entry_SYSCALL64_slow_pat-&gt;do_syscall_64，其中拿到系统调用号，在系统调用表中找到对应的系统调用，取参数，执行(老方法) 系统调用结束，返回用户态的指令变成了 sysretq。将进程恢复为用户态 总结 结合之前对用户态、内核态模式转换的学习用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态。64位系统中一个完整的系统调用,专栏中的总结图如下 补充知识 1、 系统调用表 # kernel源码位置: 数据结构定义在arch/x86/entry/syscall_64.c,系统调用列表输出在arch/x86/entry/syscalls/syscall_64.tbl 12#系统调用号 abi类型 函数名 系统调用名2 common open sys_open # 系统调用函数声明 声明在include/linux/syscalls.h,找到有sys_open 的声明 # 系统调用函数实现 内核系统调用实现和声明一致，其中fs/open.c 12 # 编译规则 接下来，在编译的过程中，需要根据 syscall_32.tbl 和 syscall_64.tbl 生成自己的 unistd_32.h 和 unistd_64.h。在文件arch/x86/entry/syscalls/Makefile 中 12 参考资料 趣谈Linux系统专栏 - 09系统调用 如何下载查看glibc源代码 glibc源码分析（一）系统调用 linux下实现一个系统调用","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"06 kernel初始化","date":"2020-04-11T00:23:02.000Z","path":"计算机基础/开发平台/Linux系统学习/06 kernel初始化/","text":"初步了解 1、 回顾 经过了BootLoader阶段，此时cpu从实模式转换成保护模式，有了更强的寻址能力，kernel也已经加载到内存了。系统内核开始运行 在kernel源码init/main.c文件中，内核的启动从入口函数start_kernel() 。其中进行一系列的初始化XXXX_init 2、目的 结合源码，了解内核启动阶段开始都做了哪些初始化。 3、总结 一些关键的初始化函数，原文中已经有总结好的图片 还有细心的同学总结了比较详细的笔记 123456789101112131415161718192021222324252627282930- 内核初始化, 运行 `start_kernel()` 函数(位于 init/main.c), 初始化做三件事 - 创建样板进程, 及各个模块初始化 - 创建管理/创建用户态进程的进程 - 创建管理/创建内核态进程的进程---- 创建样板进程,及各个模块初始化 - 创建第一个进程, 0号进程. `set_task_stack_end_magic(&amp;init_task)` and `struct task_struct init_task = INIT_TASK(init_task)` - 初始化中断, `trap_init()`. 系统调用也是通过发送中断进行, 由 `set_system_intr_gate()` 完成. - 初始化内存管理模块, `mm_init()` - 初始化进程调度模块, `sched_init()` - 初始化基于内存的文件系统 rootfs, `vfs_caches_init()` - VFS(虚拟文件系统)将各种文件系统抽象成统一接口 - 调用 `rest_init()` 完成其他初始化工作---- 创建管理/创建用户态进程的进程, 1号进程 - `rest_init()` 通过 `kernel_thread(kernel_init,...)` 创建 1号进程(工作在用户态). - 权限管理 - x86 提供 4个 Ring 分层权限 - 操作系统利用: Ring0-内核态(访问核心资源); Ring3-用户态(普通程序) - 用户态调用系统调用: 用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态 - 新进程执行 kernel_init 函数, 先运行 ramdisk 的 /init 程序(位于内存中) - 首先加载 ELF 文件 - 设置用于保存用户态寄存器的结构体 - 返回进入用户态 - /init 加载存储设备的驱动 - kernel_init 函数启动存储设备文件系统上的 init---- 创建管理/创建内核态进程的进程, 2号进程 - `rest_init()` 通过 `kernel_thread(kthreadd,...)` 创建 2号进程(工作在内核态). - `kthreadd` 负责所有内核态线程的调度和管理 下面我会根据文章和这份笔记，结合代码捋一下流程。 在线阅读linux内核源码: https://elixir.bootlin.com/linux/latest/source 各个模块的初始化 1、 0号进程 定位到入口函数start_kernel(void)，发现有一处调用set_task_stack_end_magic(&amp;init_task);。这里kernel刚启动创建的第一个进程，pid为0，唯一一个没有通过 fork 或者 kernel_thread 产生的进程。 1set_task_stack_end_magic(&amp;init_task); 2、 各个模块初始化 同样在start_kernel(void)可以定位到其他的初始化调用，其中有关键的几个 123456789trap_init(); //系统调用相关 设置中断门mm_init(); //内存管理sched_init(); //调度模块vfs_caches_init(); //rootfs文件系统rest_init(); //其他方面的init 用户态祖先进程的创建 在rest_init()函数中有一处kernel_thread(kernel_init, NULL, CLONE_FS),创建了pid为1的进程，这是第一个用户进程，是所有其他用户进程的鼻祖进程。 内核态到用户态 这是一个用户进程，需要在用户态运行。一般用户程序是从用户态--到内核态--返回用户态的过程。当前执行 kernel_thread 这个函数的时候，就在内核态。如何直接从内核态到用户态呢？ 在kernel_init()函数中有一处kernel_init_freeable()调用，查看定义处有 12if (!ramdisk_execute_command) ramdisk_execute_command = \"/init\"; 回到kernel_init()函数，有对应的执行代码 12345678910 if (ramdisk_execute_command) &#123; ret = run_init_process(ramdisk_execute_command);...... &#125;...... if (!try_to_run_init_process(\"/sbin/init\") || !try_to_run_init_process(\"/etc/init\") || !try_to_run_init_process(\"/bin/init\") || !try_to_run_init_process(\"/bin/sh\")) return 0; 如果我们打开 run_init_process 函数，会发现它调用的是 do_execve。 do_execve是一个内核系统调用，它的作用是运行一个执行文件。其中调用链为do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler 12345678int search_binary_handler(struct linux_binprm *bprm)&#123; ...... struct linux_binfmt *fmt; ...... retval = fmt-&gt;load_binary(bprm); ......&#125; 在这里，它会尝试运行ramdisk 的/init，或者普通文件系统上的/sbin/init、/etc/init、/bin/init、/bin/sh。加载ELF文件，只要有一个启动起来就可以了。 比较关心程序如何’恢复’到用户态的，其实最后内核空间中保存了用户态运行的上下文，最后只要切换上下文，恢复那些寄存器（CS、DS、IP、SP），然后下一条指令，就从用户态开始运行了。 内核态祖先进程的创建 继续在rest_init()中查看有一处调用kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)，这里创建了第三个进程，pid为2，是内核态所有task的祖先，作用是将内核态所有的task进行统一的调度和管理。 补充知识 1、 用户态、内核态 # 基本概念 进入保护模式后，为避免多进程对资源访问的混乱。使用x86提供的权限访问机制，有Ring0…Ring3 4种权限。 用户进程一般放在Ring3，我们称为用户态 核心驱动代码一般放在Ring0，称为内核态 # 系统调用 用户程序要访问核心资源，需要通过系统提供的系统调用接口，从用户态进入内核态。这个过程就是这样的：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行。 2、 ramdisk的作用 kernel启动过程中，一开始到用户态的是ramdisk的init，后来会启动真正根文件系统上的init，成为所有用户态进程的祖先。 为什么没有直接从根文件系统上加载init，这是因为文件系统一定存在一个存储设备上。要对设备访问需要驱动程序，而对内存可以直接访问。所以想在内存上建立一个假文件系统，先运行要访问存储设备的驱动程序，有了驱动就能设置根文件系统，就能启动根文件系统上的init程序了。 参考资料 极客时间- 内核初始化","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"05 BIOS到BootLoader","date":"2020-04-11T00:22:02.000Z","path":"计算机基础/开发平台/Linux系统学习/05 BIOS到BootLoader/","text":"初步了解 1、 回顾 之前理解了x86架构下的工作模式，计算机系统的核心是CPU、内存、总线来干活的。但是x86提供的是开放的硬件平台，需要配合对应的操作系统，才能发挥最大的作用。 另外随着计算机技术的衍变，32位系统之后的x86架构已经有实模式和保护模式两种模式。系统启动之前的BIOS阶段在实模式，之后工作在保护模式。 实模式，兼容原来16位系统设计出的模式。只能寻址1M，每个段最多64K 保护模式，对于32位系统，能够寻址4G。 2、 目的 学习目的: 操作系统不是在板子上电就直接运行的，中间一定有一个过程。学习了解linux系统启动之前cpu做了哪些准备，内核如何被加载到内存上运行。 3、 总结 板子上电，先读取ROM中的固件代码，做出一个基本输入输出系统。这一阶段为BIOS时期。 BIOS从启动盘（一般是硬盘第一个扇区）开始加载引导代码，进一步初始化硬件，实模式升级为保护模式。这一阶段为BootLoader时期。 BootLoader将一系列工作做完了，最重要的一步就是加载系统内核kernel到内存运行了。控制权移交给内核之后，BootLoader时期结束，然后开始内核的部分了。 BIOS阶段 BIOS是固化在ROM上的一段程序，如果你自己安装过操作系统，刚启动的时候，按某个组合键，显示器会弹出一个蓝色的界面。能够调整启动顺序的系统，就是我说的 BIOS，然后我们就可以先执行它。 1、 内存地址空间 cpu工作模式是实模式，这时只有1M的内存地址空间 x86系统中，cpu将内存地址0xF0000 到 0xFFFFF 这 64K 映射给 ROM。 主板上电，cpu将CS寄存器置为0xffff，ip寄存器置0x0000，所以第一条指令指向的地址是0xfff0(实模式下，cs&lt;&lt;4 + ip)。这里有一个jmp指令，跳转到rom中做初始化的代码。 2、 程序流程 主板上电，CPU先从ROM中加载BIOS程序，BIOS进行硬件相关的初始化工作。主要有2件事情 检查硬件环境 是建立中断程序和中断向量表，同时把结果显示在显示器上 BootLoader阶段 光有BIOS还不够，还要从硬盘上搞到操作系统。引导操作系统这一阶段就是BootLoader。 1、 引导管理器grub2 Linux一般通过grub来做系统引导程序。 系统上提供了grub2工具，grub2用户配置文件/etc/default/grub，系统会根据用户配置自动生成/boot/grub/grub.cfg。常用命令 12345# 重新生成配置文件grub-mkconfig -o /boot/grub/grub.cfg # 将Grub 2安装到硬盘引导扇区grub-install --root-directory=/ /dev/sda 2、 相关文件 使用 grub2-install /dev/sda，可以将启动程序安装到相应的位置。其中有boot.img、core.img (1)boot.img 在BIOS平台下，boot.img是grub启动的第一个img文件，它被写入到MBR中或分区的boot sector中，因为boot sector的大小是512字节，所以该img文件的大小也是512字节。 boot.img唯一的作用是读取属于core.img的第一个扇区并跳转到它身上，将控制权交给该扇区的img。由于体积大小的限制，boot.img无法理解文件系统的结构，因此grub2-install将会把core.img的位置硬编码到boot.img中，这样就一定能找到core.img的位置。 此处参考 (2)core.img core.img根据diskboot.img、kernel.img和一系列的模块被grub2-mkimage程序动态创建。core.img中嵌入了足够多的功能模块以保证grub能访问/boot/grub，并且可以加载相关的模块实现相关的功能，例如加载启动菜单、加载目标操作系统的信息等，由于grub2大量使用了动态功能模块，使得core.img体积变得足够小。 core.img中包含了多个img文件的内容，包括diskboot.img/kernel.img等。 此处参考 3、 引导流程 BIOS完成之后，先加载boot.img到内容中运行，boot.img 将控制权交给 diskboot.img 后，diskboot.img 的任务就是将 core.img 的其他部分加载进来，先是解压缩程序 lzma_decompress.img，再往下是 kernel.img，最后是各个模块 module 对应的映像。这里需要注意，它不是 Linux 的内核，而是 grub 的内核。 再kernel.img中选择加载真正的linux kernel(对应之前的grub用户配置文件)。 补充知识 1、 从实模式切换到保护模式 在bootloader过程中，lzma_decompress.img 做了一个重要的决定，就是调用 real_to_prot，cpu从实模式切换到保护模式.切换到保护模式要干很多工作，大部分工作都与内存的访问方式有关。 第一项是启用分段，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。 第二项是启动分页。能够管理的内存变大了 打开第21根地址线 Gate A20，cpu从20位总线到32位总线访问内存 2、 硬件基础(主引导扇区、分区引导扇区、分区表) 一个硬盘实际上由一个个扇区组成，它起始的一部分扇区为主引导扇区，包括MBR（主引导纪录）和DPT（分区表） 硬盘可以有多个分区，每个分区起始的一部分扇区，为分区引导扇区。分区引导扇区之后的部分，为文件系统的索引，不同的文件系统采用不同的索引，文件系统通过它定位文件在硬盘上的位置。 对硬盘的读写操作，通过文件系统来完成；引导扇区中的内容，我们不能够在文件系统中进行操作，而需要专用软件，比如引导管理器。 参考资料 主引导记录 - 百科 Grub2配置 grub2详解(翻译和整理官方手册) An introduction to the Linux boot and startup processes An introduction to GRUB2 configuration for your Linux machine","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"07 编译android kernel","date":"2020-04-05T00:35:10.000Z","path":"计算机基础/开发平台/Android系统开发/07 编译android goldfish内核(x86_64)/","text":"Android linux内核 Android并没有使用标准的Linux内核，而是做了很多的修改。AOSP网站提供了适应各种芯片或设备的linux内核源码的仓，只有少部分google设备支持的内核源码可以通过repo构建,其他的需要做一些编译配置。 手动编译内核 这里选择emulator模拟器跑Android内核，所以选择goldfish版本作为我的的Linux Kernel，下面通过编译goldfish内核来介绍这个过程。 按照官方的教程没有找到xxx_defconfig编译配置文件，之后在网上找到一篇相似的博客，以下步骤基本上是按照那个教程来的。 1、下载源码 1hinzer@ubuntu:kernel$ git clone https://android.googlesource.com/kernel/goldfish 2、查看当前Android系统对应的内核版本 1hinzer@ubuntu:android-10$ emulator # 虚拟机运行起来，点Setting -&gt; Android version 查看内核版本信息 3、检出对应分支 123456hinzer@ubuntu:kernel$ cd goldfish/git branch -a#....#....git checkout -b dev remotes/origin/android-goldfish-4.14-dev.20190417 # 对应的内核版本为4.14#.... 4、进行编译配置 1234export PATH=$PATH:/home/hinzer/source/android-10/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9/binexport ARCH=x86_64export CROSS_COMPILE=x86_64-linux-android-export REAL_CROSS_COMPILE=x86_64-linux-android- 5、编译 1/home/hinzer/source/android-10/prebuilts/qemu-kernel/build-kernel.sh --arch=x86_64 # 需要在kernel的源码的根目录下执行 但是出现error，没有发现&quot;x86_64_emu_defconfig&quot;这个文件。于是我将x86_64_defconfig改为x86_64_emu_defconfig 123456cp -a /home/hinzer/source/android-10/kernel/goldfish/arch/x86/configs/x86_64_defconfig /home/hinzer/source/android-10/kernel/goldfish/arch/x86/configs/x86_64_emu_defconfig/home/hinzer/source/android-10/prebuilts/qemu-kernel/build-kernel.sh --arch=x86_64 # 继续编译......Kernel: arch/x86/boot/bzImage is ready (#1)Kernel x86_64_emu prebuilt images (kernel-qemu and vmlinux-qemu) copied to /tmp/kernel-qemu/x86_64-4.14.88 successfully ! 6、加载内核并运行系统 emulator启动相关的参数，可参考官方手册 - 命令行启动选项 12# 编译生成的内核放在/tmp/kernel-qemu/x86_64-3.10.0/kernel-qemuhinzer@ubuntu:android-10$ emulator -kernel /tmp/kernel-qemu/x86_64-4.14.88/kernel-qemu # 配置参数 7、再次查看当前Android系统对应的内核版本 补充 将编译出的kernel-qemu加载到emulator上发现界面直接卡死，adb devices命令也连接不上。初步怀疑是编译的linux内核版本不对，导致无法正常启动。(这个问题暂时还没有解决，目前单独编译不影响) 另外，进一步研究了kernel源码下的README文件，发现make ${PLATFORM}_defconfig说明。想到之前按照官方的步骤可能出了一点差错，修改为 12345cd goldfishexport ARCH=x86 # cpu架构export CROSS_COMPILE=x86_64-linux-android-make x86_64_defconfig # 将arch/$ARCH/configs/xxx_defconfig写入.config文件，编译阶段build系统会检索make success!!此时编译出的映像文件输出arch/x86/boot/bzImage, 参考资料 手动编译内核 编译x86_64 android 7.1及goldfish内核 Android内核开发：源码的版本与分支详解 Android 通用内核","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"04 x86架构","date":"2020-04-05T00:32:02.000Z","path":"计算机基础/开发平台/Linux系统学习/04 x86架构/","text":"先了解计算机底层最基本的工作原理，以便于以后能理解Linux系统的运作模式!! 总体概要 原文中对于x86架构的总结图片，重点牢记这些寄存器的作用，以及段的工作模式 计算机的工作模式(了解一下) 1、 CPU、总线、内存 对于一个计算机来讲，所有功能看似是输入输出设备的功劳，实际干活的还是CPU。同时CPU通过内存不断的保存和取出中间数据，然后基于中间结果进行进一步的计算。总线是CPU和其他设备的高速通道。 CPU是这台计算机的大脑，所有的设备都围绕它展开。 总线其实就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。 最重要的是内存。因为单靠 CPU 是没办法完成计算任务的，很多复杂的计算任务都需要将中间结果保存下来，然后基于中间结果进行进一步的计算。 2、相互配合工作 首先要了解几个概念的关系，其中 CPU包括三个部分，运算单元、数据单元和控制单元 进程在内存上有独立的内存空间，相互隔离(但不连续)，每个进程简单的区分代码段和数据段 总线上主要有两类，地址总线操作地址数据，数据总线操作真正的数据 那 CPU 怎么执行这些程序，操作这些数据，产生一些结果，并写入回内存呢? CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。 数据单元根据数据的地址，从数据段里读到数据寄存器里，就可以参与运算了。指令 = 操作码(运算单元) + 操作数(数据单元) 运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。 最终，会有指令将数据写回内存中的数据段。 x86平台特性(了解一下) x86架构起源于IBM,开端于8086。由于开放、统一、兼容的特性逐渐成为标准，后来Intel的cpu也都基于这个架构 8086的原理(了解一下) 1、 数据单元 8086处理器内部有 8 个 16 位的通用寄存器，有些寄存器还能掰开2个8位寄存器来使用。 2、 控制单元 IP寄存器指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。 每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS代码段寄存器、DS数据段寄存器、SS栈寄存器、ES。 3、 访问地址模式 这个时候内存是分段管理，CPU要访问内存地址通过段启始地址 + 偏移量的方式访问。其中， 代码段的起始地址在CS寄存器，偏移量在 IP 寄存器中 数据段的起始地址在DS寄存器，偏移量在通用寄存器中 由于是20位地址总线，而寄存器都是16位的。所以8086采用了基地址 &lt;&lt; 4 + 偏移量的方式，其中 地址访问范围: 2^20 = 1M , 表示一个进程的最大访问空间 偏移量大小: 2^16=64k ， 表示一个段的最大空间 32位处理器(重点理解) 随着计算机的发展，32位总线已经足够应对4G内存。为了x86体系开放、统一、兼容的特性，要兼容原来的模式 对于通用寄存器和IP寄存器有原来的16位扩展到32位，兼容原来的模式。 而改动比较大，有点不兼容的就是段寄存器(因为之前的20位总线设计太独特了)。其中有 段的起始地址从原来放在寄存器中，改为放在内存的某个地方，当然为了快速拿到段起始地址，段寄存器会从内存中拿到 CPU 的描述符高速缓存器中。 cpu访问内存分位实模式和保护模式。其中实模式是对原来兼容的模式。 参考资料 极客时间 - x86架构 x86 Assembly Guide Linux学习笔记《六》","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"06 添加java层系统服务","date":"2020-04-05T00:28:10.000Z","path":"计算机基础/开发平台/Android系统开发/06 添加java层系统服务/","text":"引入概念 目前对android系统体系了解比较少，主要区分一下服务、系统服务这两个概念 Android服务是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。在android开发中作为一个应用组件,通过继承类extern Service来使用。 Android系统服务。理解为随着andorid系统启动运行的service，分为本地守护进程、Native系统服务和Java系统服务。 有相同点更有不同点，但请不要把两个概念弄混淆了!!! 然后下面记录一下添加自定义一个java系统服务的步骤，参考于qiushao大神的blog。基于android-10版本的AOSP源码， 添加服务 1、 定义服务接口 首先我们得定义我们的服务名是什么，提供什么样的接口。在frameworks/base/core/java/android目录下添加pure文件夹 12345$ tree frameworks/base/core/java/android/pureframeworks/base/core/java/android/pure└── IHelloService.aidl # 使用 aidl 定义服务接口0 directories, 1 file 定义接口文件IHelloService.aidl，模块名IHelloService,接口hello将实现播放指定路径的音频文件 1234package android.pure;interface IHelloService &#123; void hello(String name);&#125; frameworks/base/Android.bp文件中找到模块名framework-defaults，添加 1&quot;core/java/android/pure/IHelloService.aidl&quot;, 此时，进入 framework/base 目录执行 mm -j 命令编译 framework.jar 模块。 编译成功后，会在 out/soong/.intermediates/frameworks/base/framework/android_common/gen/aidl/frameworks/base/core/java/android/pure 目录生成 IHelloService.java 这个文件 2、 实现接口 然后在frameworks/base/services/core/java/com/android/server下创建HelloService.java文件(接口实现) 内容如下 1234567891011121314151617package com.android.server;import android.pure.IHelloService;import android.util.Log;public class HelloService extends IHelloService.Stub &#123; private final String TAG = \"HelloService\"; public HelloService() &#123; Log.d(TAG, \"create hello service\"); &#125; @Override public void hello(String name) &#123; Log.d(TAG, \"hello \" + name); &#125;&#125; 3、 将服务添加到 ServiceManager 修改 frameworks/base/services/java/com/android/server/SystemServer.java 文件，在startOtherServices方法里面增加以下代码 1234// add hello servicetraceBeginAndSlog(&quot;HelloService&quot;);ServiceManager.addService(&quot;HelloService&quot;, new HelloService());traceEnd(); 4、 编译验证 &amp; 系统无法启动 现在已经实现的HelloService接口模块，并添加到ServiceManager。开始尝试整编下android源码 1234$ source ./build/envsetup.sh # 导出环境变量(之前执行过了)$ lunch product01-eng # 选择Product$ make api-stubs-docs-update-current-api -j4 # 更新api接口$ make -j4 # 编译 然后启动emulator虚拟机，发现一直停留在logo界面，说明系统没起来。。这时候可以adb调试，我们查看一下log记录 123456$ emulator # 发现android系统界面没起来......$ adb shell logcat -b all &gt; logSystem.txt # 抓取android层的 log...^C 日志中检索我们想要的关键字HelloService,发现 12345678910111213141516171804-02 01:24:25.871 2224 2224 I SystemServer: HelloService04-02 01:24:25.871 1528 1528 I auditd : avc: denied &#123; add &#125; for service=HelloService pid=2224 uid=1000 scontext=u:r:system_server:s0 tcontext=u:object_r:default_android_service:s0 tclass=service_manager permissive=004-02 01:24:25.871 2224 2224 E System : ******************************************04-02 01:24:25.871 2224 2224 E System : ************ Failure starting system services04-02 01:24:25.871 2224 2224 E System : java.lang.SecurityException04-02 01:24:25.871 2224 2224 E System : at android.os.BinderProxy.transactNative(Native Method)04-02 01:24:25.871 2224 2224 E System : at android.os.BinderProxy.transact(BinderProxy.java:510)04-02 01:24:25.871 2224 2224 E System : at android.os.ServiceManagerProxy.addService(ServiceManagerNative.java:156)04-02 01:24:25.871 2224 2224 E System : at android.os.ServiceManager.addService(ServiceManager.java:192)04-02 01:24:25.871 2224 2224 E System : at android.os.ServiceManager.addService(ServiceManager.java:161)04-02 01:24:25.871 2224 2224 E System : at com.android.server.SystemServer.startOtherServices(SystemServer.java:920)04-02 01:24:25.871 2224 2224 E System : at com.android.server.SystemServer.run(SystemServer.java:512)04-02 01:24:25.871 2224 2224 E System : at com.android.server.SystemServer.main(SystemServer.java:349)04-02 01:24:25.871 2224 2224 E System : at java.lang.reflect.Method.invoke(Native Method)04-02 01:24:25.871 2224 2224 E System : at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)04-02 01:24:25.871 2224 2224 E System : at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:908)04-02 01:24:25.871 2224 2224 D SystemServerTiming: HelloService took to complete: 1ms04-02 01:24:25.871 2224 2224 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main 然后定位到这一句04-02 01:24:25.871 1528 1528 I auditd : avc: denied { add } for service=HelloService pid=2224 uid=1000 scontext=u:r:system_server:s0 tcontext=u:object_r:default_android_service:s0 tclass=service_manager permissive=0,不理解没关系，google一下。发现是selinux方面的原因。 为了进一步验证猜想，将系统中的selinux关掉试试。通过setenforce 0命令，重启系统发现正常了，印证了之前的猜想，确实selinux配置的原因。 123$ adb shell setenforce 0 # 禁用selinux$ emulator -wipe-data # 擦掉data区，重启系统 5、 设置selinux规则 然后我们只需要添加这个自定义服务HelloService相关的 SELinux 规则。为了方便之后验证，打开selinux 1$ adb shell setenforce 1 # 打开selinux Android 10 的 selinux 规则是放在 system/sepolicy 目录下的。不怎么了解SELinux规则，可以参考现有的系统服务的规则去添加，这里参考的是 network_time_update_service 服务。 12$ cd system/sepolicy # selinux规则在这个目录$ grep -nr network_time_update_service # 查找network_time_update_service服务相关的selinux配置 涉及到的文件很多，有部分文件是不需要修改的，我们先把找到的所有 service.te 和 service_contexts 都参考 network_time_update_service 加上 HelloService 的配置。 12345678910111213141516$ find -name service.te./prebuilts/api/27.0/public/service.te # 需要./prebuilts/api/28.0/public/service.te # 需要./prebuilts/api/28.0/private/service.te./prebuilts/api/29.0/public/service.te # 需要./prebuilts/api/29.0/private/service.te./prebuilts/api/26.0/public/service.te # 需要./public/service.te # 需要./private/service.te$ find -name service_contexts./reqd_mask/service_contexts./prebuilts/api/27.0/private/service_contexts # 需要./prebuilts/api/28.0/private/service_contexts # 需要./prebuilts/api/29.0/private/service_contexts # 需要./prebuilts/api/26.0/private/service_contexts # 需要./private/service_contexts # 需要 其中 service_contexts上添加HelloService u:object_r:HelloService:s0; service.te上添加type HelloService, system_server_service, service_manager_type;。 6、 编译验证 最后再次编译一遍，启动届满没有什么问题了。adb进入系统查看一下有没有这个服务 1234567891011$ source ./build/envsetup.sh # 导出环境变量(之前执行过了)$ lunch product01-eng # 选择Product$ make api-stubs-docs-update-current-api -j4 # 更新api接口$ make -j4 # 编译........$ adb shellpure:/ # service list | grep HelloService 16 HelloService: [android.pure.IHelloService]pure:/ # 错误记录 1、 添加服务后,make -j4编译系统报错 1234567891011121314151617181920error: Added package android.pure [AddedPackage]Aborting: Found compatibility problems checking the public API against the API in /home/mi/source/android-10/frameworks/base/api/current.txt-e ******************************You have tried to change the API from what has been previously approved.To make these errors go away, you have two choices: 1. You can add &apos;@hide&apos; javadoc comments to the methods, etc. listed in the errors above. 2. You can update current.txt by executing the following command: make api-stubs-docs-update-current-api To submit the revised current.txt to the main Android repository, you will need approval.******************************09:05:24 ninja failed with: exit status 1#### failed to build some targets (06:37 (mm:ss)) #### 解决思路: 没有更新服务接口，编译前执行make api-stubs-docs-update-current-api -j4 2、添加selinux后,编译报错 1234567891011121314151617181920SELinux: The following public types were found added to the policy without an entry into the compatibility mapping file(s) found in private/compat/V.v/V.v[.ignore].cil, where V.v is the latest API level.HelloServiceSee examples of how to fix this:https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/781036https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/852612[ 20% 5/24] build out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0FAILED: out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0/bin/bash -c &quot;(out/host/linux-x86/bin/treble_sepolicy_tests -l out/host/linux-x86/lib64/libsepolwrap.so -f out/target/product/pure/obj/ETC/plat_file_contexts_intermediates/plat_file_contexts -f out/target/product/pure/obj/ETC/vendor_file_contexts_intermediates/vendor_file_contexts -b out/target/product/pure/obj/ETC/built_plat_sepolicy_intermediates/built_plat_sepolicy -m out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/28.0_mapping.combined.cil -o out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/built_28.0_plat_sepolicy -p out/target/product/pure/obj/ETC/sepolicy_intermediates/sepolicy -u out/target/product/pure/obj/ETC/built_plat_sepolicy_intermediates/base_plat_pub_policy.cil --fake-treble ) &amp;&amp; (touch out/target/product/pure/obj/ETC/treble_sepolicy_tests_28.0_intermediates/treble_sepolicy_tests_28.0 )&quot;SELinux: The following public types were found added to the policy without an entry into the compatibility mapping file(s) found in private/compat/V.v/V.v[.ignore].cil, where V.v is the latest API level.HelloServiceSee examples of how to fix this:https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/781036https://android-review.git.corp.google.com/c/platform/system/sepolicy/+/85261221:45:48 ninja failed with: exit status 1#### failed to build some targets (16 seconds) #### 解决思路: selinux没配置好，没有将配置覆盖所有需要的te文件。检查本地配置，按照上面的方法，在配置一下。 3、启动emulator之后，系统没起来，同时log报错 12345678hinzer@ubuntu:android-10$ emulator -wipe-dataemulator: WARNING: Couldn&apos;t find crash service executable /home/hinzer/source/android-10/prebuilts/android-emulator/linux-x86_64/emulator64-crash-serviceemulator: WARNING: system partition size adjusted to match image file (3083 MB &gt; 800 MB)qemu_ram_alloc_user_backed: callcontext mismatch in svga_surface_destroy # 这个错误.... 解决方法: 通过网络查询到解决方法,由于我这边是VM上运行Ubuntu虚拟机，然后在跑emulator。我需要把VM设置中的显示器中的图形渲染关闭，这一操作需要关闭虚拟机，重启后在运行emulator 验证就没有问题了。 小结 查看日志 使用logcat -b all，不清楚不要过滤处理，查看全部log 不确定的情况下，可以系统上直接启动/禁止selinux验证猜想，然后进一步调试 参考资料 Android系统开发入门-7.添加java层系统服务 官方文档 - 服务概览 官方文档- SELinux Android 系统服务","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"04 添加预定义模块","date":"2020-04-05T00:05:10.000Z","path":"计算机基础/开发平台/Android系统开发/04 添加预编译模块/","text":"理解 在实际的系统开发过程中，有很多文件都是预先编译好的，比如第三方APK，so库, jar包， bin 文件，配置文件等。我们需要在系统编译时能把这些文件打包编译到系统镜像里面。 操作准则 我们有两种方法可以达到我们的目的： PRODUCT_COPY_FILES 和 定义 prebuilt 模块。 如果这个文件只需要预置到指定目录就可以了，那我们就可以简单的将其加入 PRODUCT_COPY_FILES 变量就行， 比如一些 bin 文件， 配置文件。 如果这个文件有其他模块编译依赖，或者这个文件需要系统签名，那我们就得定义一个预编译模块，比如一些 so 库，APK 文件， jar 包等。 添加预编译模块 这里先记录一下添加预编译模块到PRODUCT_COPY_FILES的过程，另外如何定义prebuilt，方法请查看原文 Android系统开发入门-5.添加预编译模块 1、 定义目录结构 为了维护方便，我们一般把 PRODUCT_COPY_FILES 的设置提取到一个单独的文件。在 $product.mk 里面 include 就行。这里在pure目录下创建一个prebuilt目录如下 123456789hinzer@ubuntu:android-10$ tree ./device/mi/pure/prebuilt/./device/mi/pure/prebuilt/├── apk # 预置 apk 模块├── libs # 预置库模块，so 库， jar 包等└── vendor # PRODUCT_COPY_FILES 类型预置，按实际输出路径组织 └── bin └── busybox-i6864 directories, 1 file 2、下载bin文件 12345hinzer@ubuntu:android-10$ cd ./device/mi/pure/prebuilt/vendor/binhinzer@ubuntu:bin$ wget https://busybox.net/downloads/binaries/1.21.1/busybox-i686....hinzer@ubuntu:bin$ file busybox-i686busybox-i686: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, stripped 3、添加product_copy_files.mk 12345678hinzer@ubuntu:pure$ vim product_copy_files.mkhinzer@ubuntu:pure$ cat product_copy_files.mk# product copy filesLOCAL_PREBUILD_DIR := device/mi/pure/prebuiltPRODUCT_COPY_FILES += \\ $(LOCAL_PREBUILD_DIR)/vendor/bin/busybox-i686:vendor/bin/busybox 4、在 $product.mk 文件中 include 1hinzer@ubuntu:pure$ echo \"include device/mi/pure/product_copy_files.mk\" &gt;&gt; product01.mk 编译验证 1234567891011121314151617181920# 编译hinzer@ubuntu:android-10$ source ./build/envsetup.shhinzer@ubuntu:android-10$ lunch product01-enghinzer@ubuntu:android-10$ make -j4# 启动emulator虚拟机hinzer@ubuntu:android-10$ emulator...# adb shell验证hinzer@ubuntu:~$ adb devicesList of devices attachedemulator-5554 devicehinzer@ubuntu:~$ adb shell busybox # 运行可执行文件BusyBox v1.21.1 (2013-07-08 10:44:30 CDT) multi-call binary.BusyBox is copyrighted by many authors between 1998-2012.Licensed under GPLv2. See source distribution for detailedcopyright notices...... 参考资料 使用预编译库 Android系统开发入门-5.添加预编译模块 Android.mk编译目标(编译包、二进制文件、预编译）","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"05 删除android内置apk","date":"2020-04-05T00:05:10.000Z","path":"计算机基础/开发平台/Android系统开发/05 删除Android原生内置APK/","text":"两种方法 为了在编译阶段将内置apk给异常，下面提供2中方法。 直接找到添加这个apk的mk文件，从 PRODUCT_PACKAGES 中删除 通过添加模块，LOCAL_OVERRIDES_PACKAGES定义要覆盖的apk 目录结构 123456hinzer@ubuntu:android-10$ tree ./device/mi/pure/./device/mi/pure/├── Android.mk├── AndroidProducts.mk├── BoardConfig.mk├── product01.mk 操作过程 1、 直接从 PRODUCT_PACKAGES 中删除 1234567891011# step1 找到apk添加到 PRODUCT_PACKAGES 的那个mk文件$ mgrep Contacts# step2 从改mk文件中移除配置项.....# step3 清理system目录，重新编译$ rm -rf out/target/product/pure/system# step4 验证make -j4 &amp;&amp; emulator 2、 通过 LOCAL_OVERRIDES_PACKAGES 删除 在Product下添加一个模块remove_unused_module 123456789101112131415161718192021$ vim Android.mkinclude $(CLEAR_VARS)LOCAL_MODULE := remove_unused_moduleLOCAL_MODULE_TAGS := optionalLOCAL_MODULE_CLASS := FAKE # 指定编译输出的目录为 $(PRODUCT_OUT)/fake_packagesLOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_OVERRIDES_PACKAGES += \\ Contacts \\ Email #这里添加要覆盖的apkinclude $(BUILD_SYSTEM)/base_rules.mk$(LOCAL_BUILT_MODULE): $(hide) echo \"Fake: $@\" $(hide) mkdir -p $(dir $@) $(hide) touch $@PACKAGES.$(LOCAL_MODULE).OVERRIDES := $(strip $(LOCAL_OVERRIDES_PACKAGES)) 将remove_unused_module添加到对应product文件的PRODUCT_PACKAGES配置 1PRODUCT_PACKAGES += remove_unused_module 清理out/target/product/pure/system目录，验证 12$ rm -rf out/target/product/pure/system$ make -j4 &amp;&amp; emulator 原理补充(PRODUCT_PACKAGES) 对于第一种方法，通过mgrep命令能够搜索到这个mk文件定义了PRODUCT_PACKAGES，直接移除就ok。对于第二种方法，在 main.mk 里面有对 OVERRIDES_PACKAGES 进行处理（在android-10源码中对这个关键词进行检索） 12345678910111213141516171819202122232425262728293031323334353637383940414243# Lists most of the files a particular product installs, including:# - PRODUCT_PACKAGES, and their LOCAL_REQUIRED_MODULES# - PRODUCT_COPY_FILES# The base list of modules to build for this product is specified# by the appropriate product definition file, which was included# by product_config.mk.# Name resolution for PRODUCT_PACKAGES:# foo:32 resolves to foo_32;# foo:64 resolves to foo;# foo resolves to both foo and foo_32 (if foo_32 is defined).## Name resolution for LOCAL_REQUIRED_MODULES:# If a module is built for 2nd arch, its required module resolves to# 32-bit variant, if it exits. See the select-bitness-of-required-modules definition.# $(1): product makefiledefine product-installed-files $(eval _mk := $(strip $(1))) \\ $(eval _pif_modules := \\ $(PRODUCTS.$(_mk).PRODUCT_PACKAGES) \\ $(if $(filter eng,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_ENG)) \\ $(if $(filter debug,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_DEBUG)) \\ $(if $(filter tests,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_TESTS)) \\ $(if $(filter asan,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_DEBUG_ASAN)) \\ $(call auto-included-modules) \\ ) \\ $(eval ### Filter out the overridden packages and executables before doing expansion) \\ $(eval _pif_overrides := $(call module-overrides,$(_pif_modules))) \\ $(eval _pif_modules := $(filter-out $(_pif_overrides), $(_pif_modules))) \\ $(eval ### Resolve the :32 :64 module name) \\ $(eval _pif_modules_32 := $(patsubst %:32,%,$(filter %:32, $(_pif_modules)))) \\ $(eval _pif_modules_64 := $(patsubst %:64,%,$(filter %:64, $(_pif_modules)))) \\ $(eval _pif_modules_rest := $(filter-out %:32 %:64,$(_pif_modules))) \\ $(eval ### Note for 32-bit product, 32 and 64 will be added as their original module names.) \\ $(eval _pif_modules := $(call get-32-bit-modules-if-we-can, $(_pif_modules_32))) \\ $(eval _pif_modules += $(_pif_modules_64)) \\ $(eval ### For the rest we add both) \\ $(eval _pif_modules += $(call get-32-bit-modules, $(_pif_modules_rest))) \\ $(eval _pif_modules += $(_pif_modules_rest)) \\ $(call expand-required-modules,_pif_modules,$(_pif_modules),$(_pif_overrides)) \\ $(filter-out $(HOST_OUT_ROOT)/%,$(call module-installed-files, $(_pif_modules))) \\ $(call resolve-product-relative-paths,\\ $(foreach cf,$(PRODUCTS.$(_mk).PRODUCT_COPY_FILES),$(call word-colon,2,$(cf))))endef 有定义 $(eval _pif_modules := $(filter-out $(_pif_overrides), $(_pif_modules))) filter-out是Makefile语法支持的函数，从$(_pif_modules)中 反选过滤出$(_pif_overrides)之外的所有modules。 涉及到android build系统，我现在也还没搞清楚逻辑链，有待补充。 参考资料 Android系统开发入门-6.删除Android原生内置APK","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"03 添加自定义模块","date":"2020-04-05T00:04:10.000Z","path":"计算机基础/开发平台/Android系统开发/03 添加自定义模块/","text":"背景介绍 早期的Android系统都是采用Android.mk的配置来编译源码，从Android 7.0开始引入Android.bp。很明显Android.bp的出现就是为了替换掉Android.mk。 Android 7.0引入ninja和kati Android 8.0使用Android.bp来替换Android.mk，引入Soong Android 9.0强制使用Android.bp 添加模块 然后开始介绍如何通过Android.bp来引入一个hello world模块。 1、目录结构 12345./device/mi/pure/hello/├── Android.bp└── hello.cpp0 directories, 2 files 2.hello.cpp文件 123456789101112#include &lt;cstdio&gt;#include &lt;android/log.h&gt;#define LOG_TAG \"qiushao\"#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG ,__VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG ,__VA_ARGS__)int main() &#123; printf(\"hello qiushao\\n\"); LOGD(\"hello qiushao\"); return 0;&#125; 3、Android.bp文件 12345678cc_binary &#123; //模块类型为可执行文件 name: \"hello\", //模块名hello srcs: [\"hello.cpp\"], //源文件列表 vendor: true, //编译出来放在/vendor目录下(默认是放在/system目录下) shared_libs: [ //编译依赖的动态库 \"liblog\", ],&#125; 4、编译hello模块 1hinzer@ubuntu:hello$ mma 5、添加product配置 123hinzer@ubuntu:pure$ pwd/home/hinzer/source/android-10/device/mi/purehinzer@ubuntu:pure$ echo \"PRODUCT_PACKAGES += hello\" &gt;&gt; product01.mk 6、整编android系统 123hinzer@ubuntu:android-10$ source ./build/envsetup.shhinzer@ubuntu:android-10$ lunch product01-enghinzer@ubuntu:android-10$ make -j4 这是其中一个常见的模块实例，需要定义其他类型的模块时，可以参考以下文档soong。或者参考系统已有的 Android.bp 模块。 验证 12345678hinzer@ubuntu:android-10$ emulator...hinzer@ubuntu:~$ adb devicesList of devices attachedemulator-5554 devicehinzer@ubuntu:~$ adb shell hello # 运行可执行文件hello hello qiushao 理论补充 1、模块编译输出分区 system :主要包含 Android 框架， google 官方实现 Android.mk 默认就是输出到 system 分区，不用指定 Android.bp 默认就是输出到 system 分区，不用指定 vendor :SoC芯片商分区(系统级核心厂商，如高通), 为他们提供一些核心功能和服务，由 soc 实现 Android.mk LOCAL_VENDOR_MODULE := true Android.bp vendor: true odm :设备制造商分区（如华为、小米），为他们的传感器或外围设备提供一些核心功能和服务 Android.mk LOCAL_ODM_MODULE := true Android.bp device_specific: true product :产品机型分区 Android.mk LOCAL_PRODUCT_MODULE := true Android.bp product_specific 参考资料 Soong 编译系统 Android系统开发入门-4.添加自定义模块 理解Android.bp","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"01 添加Product","date":"2020-04-05T00:03:10.000Z","path":"计算机基础/开发平台/Android系统开发/01 添加Product/","text":"理解概念 1、Product 在android源码正式编译之前选择Product，使用lunch product-xxx，这一步操作理解为预先对要编译的源码进行一系列的配置。在android-10的源码中，将一个Product配置分成三个部分: BoardConfig.mk: 芯片硬件相关配置，分区设置等 product.mk: 一个产品的软件相关的配置，比如内置哪些软件模块，由AndroidProducts.mk 中的PRODUCT_MAKEFILES指定 AndroidProducts.mk: 指定 product 配置,并把 product 添加到 lunch 选择项中 2、组织结构 Google为AOSP源码内置了Product配置，位于源码的build/target目录: 123456789hinzer@ubuntu:target$ pwd/home/hinzer/source/android-10/build/targethinzer@ubuntu:target$ tree -L 1.├── board├── OWNERS└── product2 directories, 1 file 同时也允许第三方定制Product配置，在源码device目录下。待会自定义Product在这个目录下: 12345678hinzer@ubuntu:device$ tree mi mi # 公司名└── pure # device名(写为Product,与product区分),一个device可对应多个product ├── AndroidProducts.mk # 指定product配置，添加lunch选项 ├── BoardConfig.mk # 硬件配置 boardconfig └── product01.mk # 软件配置 product1 directory, 3 files 自定义product 模仿aosp源码的Product配置,就引用了build/target/board/generic_x86_64/BoardConfig.mk和build/target/board/generic_x86_64/BoardConfig.mk的配置。然后进行自定义 1、创建device/[company]/[device]目录 1hinzer@ubuntu:android-10$ mkdir -p ./device/mi/pure 2、分别添加AndroidProducts.mk、product.mk、BoardConfig.mk配置文件 123456789101112131415161718192021hinzer@ubuntu:pure$ lsAndroidProducts.mk BoardConfig.mk product01.mk# 1.添加 AndroidProducts.mkhinzer@ubuntu:pure$ cat AndroidProducts.mk PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/product01.mk # 指定 productCOMMON_LUNCH_CHOICES := \\ product01-eng # 添加lunch选项# 2.添加 BoardConfig.mk hinzer@ubuntu:pure$ cat BoardConfig.mk include $(SRC_TARGET_DIR)/board/generic_x86_64/BoardConfig.mk # 这里直接饮用# 3.添加 product01.mk hinzer@ubuntu:pure$ cat product01.mk $(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_x86_64.mk)PRODUCT_NAME := product01 # product名(与文件保持一致)PRODUCT_DEVICE := pure # device名，BoardConfig.mk相关 3、lunch刚才创建的product，编译 123hinzer@ubuntu:android-10$ source ./build/envsetup.shhinzer@ubuntu:android-10$ lunch product01-enghinzer@ubuntu:android-10$ make -j4 4、验证 12# 运行虚拟机hinzer@ubuntu:android-10$ emulator # 查看Android version信息，编译时间、产品名是否对应 理论补充 1、build variants aosp为build系统提供三种Product配置，文档里叫做build variants,分别是: eng : 对应到工程版。编译打包所有模块。表示adbd处于ROOT状态，所有调试开关打开 userdebug : 对应到用户调试版。打开调试开关，但并没有放开ROOT权限 user : 对应到用户版。关闭调试开关，关闭ROOT权限。最终发布到用户手上的版本，通常都是user版。 参考资料 AOSP开发文档 - 添加新设备 Android系统开发入门-2.添加product","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"02 添加系统属性","date":"2020-04-05T00:03:10.000Z","path":"计算机基础/开发平台/Android系统开发/02 添加系统属性/","text":"理解概念 1、基本描述 系统属性可以简单的理解为系统层级的全局变量，以key-value的形式保存， key-value 都是字符串。这些属性可能是有些资源的使用状态，进程的执行状态，系统的特有属性等。 2、命名规则 几种特殊前缀的属性 ro ：只读属性，不能修改。 persist ：修改属性后，重启依然有效。数据会保存到 /data/property 目录。其他前缀的属性被设置后，只是保存在内在中而已，并没有保存到磁盘，所以重启后就恢复默认值了。 ctrl ：用来启动和停止服务。每一项服务必须在 init.rc 中定义。init 一旦收到设置 ctrl.start 属性的请求，属性服务将使用该属性值作为服务名找到该服务，启动该服务。这项服务的启动结果将会放入 init.svc.&lt;服务名&gt; 属性中。 3、读写方法 在 Android 系统中有一个 Property Service 服务， 这个服务对外提供了两个接口： 12SystemProperties.get(String key, String def) # 读取系统属性SystemProperties.set(String key, String val) # 设置系统属性 有两个命令行对这两个接口进行了封装，我们可以直接在adb shell 中输入： 12getprop key # 读取系统属性setprop key val # 设置系统属性 4、组织结构 系统启动的时候会从几个配置文件中加载属性的默认值，大概有以下几个文件， 在不同Android版本系统上可能不一样： 123456/default.prop 或者是 /prop.default，/vendor/default.prop/system/build.prop/vendor/build.prop/data/local.prop/data/property/* 系统会按先后顺序依次加载以上文件，后加载的属性将覆盖原先的值。 default.prop 的值是通过 build/tools 目录下的 buildinfo.sh 和 vendor_buildinfo.sh 生成的。 源码中添加系统属性定义 在我们之前配置的product中添加自定义属性,在源码根目录device/mi/pure下,对应Build规则在build/make/core/Makefile,编译后输出到out/target/product/pure下，最终随系统启动加载对应的文件。 下面记录了添加属性过程 1、添加到/system/build.prop 12345678hinzer@ubuntu:pure$ pwd/home/hinzer/source/android-10/device/mi/purehinzer@ubuntu:pure$ cat system.propro.pure.version=1.0 # 定义属性hinzer@ubuntu:pure$ cat BoardConfig.mkinclude $(SRC_TARGET_DIR)/board/generic_x86_64/BoardConfig.mkTARGET_SYSTEM_PROP += device/mi/pure/system.prop # 添加到 TARGET_SYSTEM_PROP 变量 2、添加到/vendor/build.prop 12345678910111213hinzer@ubuntu:pure$ pwd/home/hinzer/source/android-10/device/mi/purehinzer@ubuntu:pure$ cat product01.mk$(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_x86_64.mk)PRODUCT_NAME := product01 # product名(与文件保持一致)PRODUCT_DEVICE := pure # device名，BoardConfig.mk相关# 配置属性PRODUCT_PROPERTY_OVERRIDES += \\ ro.vendor.pure.name=qiushao \\ persist.vendor.pure.name=qiushao \\ vendor.pure.name=qiushao 编译 123hinzer@ubuntu:android-10$ source ./build/envsetup.shhinzer@ubuntu:android-10$ lunch product01-enghinzer@ubuntu:android-10$ make -j4 验证 1、查看out/target目录 123456789# 验证 `/system/build.prop`hinzer@ubuntu:android-10$ cat out/target/product/pure/system/build.prop | grep ro.purero.pure.version=1.0# 验证 `/vendor/build.prop`hinzer@ubuntu:android-10$ cat out/target/product/pure/vendor/build.prop | grep pure.namero.vendor.pure.name=qiushaopersist.vendor.pure.name=qiushaovendor.pure.name=qiushao 2、启动虚拟机系统查看属性 123456789101112131415161718192021222324hinzer@ubuntu:android-10$ emulatorhinzer@ubuntu:android-10$ adb devicesList of devices attachedemulator-5554 devicehinzer@ubuntu:android-10$ adb reboot # 重启一下，重置系统属性hinzer@ubuntu:android-10$ adb shell getprop ro.pure.version1.0hinzer@ubuntu:android-10$ adb shell getprop ro.vendor.pure.nameqiushaohinzer@ubuntu:android-10$ adb shell getprop persist.vendor.pure.name qiushao# 只读属性不可改hinzer@ubuntu:android-10$ adb shell getprop ro.vendor.pure.nameqiushaohinzer@ubuntu:android-10$ adb shell setprop ro.vendor.pure.name hinzersetprop: failed to set property 'ro.vendor.pure.name' to 'hinzer'# 修改属性，重启后恢复原属性值hinzer@ubuntu:android-10$ adb shell setprop persist.vendor.pure.name hinzerhinzer@ubuntu:android-10$ adb shell getprop persist.vendor.pure.name hinzer 参考资料 Android系统开发入门-3.添加系统属性","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"00 配置开发环境","date":"2020-03-29T01:03:10.000Z","path":"计算机基础/开发平台/Android系统开发/00 配置开发环境/","text":"ubuntu系统环境 12hinzer@ubuntu:~$ uname -aLinux ubuntu 5.3.0-42-generic #34~18.04.1-Ubuntu SMP Fri Feb 28 13:42:26 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 配置android开发环境 123456789101112131415161718192021222324252627# 编译所需的工具和相关库sudo apt-get install openjdk-8-jdksudo apt-get install -y git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libssl-dev libssl-dev openssl autoconf m4 libxml2-utils bc libxml-simple-perl# git和repo工具管理android源码mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repoecho 'export PATH=$PATH:~/bin' &gt;&gt; ~/.bashrc source ~/.bashrc# 配置git账信息git config --global user.name \"xxx\"git config --global user.email \"xxxx@aaa.bb\"# 刷写和调试工具sudo apt-get install adb -ysudo apt-get install fastboot -ysudo apt-get install android-tools-adbsudo apt-get install android-tools-fastboot# 配置规则，解决无usb权限问题sudo touch /etc/udev/rules.d/70-android.rulessudo vim /etc/udev/rules.d/70-android.rules #添加：SUBSYSTEM==\"usb\", MODE=\"0666\" sudo chmod a+rx /etc/udev/rules.d/70-android.rulessudo service udev restart 下载android源码 由于国内访问google镜像受限，推荐使用清华大学开源镜像站 1234mkdir -p ~/source/android-10cd ~/source/android-10repo init -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r8 # 拉取repo长裤，-u指定远程repo仓库url，-b指定获取特定分支branchrepo sync # 同步代码 要要查看分支列表，请参阅源代码标记和细分版本 编译调试 1234567# 整编源码source ./build/envsetup.sh # 导出所需环境变量lunch &lt;product_name&gt; # 选择要编译的productmake -j4 # 开始编译，-j4表示使用4个线程编译# 运行虚拟机emulator # 查看系统信息确认是我们刚刚编译的系统 参考资料 android源码公开文档 - 下载源代码 android源码公开文档 - 编译系统 Android系统开发入门-0.开发环境准备 Android系统开发入门-1.Android系统源码下载编译","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Android系统开发","slug":"计算机基础/开发平台/Android系统开发","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Android系统开发/"}]},{"title":"03 系统调用","date":"2020-03-28T09:31:02.000Z","path":"计算机基础/开发平台/Linux系统学习/03 系统调用/","text":"相关概念 1、程序vs进程vs命令 Linux系统上所有的操作由进程完成，进程的运行是动态的，在此之前是一个静态的程序。用户用一个程序来启动一个进程，这个程序可以是别人写好的(最终被编译成可执行文件)，比如ls、pwd、cat，也可以是我们自己写的。 2、系统调用 无论如何，程序最后运行起来都是进程，并且一个程序想要在系统上跑，要用到系统调用,这是系统给用户提供的API接口。 3、strace命令 Linux有个命令strace，常用来跟踪进程执行时系统调用和所接收的信号。通过manstrace查看具体描述。 4、Glibc 作为一个开发者，也许平时并没有直接使用系统调用，而是Glibc库。Glibc是Linux下使用的开源的标准C库它是GNU发布的libc库。Glibc即系统调用的封装。 介绍系统调用 然后本文开始介绍这些系统调用，先上图 1、进程管理 linux操作系统使用叫fork的系统调用来创建进程，进程运行过程: 当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。按理说，如果不进行特殊的处理，父进程和子进程都按相同的程序代码进行下去，这样就没有意义了。 所以，我们往往会这样处理：对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过if-else语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用execve来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支（fork）了。 其他进程都是父进程fork出来的，对于操作系统而言，系统启动的时候先创建一个所有用户进程的“祖宗进程”。 2、内存管理 在操作系统中，每个进程都有自己的进程内存空间。其中布局就有代码段、数据段、堆。 一个进程的内存空间是很大的，32位的是4G，64位的就更大了。物理空间是有限的，所以进程的空间不能事先分配好的，一定是需要的时候再分配。 brk和mmap是官员堆分配内存的系统调用，分配内存数量比较小的时候，使用brk会和原来的堆的数据连在一起。当分配的内存数量比较大的时候，使用mmap，会重新划分一块区域。 3、文件管理 文件系统相当于公司的资料库，用于保存一些永久性质的数据。能做到长期保存，文件之所以能做到这一点，一方面是因为介质，另一方面是因为格式。 对于文件的操作，无非是创建、打开、读、写等等,对应的系统调用常有: 对于已经有的文件，可以使用open打开这个文件，close关闭这个文件； 对于没有的文件，可以使用creat创建文件； 打开文件以后，可以使用lseek跳到文件的某个位置； 可以对文件的内容进行读写，读的系统调用是read，写是write。 Linux中一切皆文件,就包括二进制文件、文本文件、stdout文件、Socket文件、设备文件、目录文件，包括进程运行起来在/proc下生成的进程号也是文件。 对于每一个文件，Linux分配了文件描述符，这是一个整数。 4、信号处理 信号是异步处理机制，用于紧急突发情况。常见信号有 在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出； 如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西； 硬件故障，设备出了问题，当然要通知项目组； 用户进程通过kill函数，将一个用户信号发送给另一个进程。 每一种信号都有默认动作，当然用户也能编写信号处理函数，通过sigaction系统调用进行处理。 5、进程间通信 本地进程之间实现数据的互通，比较常见的处理机制有消息队列和共享内存。 通过msgget创建一个新的队列，msgsnd将消息发送到消息队列，而消息接收方可以使用msgrcv从队列中取消息 我们可以通过shmget创建一个共享内存块，通过shmat将共享内存映射到自己的内存空间，然后就可以读写了。 6、网络通信 内核中有TCP/IP网络协议栈的实现，可以通过socket来实现跨系统的进程间通信。 查看源码中的系统调用 下载内核源码，找到./include/asm-x86_64/unistd.h文件，里面对于系统调用的定义 1234567891011hinzer@ubuntu:linux-2.6.11$ head ./include/asm-x86_64/unistd.h#ifndef _ASM_X86_64_UNISTD_H_#define _ASM_X86_64_UNISTD_H_#ifndef __SYSCALL#define __SYSCALL(a,b) #endif/* * This file contains the system call numbers. * 参考 趣谈Linux操作系统 - 刘超","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"bugreport","date":"2020-03-28T00:28:37.000Z","path":"技术开发/测试方法/bugreport/","text":"理解 原生android系统支持adb bugreport命令，生成日志包含设备日志、堆栈轨迹和其他诊断信息，可以帮助您查找和修复应用中的错误 1、目录结构 12345678910111213mi@ubuntu:bugreport$ tree -L 1.├── bugreport-dipper_ru-QKQ1.190828.002-2020-03-26-16-15-04.txt #最重要的文件├── dumpstate_board.txt├── dumpstate_log.txt├── FS├── lshal-debug├── main_entry.txt├── outfile.log├── proto└── version.txt3 directories, 6 files 常用操作 1、ANR和死锁 12345678910# 找出无响应的应用(系统会终止该进程并将堆栈转储到 /data/anr)grep &quot;am_anr&quot; bugreport-2015-10-01-18-13-48.txt # 为二进制事件日志中的 am_anr 执行 grep 命令grep &quot;ANR in&quot; bugreport-2015-10-01-18-13-48.txt # 为 logcat 日志（其中包含关于发生 ANR 时是什么在占用 CPU 的更多信息）中的 ANR in 执行 grep 命令# 查找堆栈跟踪( ANR 对应的堆栈跟踪 --&gt; 进程主线程)------ VM TRACES AT LAST ANR------ TRACES JUST NOW 和 # 查找死锁(系统服务器发生死锁，监控程序最终会将其终止)WATCHDOG KILLING SYSTEM PROCESS 2、Activity 12345678# 查看聚焦状态的activity(崩溃期间处于聚焦状态的 Activity 表示当前用户操作)grep &quot;am_focused_activity&quot; bugreport-2015-10-01-18-13-48.txt# 查看进程启动事件grep &quot;Start proc&quot; bugreport-2015-10-01-18-13-48.txt# 设备是否发生系统颠簸grep -e &quot;am_proc_died&quot; -e &quot;am_proc_start&quot; bugreport-2015-10-01-18-13-48.txt 3、内存 4、广播 5、显示器争用 6、后台编译 7、叙述 8、电源 9、程序包 10、进程 11、扫描 参考链接 获取并阅读错误报告 阅读错误报告 Android Log机制、Logcat及MIUI 284日志介绍","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"Log","slug":"Log","permalink":"https://hinzer.github.io/wiki/tags/Log/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"测试方法","slug":"技术开发/测试方法","permalink":"https://hinzer.github.io/wiki/categories/技术开发/测试方法/"}]},{"title":"bugreport","date":"2020-03-28T00:28:37.000Z","path":"技术开发/测试方法/logcat/","text":"理解 logcat是抓log的工具，从android logging系统抓取日志。 1、logcat相关目录 123代码位置：`/system/core/logcat/`编译生成的可执行文件位于：`out/target/product/umi/system/bin/logcat`(umi是产品名)对应到设备端的可执行文件：`/system/bin/logcat` 2、日志缓冲区 1234567radio：查看包含无线装置/电话相关消息的缓冲区。events：查看已经过解译的二进制系统事件缓冲区消息。main：查看主日志缓冲区（默认），不包含系统和崩溃日志消息。system：查看系统日志缓冲区（默认）。crash：查看崩溃日志缓冲区（默认）。all：查看所有缓冲区。default：报告 main、system 和 crash 缓冲区。 使用规范 1、过滤日志输出 12# tag:priority 标记:优先级$ adb shell logcat ActivityManager:I MyApp:D *:S 2、控制日志输出格式 12# -v &lt;format&gt;$ adb shell logcat -v thread 3、查看备用日志缓冲区 12# -b &lt;buffer&gt;$ adb shell logcat -b radio 命令速查 123456# 获取help$ adb shell logcat --help# 查log$ adb shell logcat -b system &gt; logSystem.txt #查询此时system的日志，并且保存在logSystem.txt的文件中^C 参考链接 Logcat 命令行工具 Android Log机制、Logcat及MIUI 284日志介绍","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"Log","slug":"Log","permalink":"https://hinzer.github.io/wiki/tags/Log/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"测试方法","slug":"技术开发/测试方法","permalink":"https://hinzer.github.io/wiki/categories/技术开发/测试方法/"}]},{"title":"理解测试用例","date":"2020-03-28T00:28:37.000Z","path":"技术开发/测试方法/如何编写一个好的测试用例/","text":"测试用例设计过程 以“用户登录”功能的测试用例设计为例，画了一张图来帮你理清这些概念之间的映射关系。图中的业务需求到软件功能需求、软件功能需求到测试需求，以及测试需求到测试用例的映射关系， 什么才算是“好的”测试用例？ 测试用例的好坏与被测试对象的测试结果无关，好的测试用例必须具备 整体完备性： “好的”测试用例一定是一个完备的整体，是有效测试用例组成的集合，能够完全覆盖测试需求。 等价类划分的准确性： 指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。 等价类集合的完备性： 需要保证所有可能的边界值和边界条件都已经正确识别。 三种最常用的测试用例设计方法 1、等价类划分方法 我们只要从每个等价类中任意选取一个值进行测试，就可以用少量具有代表性的测试输入取得较好的测试覆盖结果。 一个具体的例子 1学生信息系统中有一个“考试成绩”的输入项，成绩的取值范围是 0~100 之间的整数，考试成绩及格的分数线是 60。 最终测试用例为 有效等价类 1：0~59 之间的任意整数； 有效等价类 2：59~100 之间的任意整数； 无效等价类 1：小于 0 的负数； 无效等价类 2：大于 100 的整数； 无效等价类 3：0~100 之间的任何浮点数； 无效等价类 4：其他任意非数字字符。 2、边界值分析方法 边界值分析是对等价类划分的补充，你从工程实践经验中可以发现，大量的错误发生在输入输出的边界值上，所以需要对边界值进行重点测试，通常选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。 我们继续看学生信息系统中“考试成绩”的例子，选取的边界值数据应该包括： -1，0，1，59，60，61，99，100，101。 3、错误推测方法 错误推测方法是指基于对被测试软件系统设计的理解、过往经验以及个人直觉，推测出软件可能存在的缺陷，从而有针对性地设计测试用例的方法。这个方法强调的是对被测试软件的需求理解以及设计实现的细节把握，当然还有个人的能力。 如何才能设计出“好的”测试用例？ 查看原文 总结 首先，理解测试用例是一个完备的集合，好的测试用例从原始业务需求出发进行分析设计。其次，理解三种常用的测试用例设计方法等价类划分方法、边界值分析方法、边界值分析方法 参考 如何设计一个“好的”测试用例？","tags":[{"name":"代码测试","slug":"代码测试","permalink":"https://hinzer.github.io/wiki/tags/代码测试/"},{"name":"笔记","slug":"笔记","permalink":"https://hinzer.github.io/wiki/tags/笔记/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"测试方法","slug":"技术开发/测试方法","permalink":"https://hinzer.github.io/wiki/categories/技术开发/测试方法/"}]},{"title":"理解单元测试","date":"2020-03-28T00:28:37.000Z","path":"技术开发/测试方法/理解单元测试/","text":"理解概念 1、单元测试的概念理解 单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类。 一个工厂生产电视机的例子。如果把电视机的生产、测试和软件的开发、测试进行类比，你可以发现： 电子元器件就像是软件中的单元，通常是函数或者类，对单个元器件的测试就像是软件测试中的单元测试； 组装完成的功能电路板就像是软件中的模块，对电路板的测试就像是软件中的集成测试； 电视机全部组装完成就像是软件完成了预发布版本，电视机全部组装完成后的开机测试就像是软件中的系统测试。 2、单元测试对开发的好处 单元测试属于最严格的软件测试手段，是最接近代码底层实现的验证手段，可以在软件开发的早期以最小的成本保证局部代码的质量。 单元测试都是以自动化的方式执行，所以在大量回归测试的场景下更能带来高收益。 单元测试的实施过程还可以帮助开发工程师改善代码的设计与实现，并能在单元测试代码里提供函数的使用示例，因为单元测试的具体表现形式就是对函数以各种不同输入参数组合进行调用，这些调用方法构成了函数的使用说明。 掌握方法 如何做好单元测试?你首先必须弄清楚单元测试的对象是代码，以及代码的基本特征和产生错误的原因，然后你必须掌握单元测试的基本方法和主要技术手段。 1、代码基本特征与产生错误的原因 1无论是开发语言还是脚本语言，都会有条件分支、循环处理和函数调用等最基本的逻辑控制，如果抛开代码需要实现的具体业务逻辑，仅看代码结构的话，你会发现所有的代码都是在对数据进行分类处理，每一次条件判定都是一次分类处理，嵌套的条件判定或者循环执行，也是在做分类处理。 可见，要做到代码功能逻辑正确，必须做到分类正确并且完备无遗漏，同时每个分类的处理逻辑必须正确。而在开发实践的过程中，通常考虑从以下方面考虑 如果要实现正确的功能逻辑，会有哪几种正常的输入； 是否有需要特殊处理的多种边界输入； 各种潜在非法输入的可能性以及如何处理。 2、测试用例 单元测试的用例是一个输入数据和预计输出的集合。 完整的输入数据 123456被测试函数的输入参数；被测试函数内部需要读取的全局静态变量；被测试函数内部需要读取的成员变量；函数内部调用子函数获得的数据；函数内部调用子函数改写的数据；嵌入式系统中，在中断调用时改写的数据 明确的预计输出 1234567被测试函数的返回值；被测试函数的输出参数；被测试函数所改写的成员变量；被测试函数所改写的全局变量；被测试函数中进行的文件更新；被测试函数中进行的数据库更新；被测试函数中进行的消息队列更新； 3、驱动代码，桩代码和Mock代码 驱动代码，桩代码和Mock代码，是单元测试中最常出现的三个名词 驱动代码，指调用被测函数的代码，单元测试过程中，驱动模块通常包括调用被测函数前的数据准备、调用被测函数以及验证相关结果三个步骤。驱动代码的结构，通常由单元测试的框架决定。 桩代码，是用来代替真实代码的临时代码。 比如，某个函数 A 的内部实现中调用了一个尚未实现的函数 B，为了对函数 A 的逻辑进行测试，那么就需要模拟一个函数 B，这个模拟的函数 B 的实现就是所谓的桩代码。 Mock，Mock 代码和桩代码非常类似，都是用来代替真实代码的临时代码，起到隔离和补齐的作用。在使用 Mock 代码的测试中，对于结果的验证（也就是 assert），通常出现在 Mock 函数中。 实际流程 实际软件项目中开展单元测试 并不是所有的代码都要进行单元测试，通常只有底层模块或者核心模块的测试中才会采用单元测试。 你需要确定单元测试框架的选型，这和开发语言直接相关。 为了能够衡量单元测试的代码覆盖率，通常你还需要引入计算代码覆盖率的工具。 最后你需要把单元测试执行、代码覆盖率统计和持续集成流水线做集成，以确保每次代码递交，都会自动触发单元测试，并在单元测试执行过程中自动统计代码覆盖率，最后以“单元测试通过率”和“代码覆盖率”为标准来决定本次代码递交是否能够被接受。 总结 全部笔记内容从茹炳晟的《软件测试52讲》整理。 参考链接 什么是单元测试？如何做好单元测试？","tags":[{"name":"代码测试","slug":"代码测试","permalink":"https://hinzer.github.io/wiki/tags/代码测试/"},{"name":"笔记","slug":"笔记","permalink":"https://hinzer.github.io/wiki/tags/笔记/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"测试方法","slug":"技术开发/测试方法","permalink":"https://hinzer.github.io/wiki/categories/技术开发/测试方法/"}]},{"title":"git fetch","date":"2020-03-28T00:24:37.000Z","path":"技术开发/源码管理/git-fetch/","text":"理解 从远程取最新的patch或者分支，引用的信息记录到.git/FETCH_HEAD这个文件中。可以借助git fetch --help查看具体描述。可以操作一个分支git pull = git getch + git merge，也可以单独pick一个patchgit fetch + git cherry-pick。 使用准则 无 命令速查 12345678### 从gerrit上取一个patch，然后pick到当前分支git fetch ssh://wangjianfeng1@git.mioffice.cn:29418/device/xiaomi/merlin refs/changes/17/909617/1git cherry-pick FETCH_HEAD### 获取远程库的分支更新，然后merge到本地分支git fetch origin master:tmp #从远程仓库master分支获取最新，在本地建立tmp分支git diff tmp #將當前分支和tmp進行對比git merge tmp #合并tmp分支到当前分支 参考 git fetch 和git pull 的差别","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"push代码","date":"2020-03-28T00:24:37.000Z","path":"技术开发/源码管理/push代码/","text":"用法 12345678910111213wjf@ubuntu:base$ pwd/home/wjf/miui/umi-q/frameworks/basewjf@ubuntu:base$ repo info .Manifest branch: miui-q-umi-stableManifest merge branch: refs/heads/stableManifest groups: all,-notdefault----------------------------Project: platform/frameworks/baseMount path: /home/wjf/miui/umi-q/frameworks/baseCurrent revision: miui-q-umi-stableLocal Branches: 0----------------------------wjf@ubuntu:base$ git push ssh://wangjianfeng1@gerrit.pt.miui.com:29418/platform/frameworks/base HEAD:refs/for/miui-q-umi-stable git push git语法表示远程推送,git push help查看详细情况 ssh://wangjianfeng1@gerrit.pt.miui.com:29418/platform/frameworks/base表示使用ssh协议访问gerrit服务器的29418端口，通过url定位到frameworks/base这个目录，是要推送的目录 HEAD:refs/for/miui-q-umi-stable,HEAD指向当前的本地分支，refs/for/miui-q-umi-stable表示远程分支名。 ps: 在修改目录下，git remote -v命令查看代码服务器的git仓库的链接，repo info .获取gerrit仓库远程提交点（分支名） 参考 SSH协议语法格式","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"打patch","date":"2020-03-28T00:24:37.000Z","path":"技术开发/源码管理/打patch/","text":"理解 patch是某一次提交给文件内容的改变，打patch是将某一次改变的内容应用到当前的版本库。 常规操作 1234567# 生成patchgit diff ./ &gt; xxx.patch #将差异的内容制作成patchmkdir update &amp;&amp; git diff commit-id-time1 commit-id-time2 --name-only | xargs -i cp '&#123;&#125;' ./update/ --parents #制作patch 把两个commit-id 之间修改的文件复制到update目录中 而且会把中间的目录也一并生成# 打patchpatch -p1 &lt; xxx.patch 另外 不过我们有线上的gerrit仓库，日常使用git fetch + git cherry-pick效果是一样的，cherry-pick直接pick某一个patch. 参考 你知道用git打补丁吗？ Git Commands - Patching","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"android源码管理工具","date":"2020-03-27T16:11:37.000Z","path":"技术开发/源码管理/android源码工具/","text":"Google使用git和repo管理AOSP源码。 概念区分 1、Git和git(https://source.android.com/setup/develop#git) Git是版本控制系统，我们使用git工具进行代码仓库和分支的管理。比如我可以使用git clone从远程仓库的一个分支下载代码到本地，可以git push将本地仓库的某一个分支推送到远程仓库的分支，关于git使用可以参考progit Google将android源码拆分成许多个Git仓库，我们知道每一个git仓库下有.git文件 12345678910111213141516171819hinzer@ubuntu:android-10$ find -name \".git\"./developers/demos/.git./developers/build/.git./developers/samples/android/.git./.repo/repo/.git./.repo/manifests/.git./cts/.git./platform_testing/.git./prebuilts/go/linux-x86/.git./prebuilts/go/darwin-x86/.git./prebuilts/build-tools/.git./prebuilts/clang/host/linux-x86/.git./prebuilts/clang/host/darwin-x86/.git./prebuilts/checkcolor/.git./prebuilts/android-emulator/.git./prebuilts/asuite/.git./prebuilts/gradle-plugin/.git./prebuilts/manifest-merger/.git^C 2、Repo和repo(https://source.android.com/setup/develop#repo) 然后使用一个Repo仓库对这些拆分开来的Git仓库集中起来进行管理，在源码根目录下有一个.repo文件，其中manifest.xml是一个清单文件，记录了远程分支、本地分支、本地目录之间对应关系。 1234567891011hinzer@ubuntu:android-10$ tree .repo -L 1.repo├── manifests # 所有清单文件保存├── manifests.git├── manifest.xml # 重要，当前清单文件的指向！！├── project.list├── project-objects├── projects└── repo5 directories, 2 files 在.repo目录之前，还有一个repo工具(通过它来初始化repo仓库)，这是一个python写的脚本，可以直接阅读源码(也就是可执行文件的位置)查看代码逻辑。 123hinzer@ubuntu:android-10$ whereis reporepo: /home/hinzer/bin/repohinzer@ubuntu:android-10$ cat /home/hinzer/bin/repo PS: google将android源码拆分成许多个Git仓库，又通过Repo将这些拆分还原回一个android源码。像不像计算机原理中的化整为零，还零为整的思想？ 平时使用 1、Repo和Git Repo 并非用来取代 Git，只是为了让您在 Android 环境中更轻松地使用 Git。一般我们使用repo命令建立Repo仓库，同步android源码；使用git命令对我们修改的其中一个模块提交。 2、Gerrit仓库 一个网页系统，用于代码审核，也方便查看别人提交的patch。 3、OpenGrok 网页系统，在线阅读源码的利器。 4、Android Studio 用于开发 Android 应用的官方集成开发环境 (IDE)。 相关资料 Git 文档 Repo 命令参考文档","tags":[{"name":"Android","slug":"Android","permalink":"https://hinzer.github.io/wiki/tags/Android/"},{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"},{"name":"Repo","slug":"Repo","permalink":"https://hinzer.github.io/wiki/tags/Repo/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"02 Linux命令","date":"2020-03-21T14:01:02.000Z","path":"计算机基础/开发平台/Linux系统学习/02 Linux命令/","text":"阅读刘超老师的《趣谈Linux操作系统》，然后整理了这篇笔记，文章中讲了多种常见的Linux命令。我挑2个我认为挺重要的操作，运行程序和安装软件的命令整理一下。 运行程序 通过命令行让Linux执行程序，有以下几种方式，也决定进程已什么方式运行。 1、交互式运行 1$ ./filename # 交互式运行，Ctrl+C可以结束这个在执行的进程 2、后台方式运行 123456# 脱离终端后台运行，并将log输出到xxx.outfile文件。# nohup命令使终端关闭也不影响进程(进程正常是终端进程fork过来的，父进程挂起....), 2&amp;&gt;1表示将标准输出合并错误输出到xxx.outfile,&amp;设置进程后台运行$ nohup ./command &gt; xxx.outfile 2&amp;&gt;1 &amp; # 后台运行进程# ps -ef |grep 关键字过滤出进程信息，通过awk '&#123;print $2&#125;'找出进程id，然后通过xargs命令传递给kill -9 ，最终干掉这个进程$ ps -ef |grep 关键字 |awk '&#123;print $2&#125;'|xargs kill -9 # kill 这个进程的方法 3、服务方式运行 12345# systemctl工具管理服务$ systemctl enable service-name$ systemctl start service-name$ systemctl stop service-name..... 现在有一个小问题 Q: 后台运行的进程和服务都是可以脱离终端独立存在的，那么两者有什么区别呢？ &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; A：查到系统服务的概念，总结两点区别：1、服务是系统功能的进程；进程是用户的进程。2、服务不会与用户交互，在后台默默运行(这点和后台进程一样) 安装软件 无论是Ubuntu系还是CentOS系的Linux发行版，总有几种安装软件的方式，下载安装包、通过软件管家、直接下载压缩包或者通过源码编译。 1、下载安装包安装 1$ dpkg -i xxxx.deb # 如果是chentos的话，使用rpm命令 2、通过软件管家安装 1$ apt-get install xxxx # 如果是chentos的话，使用yum命令 3、下载压缩包安装 1export PATH=XXX/bin:PATH #将可执行文件bin添加到PATH变量，可将这个命令配置在~/.bashrc文件，每次重启Linux加载这个文件 4、源码编译安装 12345678# 对当前环境评估，--prefix指定安装路径$ ./configure --prefix=/usr/local/program# 编译生成安装包$ make# 安装软件$ make install 总结 引用文章中总结的图片 课后作业 课后要求是安装jdk和mysql，搭建一个数据库服务。我没有去做，不过我找到一个部署的教程,很有参考意义: 使用LNMP架构部署动态网站环境 参考资料 快速上手几个Linux命令：每家公司都有自己的黑话","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"01 操作系统","date":"2020-03-21T12:33:10.000Z","path":"计算机基础/开发平台/Linux系统学习/01 操作系统/","text":"哪有什么岁月静好，只不过有人替你负重前行。而操作系统就扮演了这样一个负重前行的角色 计算机硬件组成 对于一台电脑，拆开来看，有鼠标键盘、显卡显示屏、CPU、内存、硬盘、网卡… 但仅有硬件组成的电脑，还不能直接使用。&quot;硬件 + 操作系统&quot;才算是我们通常说的电脑，以后的学习主要围绕linux系统，这个话题展开。我们首先必须承认操作系统的重要性。 想理解外包公司一样理解操作系统 刘超老师将操作系统类比成一家外包公司。确实很形象，加深了我对linux系统的理解。 内核对于操作系统，相当于公司的老板，老板是不轻易干活的(一般有很多部门)，所以linux系统中也有很多子系统。对应关系有： linux系统 外包公司 用户 公司的客户 内核 公司的老板 系统调用 公司的办事大厅 设备管理系统 公司的客户对接和交付部门 网络管理系统 公司的对外合作部门 进程管理系统 公司的项目管理部门 内存管理系统 公司的会议室 文件系统系统 公司的档案室 其他：程序相当于项目计划书，进程相当于正在进行的项目。 “点击QQ事件” 为了更好的理解linux的运作机制，老师分析了&quot;用户点击qq&quot;事件。分为如下几个阶段 阶段一：用户点击图标 对于linux而言，驱动捕捉到用户点击事件，产生中断。cpu调用到驱动事先安排好的中断处理函数。 对于外包公司而言，对接人员记录客户提出的需求，进行项目开发的计划。 阶段二：系统加载进程 对于linux而言，将qq的程序文件从硬盘加载到内存，内存上以进程启动。这个阶段需要思考几个问题： 1. 硬盘上的文件如何管理？ 2. 内存空间上的进程如何管理？ 3. 多进程如何实现？ 4. 进程自身如何实现功能？ 硬件上的数据有文件系统进行统一管理；进程在内存空间上的映射由内存管理系统完成；多进程的实现通过进程管理系统；系统对进程提供统一的接口，实现核心功能。这层接口称为系统调用层。 对于外包公司而言，从档案库中取出项目计划书，成立项目组，划分会议室，完成立项的过程。然后执行项目，通过办事大厅处理业务，和各个部门打交道。这些都是动态的过程。之后就比较好理解了。 阶段三：进程调出对话框 对于linux而言，进程调出显示对话框，进程-&gt;显卡驱动-&gt;显示界面 对于公司，这里显卡驱动相当于客户的交付人员，项目组通过交付人员将项目的成果交付给用户。 阶段四：用户操作输入框 用户在输入框输入，字符立即显示，键盘驱动-&gt;进程-&gt;显卡驱动-&gt;显示界面 对于公司，就是对接人员处理客户不断提出的需求–交付人员交付的过程 阶段五：用户按回车发送 对于linux系统，用户按下回车键，网络发送到远程的另一个用户，键盘驱动-&gt;进程-&gt;网卡驱动 对于公司，有时候为了实现需求，需要与其他公司的交互，通过对外合作部门。 总结 以一张图片概括我对这篇文章的理解 课后作业 对于课堂练习，找出linux源码中几个子系统所在的目录（参考同学给出的答案） linux内核：https://www.kernel.org/ 系统调用 kernel/ 进程管理 kernel/, arch//kernel 内存管理 mm/, arch//mm 文件系统 fs/ 设备系统 drivers/char, drivers/block 网络系统 net/ 参考资料 《趣谈Linux操作系统》03章","tags":[{"name":"note","slug":"note","permalink":"https://hinzer.github.io/wiki/tags/note/"},{"name":"Linux","slug":"Linux","permalink":"https://hinzer.github.io/wiki/tags/Linux/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"开发平台","slug":"计算机基础/开发平台","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/"},{"name":"Linux系统学习","slug":"计算机基础/开发平台/Linux系统学习","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/开发平台/Linux系统学习/"}]},{"title":"git 调试","date":"2020-03-20T01:20:14.000Z","path":"技术开发/源码管理/git调试/","text":"概念理解 git blame和git bisect能帮助调试git项目，找到出bug的原因。 操作方法 1、文件标注 使用git blame能显示任何文件中每行最后一次修改的提交记录。git blame --help查看具体描述 1234mi@ubuntu:base$ git blame Android.bp -L 230,231 #查看Android.bp的230-231行提交记录，#commit id #提交者 #时间 #行 #内容7c469179ce2a (junyulai 2019-01-16 20:23:34 +0800 230) \"core/java/android/net/ISocketKeepaliveCallback.aidl\",e40eab608af2 (Benedict Wong 2018-11-14 17:50:13 -0800 231) \"core/java/android/net/ITestNetworkManager.aidl\", 2、二分查找 git bisect能在commit区间中检出中间的patch，通过不断地二分查找，最终定位到带bug的patch 1234567891011# 开始$ git bisect start # 启动二分$ git bisect bad # 当前提交有bug$ git bisect good &lt;good_commit&gt; #指定已知的最后一次正常状态是哪次提交# 测试 --&gt; 二分判断$ git bisect good # 当前提交无bug$ git bisect bad # 当前提交有bug# 结束$ git bisect reset 参考 Git 工具 - 使用 Git 调试","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git merge失败","date":"2020-03-19T16:11:37.000Z","path":"技术开发/源码管理/2020-03-20-bug-for-git/","text":"问题描述 git merge本地分支出现报错 fatal: refusing to merge unrelated histories 第一反应 我现在都是在本地操作还没有远程，我得理解master分支merge到slave分支，应该直接fast forward过去才对。 如果把master分支干掉，直接在slave分支那个位置创建一个master分支应该也没什么影响。就是特别像知道为啥会出错这个merge。 问题分析 merge命令之后报错fatal: refusing to merge unrelated histories。，表示当前分支和slave分支不相关。有对应的解决方案 加上--allow-unrelated-histories参数，忽略这个问题。 然而又报错，根据进一步提示，git status发现当前工作目录确实存在冲突。解决完冲突commit之后，再次merge就可以了。 不记得当时具体做了什么操作了，又重新做了几遍还是没能把当时的情景复现出来(merge直接fast forward了)。后来分析应该是某种原因导致了文件冲突，进而影响之后的merge操作。 解决方法 如果是git pull或者git push报fatal: refusing to merge unrelated histories,直接在merge后加上--allow-unrelated-histories参数就ok了 如果是依然无效，不妨先git status查看一下当前版本库的状态有无问题(我这边是冲突引起的)。 参考资料 解决Git中fatal: refusing to merge unrelated histories","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"},{"name":"Bug","slug":"Bug","permalink":"https://hinzer.github.io/wiki/tags/Bug/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git log","date":"2020-03-18T16:11:37.000Z","path":"技术开发/源码管理/git-log/","text":"理解 显示项目提交历史，通过参数选项可以控制log显示的方式。git help log查看具体描述。 git log 有两个高级用法：一是自定义提交的输出格式，二是过滤输出哪些提交。这两个用法合二为一，你就可以找到你项目中你需要的任何信息。 使用准则 git log允许你查看你项目历史中任何需要的内容。 命令速查 1、常规使用,查看git log常用选项 123git log --oneline --graph --all #简略显示各种分支的patch记录，个人比较下常用这个命令git log --stat # 显示每次提交的文件修改统计信息。git log -p # 按补丁格式显示每个提交引入的差异。 2、定制化输出,查看–pretty=format常用格式 12$ git log --pretty=format:\"%h %s\" --graph$ git log --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:\"%h-%an-%ad-%ae\" --graph --all –date=format定制作者修订日期格式 –pretty=format定制log记录显示 –graph图形显示分支与合并历史 –all显示所有分支 3、过滤出自己想要看到的log,查看限制输出长度 1234$ git log -3 #按次数，最近3次提交log$ git log --since=2.weeks #按时间，最近两周提交log$ git log --until=2020-03-20 #按时间，2020-03-20前的提交log$ git log --grep=\"update\" #仅显示提交说明中包含\"update\"的提交 4、如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令： 12345678$ git log --pretty=\"%h - %s\" --author='Junio C Hamano' --since=\"2008-10-01\" \\ --before=\"2008-11-01\" --no-merges -- t/5610e3b - Fix testcase failure when extended attributes are in useacd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() APIf563754 - demonstrate breakage of detached checkout with symbolic link HEADd1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths51a94af - Fix \"checkout --track -b newbranch\" on detached HEADb0ad11e - pull: allow \"git pull origin $something:$current_branch\" into an unborn branch 参考 Git 基础 - 查看提交历史 Git日志格式、颜色设置 Linux下date命令，格式化输出，时间设置","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git log","date":"2020-03-18T16:11:37.000Z","path":"技术开发/源码管理/git-merge/","text":"理解 工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。git help merge命令查看具体描述。 将topic分支merge到master分支上(更新master分支)，使用git merge topic 12345678合并前: A---B---C topic / D---E---F---G master合并后: A---B---C topic / \\ D---E---F---G---H master 使用准则 merge或者pull之前本地仓库是干净的应当commit本地，保证merge之后不会被破坏。或者git stash储藏本地的修改 merge冲突后可以使用git status查看分支状态，git diff显示工作区文件变化 命令速查 1234567$ git merge slave # merge slave分支到当前HEAD分支， --no-ff $ git merge slave --no-ff # 不使用fast-forward模式，merge同时创建一个新的cmomit patch$ git merge slave --allow-unrelated-histories #$ git merge -Xignore-space-change whitespace # 忽略空白merge$ git merge --abort # (merge失败)恢复到合并前的状态$ git merge --continue # 冲突后执行 参考 git help merge 高级合并","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git rebase","date":"2020-03-18T16:11:37.000Z","path":"技术开发/源码管理/git-rebase/","text":"理解 rebase也是整合不同分支的方法，和merge不同的是它会改变提交历史。git help rebase命令查看具体描述。 假设当前HEAD指向topic分支，下面执行rebase命令(将topic上的patch打到master上，并改变历史)，使用git rebase master 123456789rebase前: A---B---C topic / D---E---F---G masterrebase后: A'--B'--C' topic / D---E---F---G master 原理:首先找到这两个分支（即当前分支 topic、变基操作的目标基底分支 master 的最近共同祖先 E，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 G, 最后以此将之前另存为临时文件的修改依序应用 使用准则 rebase操作可以让提交历史更加简介，但注意不要影响远程分支的提交历史记录。不要在公共分支上使用rebase 如果你想把rebase之后的master分支推送到远程仓库，Git会阻止你这么做，因为两个分支包含冲突。但你可以传入--force标记来强行推送。 命令速查 1234git rebase master topic #master是基底分支，将topic分支上的修改在master上重放git rebase --onto master server client #选中在 client 分支里但不在 server 分支里的修改，将它们在 master 分支上重放 参考 Git 分支 - 变基 Merge、Rebase 的选择","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git revert","date":"2020-03-18T16:11:37.000Z","path":"技术开发/源码管理/git-revert/","text":"理解 revert还原提交，撤销已经存在的commit的所有更改，原来的commit将保留，并用新commit来记录还原后的结果。git help revert命令查看具体描述。 使用准则 无 命令速查 123456git revert HEAD # 撤销当前HEAD指向的patch上的更改git revert commit # 撤销制定commitid表示的patch上的更改# merge之后的revertgit revert -m 1 HEAD # HEAD指向的节点有两个父节点,-m 1保留父节点1，撤销父节点2带来的改变 参考 工具 - 高级合并 git revert 用法 回滚错误的修改","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git reset、git checkout","date":"2020-03-18T16:11:37.000Z","path":"技术开发/源码管理/git-reset_git-checkout/","text":"理解 1、git三棵树,即 HEAD，永远指向当前分支的最新一笔提交 Index，索引(暂存区) Work Directory,工作目录 12345#git 底层命令git cat-file -p HEAD #显示HEAD内容git ls-tree -r HEAD #显示树对象的内容git ls-files -s #显示索引(Index)的所有文件信息tree #查看当前工作目录 2、git-reset 将当前HEAD重置为指定状态。git help reset命令查看具体描述。 使用准则 运行git --hard reset之前请考虑一下。如果由于执行这个选项导致工作目录中文件(文件已经提交)被覆盖，可以尝试git reflog找回。 命令速查 1、作用于某个patch 123git reset --soft [patch] #移动HEAD的指向，不改变Index和Work Directorygit reset --mixed [patch] #(默认reset)移动HEAD的指向，改变Index，但不改变Work Directorygit reset --hard [patch] #移动HEAD的指向，改变Index和Work Directory 2、作用于某个path/file 12git reset [path/file] #通过当前HEAD指向的patch改变当前Index(恢复暂存区)git reset [patch] [path/file] #通过指定patch改变当前Index 3、压缩提交 12git reset --soft [patch] #HEAD移动到压缩提交的前一个patch，Index和Work Directory不变git commit #通过Index创建新的patch ###git reset 和 git checkout 总结了两点重要的区别， 操作patch时，chekcout只移动HEAD指针本身(不改变HEAD分支) 操作path/file时，checkout会改变工作目录(类似git reset --hard) 参考 Git 工具 - 重置揭密 多种表示patch的方式","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git stash、git clean","date":"2020-03-18T16:11:37.000Z","path":"技术开发/源码管理/git-stash_git-clean/","text":"理解 贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。或在清理(clean)文件。 使用准则 无 命令速查 1234567891011121314151617$ git stash push # stash跟踪文件的修改与暂存的改动$ git stash push --keep-index # --keep-index 选项使存储的同时保留索引。$ git stash push --all # -u 选项存储untracked文件，$ git stash push -u # stash全部文件(包括被忽略文件)$ git stash list # 列出当前的stash$ git stash apply # 应用stash, 加上--index 选项可以让之前暂存的文件重新暂存$ git stash drop stash@&#123;0&#125; # 移除stash,$ git stash pop # 应用stash@&#123;0&#125;,并移除它$ git stash branch dev # 创建新分支dev，然后应用stash,然后drop stash$ git clean -f -d # 移除工作目录中所有未追踪的文件以及空的子目录(不包括被忽略文件)$ git clean -n # 演戏以下，加-n参数$ git clean -n -x # -x选择清理忽略文件$ git clean -x -i # -i交互模式 参考 Git 工具 - 贮藏与清理","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git 对象","date":"2020-03-18T16:11:37.000Z","path":"技术开发/源码管理/git对象/","text":"窥探 git对文件内容管理核心是基于键值对数据库，位于.git/objects。通过key-value方式管理内容。 对象数据库中存储的三种对象，每一个对象在数据库中以key-value形式存在 数据对象（blob object），记录文件内容,解决内容存储问题 树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起 提交对象（commit object），对应一次提交，解决项目快照的问题 命令速查 1、通用操作 123456find .git/objects -type f # 列出所有git对象git cat-file -p &lt;key&gt; # 查看对象内容信息git cat-file -t &lt;key&gt; # 查看对象类型git cat-file -p master^&#123;tree&#125; #查看master分支上最近提交的树对象 PS: 尝试git add、git commit等上层命令，然后find .git/objects -type f查看git对象的变化。 发现：git每次add文件，添加数据对象；commit之后，又创建了树对象、和提交对象。 于是得出结论：git会记录每一次变化的文件版本(生成blob对象)，对于没有修改的文件tree还是原来的指向。 2、创建数据对象 123456# 内容写入数据库，返回key值$ echo 'test content' | git hash-object -w --stdin # -w表示写入数据库, --stdin表示从标准输入流读取$ echo 'version 1' &gt; test.txt$ git hash-object -w test.txt #从文件读取内容写入数据库 3、创建树对象 123456789101112# 为文件添加暂存区(index)$ git update-index --add --cacheinfo 100644 \\ 83baae61804e65cc73a7201a7252750c76066a30 test.txt # --add表示这个文件此前没有添加到index, --cacheinfo表示添加的文件在数据库中 匹配此的参数格式为(文件模式 key 文件名)$ git write-tree #通过暂存区创建树对象# 方式二$ echo 'new file' &gt; new.txt$ git update-index --add --cacheinfo 100644 \\ 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt$ git update-index --add new.txt文件名)$ git write-tree #通过暂存区创建树对象 4、创建提交对象 123$ echo 'first commit' | git commit-tree d8329f #(没有父提交)第一步提交$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3 #-p参数制定父提交对象的key 5、查看提交历史 1$ git log --stat 0155eb 参考 Git 内部原理 - Git 对象 Git 工具 - 重置揭密","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"git 引用","date":"2020-03-18T16:11:37.000Z","path":"技术开发/源码管理/git引用/","text":"理解 git用文件保存patch的哈希值，这个文件名代表一个分支。指针、分支、引用理解是表示一个概念。 1、在.git目录下查看 1234HEAD #指向当前分支refs/heads/ #分支，记录本地commit对象refs/tags/ #tag也记录commit对象，但是通常不会改变refs/remotes/origin/ #服务器映射下来的远程只读分支 2、查看HEAD内容 12345678mi@ubuntu:test3$ cd .gitmi@ubuntu:.git$ cat HEADref: refs/heads/mastermi@ubuntu:.git$ cat refs/heads/masterca82a6dff817ec66f44342007202690a93763949mi@ubuntu:.git$ git show HEADcommit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master) 参考 Git 内部原理 - Git 引用","tags":[{"name":"Git","slug":"Git","permalink":"https://hinzer.github.io/wiki/tags/Git/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"《小狗钱钱》","date":"2020-03-16T23:42:42.000Z","path":"生活学习/读书笔记/小狗钱钱/","text":"这本书的重点内容： 怎么攒钱？开始储蓄，迈出财富积累的第一步 怎么挣钱？付出劳动，挣出第一桶金 怎么用钱生钱？学会投资，养一只会下金蛋的鹅 怎么攒钱？ 攒钱这件事要从哪开始呢？小狗钱钱说，首先要从你脑子里的想法开始。我们首先要正确地认识钱，金钱既不是万能的，也不是万恶之源，它本身没有好坏之分，只是商品流通的媒介。金钱就像一个放大镜，它只是充分展示了人性本来的样子。一个幸福的人有了钱，会更加快乐；一个悲观的人有了钱，会更加忧虑。像比尔·盖茨、扎克伯格这样的人，有了钱，会捐出巨资，帮助他人。而像伊斯兰国这样的恐怖组织，会用钱去购买武器，伤害无辜。 你是什么样的人？如果有了钱，你会去做什么？对我们大多数人来说，有了钱，可以提高生活质量，去实现更多的梦想。反之，越是缺钱，我们就越容易被它牵制。小狗钱钱说，吉娅的父母之所以不停地谈钱，就是因为他们的经济状况太糟糕了，好比一个人掉进水里，随时可能会被淹没。 梦想清单 用笔写下10个你想变得富有的理由，越具体越好，然后从中挑出三个最重要的。在书里，吉娅挑出的3个理由包括，作为交换生去美国，买一台电脑，以及帮助爸妈还清债务。 梦想相册 那怎么制作梦想相册呢？比如，吉娅想去美国当交换生，她就在相册里贴上迪士尼乐园、自由女神像的照片。相册做完后，吉娅也没有束之高阁，而是每天都看几遍，想象自己在美国认识新的朋友，看到各种新鲜事物。这种方式让吉娅充满了攒钱的动力。 梦想储蓄罐 存钱可以让我们避免不必要的花费，做到量入为出。比如吉娅为了存钱，克制住了自己的欲望，没有直接用一个月的零花钱来买一张CD；而且存起来的钱，无论是放到银行还是买理财产品，都可以让你享受到复利、也就是利滚利的好处。这点非常关键。 在这本书里，小狗钱钱给吉娅的建议是 5-4-1原则，就是说，除了最必要的日常开销，剩余的收入分成10份，其中五份用来投资，四份放在梦想储蓄罐里，一份当作奖励自己的零花钱。哪怕你每个月日常开销以后只剩100块，也可以按照5-4-1原则来分配 这就是让你开始攒钱的三个步骤，制作梦想清单、梦想相册和梦想储蓄罐。一旦开始储蓄，你就迈出了财富积累的第一步 PS:如果一个人出现资产负债的话，又谈何财富积累呢？ 走出负债 停掉手中所有的信用卡 在允许范围内，尽量按照较低的分期付款数目标准来支付 边攒钱边还消费贷款 那就是每次在付款之前，都再问自己一句“这真的有必要吗？” 小结：以上我们着重讲了财富积累的第一步，储蓄。想要获得财富，首先我们必须牢牢树立攒钱的意识。本书为我们介绍了开始攒钱的三个步骤，制作梦想清单、梦想相册和梦想储蓄罐。同时，针对有债务困扰的人，小狗钱钱也给了我们四点忠告，分别是：停掉所有信用卡、按照较低分期付款标准支付贷款、攒钱还款两不误，以及每次花钱之前，问问自己“这真的有必要吗”。 怎么挣钱？ 小狗钱钱先告诉吉娅要攒下零花钱，但是零花钱只有那么一点，为了实现去美国当交换生的梦想，吉娅还要攒更多的钱才行，于是她开始琢磨怎么挣钱。 一个12岁的小女孩能做什么呢？吉娅自己也非常茫然。这和我们大部分人的情况很像，我们都想赚钱，但怎么赚呢？ 赚钱法则 你得为别人解决一个难题； 你要把精力集中在你知道的、能做的和拥有的事情上。 PS:做自己擅长和喜欢的事情，这件事情要给别人带来价值。 写成功日记 每天花10分钟，写下你这一天的五个成果。千万别被“成功”这两个字误导了，你所记录的这些事情，不一定非得多重要，任何芝麻蒜皮的小事都可以写进去。比如，吉娅在第一次写成功日记时写道：今天我学习了挣钱的知识，攒了5马克钱，还制作了梦想相册。 怎么理财？ 什么是“会下金蛋的鹅”呢？书里说，从前有个农夫，他养了一只鹅。有一天，他在笼子里发现了一只金蛋，于是他把这只金蛋卖了，得到了很多钱。第二天笼子里又有了一个金蛋。这样的好运持续了好几天。可是贪得无厌的农夫依然不知足，他认为这只鹅下金蛋的速度太慢了。于是，一怒之下，他把鹅劈成了两半。就这样，他的鹅死了，再也没法下金蛋了。 在这个故事里，“鹅”代表本金，它下的“金蛋”代表利息，用本金获取利息，也就是用钱生钱。在这个过程里，这个金蛋也被叫做是“被动收入”。就是说，你不用付出任何劳动，就能自动获得的收入，比如，银行存款的利息，出租房子的租金、出书的版税、股票的分红等等。 PS:&quot;被动收入&quot;是实现财务自由的关键因素 股票与基金 股票:大家对股票更熟悉一点，你买了这家公司的股票，就成了它的股东，每年可以享受分红。而且，你可以在证券市场上买进或是卖出股票。当然，作者说的欧美股票市场，和我们国家的股市，在规范程度和投资回报上都有所不同，借鉴意义有限，所以我们点到为止。 基金:基金就像一口大锅，投资者可以把自己的钱投进这口锅里，然后由基金经理人，帮大家投资买股票。你只需要付给经理人一定的佣金就行。因为基金这口锅里，有多种不同股票，里面某只股票的涨跌已经被分散稀释，所以风险比股票小，当然收益也相对比较少。但是从长期来看，找到稳定上涨的基金，投资5-10年，它就相当于是零风险，而且你的收益将会非常可观。 如何挑选基金 有10年以上历史的基金更值得购买。既然它在过去长期保持丰厚的利润，那么未来也是可以预期的。 选择大型的跨国股票基金。这种基金在全球范围内选取股票，风险比较低。 对比过去10年间，各种基金年终利润的走势图，选出最好的来投。 计算收益(72法则) 如何知道你投资的钱多长时间能翻一倍呢？:用 72除以一项投资的年收益率，得出的数字就是这笔钱翻一倍，所用的时间。比如，你买了一款年收益为6%的理财产品，用72除以6等于12，就是说，12年之后这笔钱就翻了一倍。 一笔钱多长时间会贬值二分之一:同理，用72除以通货膨胀率，得出的数字就是这笔钱贬值到只剩一半的时间。比如，通货膨胀率是6%，那么72除以6就等于12，也就是说12年后，你的100块钱就只能买现在50块钱的东西了。对理财新手来说，72法则是一个简单好用的工具。 规避风险 不要把鸡蛋都放在同一个篮子里:把你手头的资金分配在不同的投资方式，而且这些投资方式的回报率之间关联性越低越好 总结 要牢牢树立储蓄的意识，有的理财书籍建议每个月拿出收入的50%作为储蓄，对很多人来说，这个很难做到。那不妨从10%开始，每月发了工资，立马分出10%作为储蓄，如果能按月坚持，你就迈出了财富积累的第一步。不管你目前是否负债，储蓄这件事最好都要开始做、坚持做。 要开源节流，就是要增加收入、控制消费。想要挣钱，就要为别人解决一个难题，这件事最好是你擅长的、喜欢的。有了收入，还要控制消费。因为消费通常会随着收入，水涨船高，人们甚至会超前消费，为了消费而去负债，比如，花信用卡、申请消费贷款等等。作者建议，量入为出，一定要避免不必要的消费 有了一定的储蓄，就达到了投资的门槛。投资就是要养一只会下金蛋的鹅。《小狗钱钱》建议吉娅设立一个金鹅账户，就是会下金蛋的鹅，可以按照5-4-1的原则，把每个月可支配收入的50%存入金鹅账户，用来投资，用钱生钱","tags":[{"name":"book","slug":"book","permalink":"https://hinzer.github.io/wiki/tags/book/"}],"categories":[{"name":"生活学习","slug":"生活学习","permalink":"https://hinzer.github.io/wiki/categories/生活学习/"},{"name":"读书笔记","slug":"生活学习/读书笔记","permalink":"https://hinzer.github.io/wiki/categories/生活学习/读书笔记/"}]},{"title":"ctags","date":"2020-03-15T23:46:33.000Z","path":"技术开发/测试方法/ctags/","text":"ctags是方便阅读源代码的工具。开发者在linux平台下和vim编辑器配合使用,这种策略经常被用于linux源码阅读。 开发环境 12hinzer@ubuntu:~$ uname -aLinux ubuntu 5.3.0-40-generic #32~18.04.1-Ubuntu SMP Mon Feb 3 14:05:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 关于2.6.11版本的kernel源码下载 12hinzer@ubuntu:source$ wget -O kernel https://mirrors.edge.kernel.org/pub/linux/kernel/v2.6/linux-2.6.11.tar.gzhinzer@ubuntu:source$ tar -xzvf kernel.tar.gz 安装 1sudo apt-get install ctags -y 配置 在当前目录下生成索引文件 12hinzer@ubuntu:source$ cd linux-2.6.11/hinzer@ubuntu:linux-2.6.11$ ctags -R . #生成索引tags sudo vim /etc/vim/vimrc配置vim 1hinzer@ubuntu:~$ sudo vim ~/.vimrc #添加 set tags=/home/hinzer/source/linux-2.6.11/tags; 使用演示 命令行索引tag 123hinzer@ubuntu:linux-2.6.11$ ctags -R . #生成索引tagshinzer@ubuntu:linux-2.6.11$ ll tagshinzer@ubuntu:linux-2.6.11$ vim -t main #查找main函数 vim中使用ctags命令 12345:ts #tagslist,列出索引list:tp #tagspreview 上一个tag:tn #tagsnext 下一个tagCtrl+ ] #通过光标位置 跳转到定义处Ctrl+ T #返回上一步的光标位置 参考资料 百度百科ctags linux kernel","tags":[{"name":"ctags","slug":"ctags","permalink":"https://hinzer.github.io/wiki/tags/ctags/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"测试方法","slug":"技术开发/测试方法","permalink":"https://hinzer.github.io/wiki/categories/技术开发/测试方法/"}]},{"title":"Welcome hinzer's Wiki Site","date":"2020-03-14T17:55:57.000Z","path":"index/","text":"关于wiki 知识是自己构建的，不是搬运来的。建立个人wiki的目的是将此作为一个知识整理的平台，虽然维基百科已经足够好了，但终究不是自己的，希望能建立自己的知识库(也可以理解为对已有知识的二次整理)。 万丈高楼平地起，起步阶段咱也不需要写的多好，随着理解的慢慢深入，自然能写出高水准的wiki。 这是一个基于Hexo框架的Wiki系统，Hexo是开源框架同时也支持很多主题，这里就采用了Wikitten的主题样式。然而我不关心这个，当然也不擅长这个(大佬们做好的轮子，拿来用就好了)。 组织结构 先将wiki列表简单分几个大类 技术开发 非核心技术，仅要求了解即可，方便以后随时查询。涉及面应该广一些，包括但不仅限于: 工程规范、开发工具、源码管理、测试方法。 计算机基础 核心技术，需要长期学习和理解的领域，掌握程度高一些。并不奢求一次就能写的多好，要求有更深的理解了，回来补充和修正。至少包括: 开发平台、常用算法、数据结构。 生活学习 其他方向归于这个分类 部署指南 Hexo 官方文档 zthxxx wiki源码 Wikitten 主题地址","tags":[{"name":"wiki","slug":"wiki","permalink":"https://hinzer.github.io/wiki/tags/wiki/"}],"categories":[]},{"title":"年度总结2019","date":"2019-12-31T15:59:19.000Z","path":"生活学习/随笔记录/年度总结2019/","text":"2019年又要到底了，有必要写一个总结，看看过去的一年时间了干了些什么。。另，不知怎么，发现最近变得有些懒散，希望能重拾写作这个习惯。不管怎样，这不是一篇对自我批判或者激励自我的文章，总结记录，仅此而已。 今年跨年在看罗胖演讲时间的朋友，最多听到的是网络、连接、点亮这些字眼，无论是个人、行业、国家，都在积极地对外输出自己的价值(连接)，塑造自己的品牌影响力(网络)。今后是网络化的时代。 对于我而言，如何和别人建立好的连接，结出自己的网络，可能需要想搞清楚几个问题： 我是谁？ 我干啥？ 我为谁干？ 别人需要我么？ 社会更好了么？ 这些问题我想留给下年，下一个年终总结。 过去的2019 过去一年里发生了很多&quot;第一次&quot;，第一次去了杭州合肥这些城市、第一次写年终总结、第一次找工作的过程，经历了社招和校招，也体验过电话面试、现场面试和网络面试，如今第一次实习。 求职 这一年，我最大的期望就是找一份好的工作。在这个过程中，我发现有很多优秀的人、优秀的平台，通过他们的故事和分享，收获了很多实用的建议。 经过2018年，我已经把之前报的嵌入式的课程学的差不多了，随后又补习了Python，3月份左右去考试拿了一个二级证书。 有了找实习的意识，也经历过很多面试。最后有拿到几个实习offer，最后学校没给批，自己也没过于坚持，就没去成。 通过博客认识了几个有意思的小伙伴，有职场人，也有在校同学，收获了很多有用的建议 开始关注牛客网，后来认识了谱哥。这时大三也快结束了，后来找工作的打法也是从谱哥那里学习的。现在已签的offer也是在牛客上找的。 好朋友强哥参加比赛，晋级北京总决赛，团队人员替换，我跟着强哥去北京待了一周，确实是长见识了。 暑假留校学习，完善自己的技术栈。刷剑指offer、网上找内推、投简历，这样坚持一个月。可能感到这样闷头学习没有意思，想出去面试一下，想着以后也要在家乡发展，我订一张火车票就回安徽。在合肥、杭州这些地方转悠一圈，面了十多家公司，有大有小，大多给了offer。这是我今年最正确的决定，后来的面试也有了一定的底气。 开学回到学校，这时发现我是班中唯一一个拿到offer的人，心中一阵窃喜。。后来参加一次网络面试，也就是我现在这家。再后来秋招正式开始也都没怎么参加。 拿到满意offer后，报名了驾考，过了科目一和科目二。 生活 其实在大多时间还是宅在屋里，时间久了，养成一个孤僻的性格，现在多多少少有些抵触与外界的接触。 这一年记录了77篇博客，大多是技术相关的，生活记录有些少了。 办了一张半年的健身卡，坚持每周4天，30min左右活动时间。每次健身之后可以获得身心愉悦，确实不错。 寒假和暑假的时间挺长，真正在家里没过多久。感觉在家里闲不住，想着以后就没有寒暑假了，应该多陪陪家人。 大学里的同学，同一专业的还认识一些。高中同学现在还能常保持联系的也就两个。很多以前关系还不错的朋友，不怎么联络，关系也就慢慢疏远了。 来到东北之后也很少出去走走，对校园之外的世界接触太少。貌似从大三之后就比较宅了，现在实习了。 对现状的思考 大四学生，目前在北京实习，内容是android系统适配，实习还算轻松，但职场上不能很好的适应，仍感到些许压力。 入职 第一次走出校门，进入职场。那天正好是双11，有一个多月了。现在对工作上需要哪些技术，基本上有一个了解。当然还有诸多问题，对自己定位不清晰、目前还没有一个明确的职业规划、所在岗位注重哪些能力，如何针对性的培养等等 性格 或许是出于小时候的成长环境的原因，养成了一个内向的性格。后来，进入大学后，也或许是内向的性格让我选择了学习技术(也可能因为兴趣，但那是之后的事情了),渐渐不与人交流，越来越不善表达了。我始终觉得自己和那些在大学里整天待在宿舍打游戏为了逃避学业，或者整天考研为了逃避就业没什么两样，多少有点逃避的意思。 幸运的是我在学习技术的过程中，有段时间真的体验到了乐趣；不幸的是，社交与沟通能力成为了我最大的短板，比较头疼。 求职找工作那段时间，我感觉比较&quot;充实&quot;,因为当时体会到以前学过的那些知识、技能给我带来的价值。后来进入职场，暴露出自己的社交能力的短板，确实比较难受。 反省 人的本性是在成功时寻找内因，失败了寻找外因。特别是在没有什么可以值得炫耀的时候，总是拒绝面对现实，拒绝反省自己。 其实经历的每一件事都是一次成长的机会，通过总结记录的方式，反思和审视自己。 我是一个&quot;懒人&quot;，平时很少思考，更不愿意去主动总结。大概原因归纳如下： 对事情的理解往往只流于表面，没有深入的理解，也常常感到没有什么值得去写的东西 每次写作的过程中，往往&quot;咬文爵字&quot;，浪费很长时间，会感觉投入产出不成正比 总想利用大块时间一次性写完，但往往没有这种时间，要么贪玩，或者去做别的事情了 针对上面问题的反省，我需要： 最重要的一点，不要搞错总结的目的。总结是给自己看的，每次总结都能提炼出一些有用的东西，这就是总结的价值。 相信持续写下去，文字表述能力自然会提高上去。 养成提问和记录的习惯之后，随时记录考虑的问题，形成主题列表。确定要写的主题，先立大纲，拆分每个部分到碎片时间去实现，利用周末时间拼接起来。 即将到来的2020 期望未来自己，可以协调好学习、工作、生活三者，让生活更加充实。 期望改掉的毛病 [ ] 熬夜 [ ] 懒 [ ] 不善于表达，通常显得冷静而无情 期望养成的习惯 [ ] 早睡早起 [ ] 多进行思考总结，主要方式是记录，经常写日志进行日常总结、写博客进行工作总结 [ ] 必须直接地表达出对他人的欣赏，而不是仅仅保留在内心 [ ] 主动去联系老朋友，至少一个月联系一次嘛 期望达成的目标 [ ] 作息时间 5:10(早)~11:30(晚) [ ] 持续写博客 每周至少产出一篇 [ ] 开始接触金融学 投资、理财、保险… [ ] 多读一些心理学的书，多了解自己 [ ] 坚持健身(久坐生病，需要适当运动)","tags":[{"name":"record","slug":"record","permalink":"https://hinzer.github.io/wiki/tags/record/"},{"name":"2019","slug":"2019","permalink":"https://hinzer.github.io/wiki/tags/2019/"}],"categories":[{"name":"生活学习","slug":"生活学习","permalink":"https://hinzer.github.io/wiki/categories/生活学习/"},{"name":"随笔记录","slug":"生活学习/随笔记录","permalink":"https://hinzer.github.io/wiki/categories/生活学习/随笔记录/"}]},{"title":"github搜索开源项目","date":"2019-12-29T11:40:58.000Z","path":"技术开发/源码管理/github搜索开源项目/","text":"1、从名字中搜关键词 in:name example 2、搜索readme文件 in:readme example 3、描述中搜索关键词 in:description example 4、追加限定条件 stars:&gt;3000 # 限定在stars数量大于3000的项目 fork:&gt;50 # fork 数量 pushed:&gt;2019-09-10 # 最后一次push的时间 language:java # 限定语言 参考资料 github官方文档-搜索 如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程","tags":[{"name":"github","slug":"github","permalink":"https://hinzer.github.io/wiki/tags/github/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"https://hinzer.github.io/wiki/categories/技术开发/"},{"name":"源码管理","slug":"技术开发/源码管理","permalink":"https://hinzer.github.io/wiki/categories/技术开发/源码管理/"}]},{"title":"提问","date":"2019-12-10T01:10:12.000Z","path":"生活学习/方法习惯/关于提问/","text":"问问题，如何问 错误问法： - 某某出错了，怎么办？ —&gt;太模糊 - 如何针对某某封装一个库？ —&gt;太庞大 正确问法： - 目的 + 就此目的提出的手段 + 走到这一步的障碍 (解答题) - 提供选项 + 展现探索了哪些路径 (选择题) - 付出态度，表达感谢 + 提供一份可供交换的视角 (交换价值) 原则： - 提供足够多的信息，让人能够回答 - 提供足够多的选项，让人方便回答 - 提供交换价值，建立讨论基础;表达感谢态度，让人乐于回答 记录问题，定期回顾 问题上下文 问题具体描述 问题的解决思考和思路 问题的解决方案和具体技术或办法 问题解决后留下的思考或其他延伸的疑问 这就是积累价值和传递价值的方式，定期记录与回顾，终有所获！ 问问题，为何问 … 参考资料 《提问的智慧》 《程序员进阶攻略》","tags":[{"name":"方法","slug":"方法","permalink":"https://hinzer.github.io/wiki/tags/方法/"},{"name":"问题","slug":"问题","permalink":"https://hinzer.github.io/wiki/tags/问题/"}],"categories":[{"name":"生活学习","slug":"生活学习","permalink":"https://hinzer.github.io/wiki/categories/生活学习/"},{"name":"方法习惯","slug":"生活学习/方法习惯","permalink":"https://hinzer.github.io/wiki/categories/生活学习/方法习惯/"}]},{"title":"「转」详谈typedef的用法","date":"2019-10-09T23:42:21.000Z","path":"计算机基础/编程语言/typedef理解/","text":"我们都知道typedef是类型重定义，既然是重定义就不可能出现新的数据类型，只是将已有的数据类型进行换个名字而已，但是这有什么用呢？ 可能我们学的时候，给的例子都是：typedef int INT; 然后再用INT去定义一些变量，例如： 12typedef int INT;INT a; 这个就等于int a; 我们当时感觉不出来有什么用，当学到结构体的时候，可能觉得会减少数据类型的写法，像struct student这样一个结构体定义变量的时候如果不用typedef就只能struct student(当然这是在C语言中，在C++中可以省略掉struct直接写student)，这样感觉很麻烦，所以才想到用typedef，但是这是他的用法之一，却不是为唯一的用法。 typedef的用法主要我总结了一下三点： 用法一 可以减少代码的书写量,就像我们经常能考虑到的，结构体这样“新的”数据类型，用typedef可以简化，而且不容易出错.例如: 1234567struct student&#123; int data; char name[10];&#125;; 当我们定义学生结构体的时候要这么定义struct student s1,s2,s3; 如果想定义结构体指针，我们可以这么定义,struct student *ps1, ps2; 显然ps2不是指针类型，但是好多初学者对指针不熟悉，所以容易出错，但是当我们用typedef的时候，就不会出现这样的错误了， 1234567typedef struct student&#123; int data; char name[10];&#125;stu, *pstu; 我们定义的时候可以这么定义stu s1, s2, s3; 定义结构体指针的时候，可以这么定义,pstu ps1, ps2; 这样ps1， ps2都是指针类型的变量 这是typedef的用法之一，也是比较常用的。 用法二 实现代码的复用性和可扩展性,如果一段代码没有扩展性和复用性，那么这段代码就不能算得上是一段特别规范的代码，就像我们为了实现代码的复用性，提高程序可读性的时候，用函数一样，提高代码的复用性和可扩展性是作为软件开发者必备的本领。一段好的代码，如果在别的项目中引用的话，如果功能类似，基本上改不了几行，这就是规范性的重要性(这里先不谈规范性，但是这个typedef的用法也涉及规范性，嘿嘿，所以规范是避免不了的)。就这么来说吧，假如我们定义了一个结构体 1234567struct student&#123; int score; char name[10];&#125;; 我们想把成绩改成double类型的，应为int的精度太低了，但是下面用到的地方可能都要改掉，但是，我们要是用typedef一下， 问题就变得简单多了， 123456789typedef int typeitem；struct student&#123; typeitem score; char name[10];&#125;; 这样直接改typedef就行了，其他的代码根本不用动，这就是分层的原因，我们只改变最底层的，上层的东西根本不用变（就像在链表中，我们可以把它分为三层，纯数据层、节点层、head指针层，也就是整条链)这样分层处理问题会变得简单得多。还有就是平台不同可以兼容，就像有的平台不支持long double类型，但是你如果定义了long double 直接不能用，但是如果这么 typedef long double typeitem； 直接改成可以支持的类型就行啦，根本不用那么麻烦改下面的代码，这也是比较重要的用途。 用法三 简化，提高可读性。想必大家觉得，这个用途不是包含在上面的用途之中了吗，为什么还要再说一遍呢，其实我举个例子你也就明白了，typedef int array[10];，这个代表什么意思，这可不是平时那种array[10]是个int了吧，这个代表，array是个重定义的类型，array a；就代表a是一个含有10个int型元素的数组，这么定义可能觉得简化不了多少，还不如直接int a[10]; 看着明白呢，好! 继续往下看,typedef array Array[5]; 这个呢，如果我这么定义一个变量 Array arr[2]; 这个又是什么意思呢？这个就是定义个Array类型数组，其中这个“一维”数组有两个元素，但是每个元素又都是Array 类型的，每个Array又是一个5行10列二维数组，所以arr就是一个三维数组，他就等于int arr[2][5][10]; 是不是看的有点蒙了， 其实在C语言中根本不存在多维数组，全部都是一维数组，只是一维数组里面又含一维数组，所以才构成了所谓的“多维”数组， 如果这样理解的话，是不是觉得多维数组也就不那么“神奇”了，变得简单了，没有那么晕了，这样定义的好处就是可以讲一个多维的数组转化成我们比较熟悉的一维数组，这样操作起来就比较容易了，可读性自然也会增强。所以这就是他的“简化”的作用。 其实我们还可以在函数指针上体现，想定义个函数指针int (*p)(); 我们可以定义为typedef int (*POWER)(); 接下来可以直接定义POWER p1, p2; 他就等价于int (*p1)(), int (*p2)(); 这样也非常易懂。 定义方法 下面来谈一下他的定义过程，说了这么多，还没讲到怎么定义，其实也就三步: 第一步: 按照定义变量的方法先写出定义体(想必这么都比较熟悉吧), 例如: int a; 第二步: 将变量名换成想要重定义的名字 例如: int INT; 第三步: 在最前面加上typedef 例如: typedef int INT; 整个步骤就完成了，下面就可以用重定义的类型定义变量了:例如: INT a; 就是这么简单，不要想那么复杂。 与宏定义 还有就是与宏定义区分开来，宏定义是在编译预处理的时候直接进行的替换，而typedef却不是，宏定义特别是写那个表达式的时候新手容易出错就是不能真正理解宏替换，就像这么例子: #define mul(a, b) a * b ，如果这么写mul(2, 3)那么恭喜，你对了， 但是如果这么写， mul(2 + 1, 3 + 4); 你的出来的结果一定是错的，它只是简单地替换， 不会像函数那样会先计算出来2 + 1 等于 3 然后在进行计算， 它只能替换为2 + 1 * 3 + 4 所以结果当然错了……新手注意点就好了，这东西挺简单的。 大致就将这么多，如果那里写的不好，多多指教，多多补充！ 转载于：Howe_Young","tags":[{"name":"typedef","slug":"typedef","permalink":"https://hinzer.github.io/wiki/tags/typedef/"},{"name":"C","slug":"C","permalink":"https://hinzer.github.io/wiki/tags/C/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/"},{"name":"编程语言","slug":"计算机基础/编程语言","permalink":"https://hinzer.github.io/wiki/categories/计算机基础/编程语言/"}]}]}